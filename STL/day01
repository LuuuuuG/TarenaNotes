/**************************************************************************/
*															              *	*							  day_01	                                  *	
*									                                      *
/**************************************************************************/




静态类型系统:标识符的类型在运行期不可改变
动态类型系统:标识符的类型在运行期可动态变化

int i;

 C/C++是静态类型语言,类型信息都是编译期间确定的,运行时不可改变与类型相关的一切属性。

	优点：性能卓越。
	缺点：缺乏灵活性,不适用编写与类型无关的通用算法和数据结构。


一、模版起源
	1. 针对具体类型的实现
	  C/C++语言的静态类型系统,在满足效率和安全性要求的同时,很大程度上也成为阻碍
	  程序员编写通用代码的 。它迫使人们不的不为没一种数据类型编写完全或几乎完全相同
	  的代码,虽然他们在抽象层面上是一致的。

	2. 摆脱类型的限制————Live free or die
		借助参数宏可以摆脱类型限定
	  	宏定义只是在预处理器的作用下,针对源代码的文本替换,其本身并不具备函数语义。
	  因此借助鱼参数宏可以子啊某种程度上是程序的编写着摆脱那些源于类型的约束和限制,
	  但同时也因此丧失了类型的安全性。



	3. 两全其美的解决之道
		利用宏定义构建通用代码框架,让预处理器将其扩展为针对不同类型的句i他版本。将
	  宏的一般性和函数的类型安全性“完美”地结合起来。
		美中不足的是,必须显式调用所定义的宏,否则预处理器不会扩展出针对具体类型的函数
	  定义,而且宏无法单步调试。



二、函数模版
   	1. 定义
		template<typename 类型形参1,typename 类型形参2,..>
 	  返回类型 函数名 (调用形参表) [常属性] [异常说明] {函数体;}
	  类型形参可以用于函数的返回类型、形参表以及函数体,表示一种参数化的类型。

   	2. 使用
		函数名<类型实参1,类型实参2,..> (调用实参表);
		类型实参即用于传递模版类型形参的各种具体类型,如：
		  int/float/double/string/Student/Teacher...

   	3. 实例化
		编译器根据调用函数模版时所提供的类型实参,按照从前到后的顺序,依次结合函数
	  模版的类型形参,得到一个针对类型实参的具体函数,并编译之,这个过程叫做函数模版
	  的实例化。函数模版并不代表一个具体函数,也不存在于目标模块,当然也不参加链接,
	  它实际上表示的是一组具有重载关系的函数族。

   	4. 类型参数
		无论基本类型,还是类类型都可以作为函数模版的类型实参,唯一的条件就是该类型
	  必须满足函数模版的要求,否则将导致编译失败。


   	5. 二次编译
		与普通函数不同,函数模版事实上至少要被编译两次,第一次是在实例化之间,先检查
	  模版代码本身,做与类型参数无关的语法处理,生成该函数模版内部表示。
		第二次实在实例化期间,用所提供的类型实参结合内部表示中的类型形参,在完成与类型
	  相关的语法处理以后,生成二进制形式的机器指令。有时候,编译器会将本来应该在第二次
	  编译时处理的问题,提前到第一次编译时处理,由于此时的类型参数尚不明确,可能引发
	  编译失败,需要使用特殊的处理手段予以避免。


   	6. 隐式推断
		如果函数模版的调用参数的类型相关于该模版的类型参数,那么在调用该函数模版时,
	  即使不显式制定传给模版的类型实参,编译器也有能力根据调用参数的类型隐式推断出
	  正确的模版参数,以获得与普通函数调用一致的语法形式。但是,有时候隐式推断出的
	  类型可能和程序设计者所期望的类型不一致,导致结果异于预期,需要引起注意。

   	7. 函数模板的重载
		函数模板和函数模板,以及函数模版和普通函数之间也可以构成重载关系,与普通函数
	  之间的重载不同,函数模板的重载在解析规则中增加了类型针对性越强越优先匹配的条件


三、类模板

	1. 如果一个类中的成员变量、成员函数、成员类型,乃至基类中使用了参数化的类型,那么
	这个类就是一个类模板。
template<typename 类型形参1,typename 类型形参2,..>
class 类模板名 {..};

template<typename M,typename R,typename A,
	typename V,typename T,typename B>
class MyClass : public B{
	M m_mem;
	R function (A arg) {.. V var; ..}
	typedef T* PT;
};

	2. 使用
	  类模板名<类型实参1,类型实参2,..> 对象 (构造实参表);
	  类模板名<类型实参1,类型实参2,..> &引用 = 对象;
	  类模板名<类型实参1,类型实参2,..> * 指针 = &对象;
	  |<------------类-------------->|

	MyClass<char,short,int,float,double,string> mc;
	MyClass<char,short,int,float,double,string>& r = mc;
	MyClass<char,short,int,float,double,string>* p = &mc;
	MyClass mc;//error
	MyClass& r = mc;//error
	MyClass* p = &mc;//error

	类模板本身不是一个类型,当然也不是一个合法作用域,因此既不能用于对象、引用和指针
  的声明,也不能放在作用域限定操作符(::)前面,只有戴上足够的类型实参,这才是一个完整
  的类，可以用在一切类可以出现的上下文中。 



	3. 两步实例化
			编译期		运行期
		类模板-实例化->类-实例化->对象
			编译器		处理器
			  V			  V
	      成员函数的	  
		  第一次编译

		  看到对成员
		  函数的调用
		  第二次编译


	4. 类型参数
	  1)与函数模板不同,类模板并不要求实例化该模板的类型实参支持模板对类型的所有要求,
	  实例化该模板的类型实参只需要满足用到的成员函数对它的要求即可。

	  2)作为类模板的设计者,对于实例化该模板的类型要求越少越好。
		而作为类模板的使用者,对于用不着的功能可以不予支持。



	5. 类模板的静态成员变量
		类模板的静态成员变量,既不是一个模板一份实例,也不是一个对象一份实例,而是在该
	  模板的每个实例化类中各有一份实例,且为该类的每个对象所共享。
class A {int x;};
	A
 /  |  \
a1 a2  a3
x  x   x

class A {statci int x;};
	A
	x
 /  |  \
a1 a2  a3

template<typename...>
class M {static int x;};




	6. 递归实例化
		用一个类模板的实例化类型,实例化该类模板自身。主要用于表示在空间上具有递归
	  特性的数据结构,如:多维数组、二叉树等;.


	7. 全类特(例)化
		一个类模板在满足大多数类型要求的同时,可能对一些特殊类型无法给出正确的结果,
	  或者虽然能给出正确的结果,但性能不佳。这个时候可以提供一个针对特殊类型的
	  特殊实现,以弥补通用版本在功能和性能方面的不足。

	  1)全类特化
		template<>
		class 类模板名<特化所针对的类型> {定义一个具体类};
		当用户用特化所针对的类型实例化该类模板时,编译器将选择特化的版本而非通用版本
	  在特化版本中,程序设计者可以完全依赖所针对的特殊类型进行功能设计和性能优化。	

	  2)成员特化
		如果与特殊类型相关的仅仅是几个别的成员函数,那么也可以只针对这些成员函数做
	  专门的特化。

		template<>
		返回类型 类模板名<特化所针对的类型>::成员函数名(
			形参表)[常属性][异常说明]{定义一个具体函数}
		成员特化只是给一个成员函数针对特殊类型的新的定义,其声明依然在通用版本中,因此
	  特化版本的原型和通用版本的原型,除了一个是具体类型,一个是参数类型以外,
 	  必须完全一致。


	  3)从类模板的设计角度讲,不要将特化作为模板缺乏一般性的借口。所谓类模板特化应该
		被视为一种无奈之举,后者是一种权宜之计,而不应作为设计原则。
		
		

	8. 局部特化
	  	template<typename A,typename B> 
		calss X {..};//通用版本
	  	template<>
		calss X {int,short};//完全特化
	  	template<typename A> 
		calss X<A,short>{..};//局部特化

	  类模板可以被局部的特例化,即一方面为类模板指定特定的实现,另一方面又允许用户
	对部分类型参数自行指定。


	9. 案例:std::auto_ptr<T>的简化实现
int i = 100;
int* p =&i;
int* q = p;


四、模板参数的缺省值
template<typename A = int,typename B = double>...
	模板的参数可以带有缺省值,实例化该模板时,如果提供了类型实参,就用所提供的实参,
  如果没提供类型实参,就取相应的缺省值。如果某个模板参数带有了缺省值,那么它后面的
  所有参数必须带有缺省值。
	void fuck(int x,int y = 10){..}//OK
	void fuck(int x,int y = x){..}//ERROR
	函数的参数,后面参数不能用前面的参数作为其缺省值。
	模板的参数,后面参数可以用前面的参数作为其缺省值。
	template<typename A,typename B = A>...
	
	C++98中,函数模板不能带有缺省参数,但是C++2011中可以,如果使用GNU的C++编译器
	需要加上编译选项：
		-std=c++0x //4.8以下版本
		-std=c++11 //4.8及以上版本


	当函数模板隐式推断的参数类型与模板参数的缺省值不一致时,以隐式推断的类型为准,
	忽略其缺省值。


五、模板的非类型参数
	void fuck (int x){..}
	fuck (10);
	int i = 10;
	fuck(i);

	  模板的参数并不局限于类型参数,普通的数值也可以作为模板的参数,但这些参数前面不要
	写typename,而要注明其具体类型。传递给模板非类型参数的实参,可以是常量、常量表达式
	带有常属性(const)的变量,但不能同时具有挥发性(volatile)。
	  此外,关于模板的非类型参数还有一下额外限制：
	1. 不能是浮点类型:float/double/long double
	2. 不能是非标量类型:Student/Teacher/Cat/Dog
	3. 可以是字符串但是只能指针作为形参,且只能用非静态的全局字符数组作为实参,
		否则无法通过编译。




六、typename关键字
	1. 声明模板的类型参数
	  template<typename T,...>...
	  等价于class关键字
		template<class T,...> ...

	2. 解决嵌套依赖
		嵌套依赖:
		typename T::A a; 不能换成class关键字

七、template关键字
	1. 声明模板
	  template<..>..
	2. 解决嵌套模板
		所谓嵌套模板,就是依赖于模板类型参数的内部模板。而且有时还需和typename关键字
	  配合使用。


八、子类模板访问基类模板
	  在子类模板中直接访问那些依赖于模板参数的基类模板的成员,编译器在第一次编译时,
	通常会因为基类类型不明确而只在子类和全局作用域中搜索所引用的符号。通过显式注明
	基类的作用域限定,或者显式使用this指针,可以迫使编译器在第二次编译时根据基类的
	声明检查所引用的符号,避免编译失败。



九、模板中的模板
十、模板型的模板成员和模板参数
十一、零初始化
十二、类模板与虚函数
	1. 类模板中可以包含虚函数,但是一定要注意,实例化该模板所用的类型实参一定不能违背
	  有效覆盖的条件,否则将导致编译错误,或者丧失多态特性。

	2. 如果一个类或者模板的成员函数带有自己的类型参数,那么该函数就是一个类或类模板的
 	  模板型成员函数,这样的成员函数不能同时又是虚函数。其原因就在于,模板函数的二次编	
	  译会阻碍虚函数表的静态构建。


十三、编译模型
	1. 单一模型：将模板的声明与实现放在同一个编译单元中。
template<typename T>
class A{
  void fuck(T atg){..}
};
	2. 分离模型:将模板的声明与实现分别放在.h和.cpp文件中
xxx.h
//声明
template<typename T>
class A{
	void fuck(T arg);
};
xxx.cpp
//实现
template<typename T>
void A<T>::fuck (T arg){..}

//不可行！！！

	3. 包含模型
	  在模板的声明文件末尾包含该模板的实现文件,强制模板的声明、实现和实例化都同处于
	  一个编译单元,保证对模板的二次编译能够正确执行,满足连接器的要求。但是,包含模型
	  会延长编译时间,而且模板的实现代码必须公开。

	4. 实例模型
		在模板实现文件中使用实例化指示符,强制编译器在编译该文件时,即根据特定的模板
	  实参对模板进行实例化,满足连接器的要求。但是,实例模型的实例化类型总是有限的,
	  对于用户自定义的各种类型无法提供完全的支持。

	5. 导出模型 export 导出关键字
		大多数的编译器都不支持 @_+
		GNU/Microsoft/IBM/HP/Oracle 等都不支持
		Edison Design,Inc.曾经支持
		C++2011 彻底删除了该特性,export 关键字被移作它用。
		



十四、预编译头文件


[common.h]
#include <unistd.h>
#include <iostream>
#include <iomanip>
using namespace std;
...

[a.cpp]
#include "common.h"
...

g++ -c common.h -> common.h.gch


微软:
stdafx.cpp -> <项目名>.pch
#include "stdafx.h"


十五、静态多态
	1. 动态多态：基于虚函数和动态绑定的多态。
	2. 静态多态：基于参数类型和模板的多态。



十六、容器、迭代器和泛型算法
	1. 容器：双向线性链表
	2. 迭代器：正向顺序迭代器
	3. 泛型算法：线性查找算法




标准模板库(Standard Templates Library,STL)
	
	容器:以类模板的形式实现不同的数据结构：数组、链表、堆栈、队列、二叉树等等。
	线性容器：向量(vector)、双端队列(deque)、列表(list)
	适配器容器：堆栈(stack)、队列(queue)、优先队列(priority_queue)
	关联容器:映射(map)、多重映射(multimap)、集合(set)、多重集合(multiset)

	每个容器都提供四个迭代器：
		正向迭代器：iterator
		常正向迭代器：const_iterator
		反向迭代器：reverse_iterator
		长反响迭代器：const_reverse_iterator

	  只有向量和双端队列这种连续的内存的容器才会提供随机迭代器,
	其他容器都只提供顺序迭代器。


‭	  基于迭代器,在与具体数据结构无关的前提下,以一种一般化的方式访问不同类型的容器,
	得到了一组泛型算法函数。一种容器是否可适用于特定的泛型算法,唯一的条件就是该容器
	满足算法对迭代器的要求。


	一、向量
	#include<vector>
	
	  1. 连续内存、下标访问、动态内存管理、静态内存预留。

	  2. 随机迭代器：可以和整数做加减运算、同型迭代器之间可以比较大小/相减,不能相加.
	
	  3. 成员函数
		front()/back()
		push_back()/pop_back()
		insert()/erase()
		clear()/size()/empty()
		begin()/begin() const 	-可写/只读起始正向迭代器
		end()/end() const	-可写/只读终止正向迭代器
		rbegin()/rbegin() const 	-可写/只读起始反向迭代器
		rend()/rend() const	-可写/只读终止反向迭代器

	4. 类类型向量元素
		如果向量中的元素类型是自定义类,往往该类需要支持如下特性:
		  	缺省构造函数、深拷贝的拷贝构造函数和拷贝复制运算符函数,如果需要搜索功能,
		  还需要"=="运算符,如果需要做坏虚,还需要支持"<"运算符,或者提供小于比较器。




二、双端队列(deque)
	#include<deque>

	1. 双端队列无论是实现还是功能几乎和向量完全一样。在存储结构上,双端队列也是连续
  	  内存,也支持下标访问和随机迭代,但是和向量不同,动态存储区的首端是开发,可以通过
	  push_front()/pop_front()成员函数,在容器的首端做元素的压入和弹出。
	
	2. 双端队列无论是内存空间还是操作时间都会略逊于向量。


三、列表(list)
	#include<list>
	
	1. 唯一化
		void unique(void);
		连续重复出现元素做唯一化。
	  10 10 20 20 10 20 30 20 20 20 10 10
					|unique()
					V
		  10 20 10 20 30 20 10	


	2. 排序
	void sort (void);
	通过元素类型的"<"比较大小。
	void sort(less cmp);
	通过小于比较器cmp比大小。


	3. 拆分
	  将参数列表的部分或全部剪切到调用列表的指定位置。
	e.g.
	void splice(IT pos,lsit& lst);
	  将lst列表中全部元素剪切到调用列表pos迭代器之前。
	void splice(IT pos,lsit& lst，IT del);
	  将lst列表中del迭代器所指向的元素剪切到调用列表pos迭代器之前。
	void splice(IT pos,lsit& lst，IT begin,IT end);
	  将lst列表中位于begin和end两个迭代器之间的元素剪切到调用列表pos迭代器之前。

		注: 在STL中凡是用两个迭代器表示一个范围,其终止迭代器一定是范围中
	  最后一个元素的下一个位置。

	/*
		时间复杂度：
				
			O(1) < O(log N) < O(N) < O(Nlog N) < O(N^2)


	*/



	3. 合并
	  将【有序】的参数列表的全部元素合并到有序调用列表中,合并后的调用列表
【依然有序】,参数列表为空。
	void merge (list& lst);
	void merge (list& lst,LESS less);
	


四、堆栈
	#include<stack>
	stack<元素类型,地层容器>
	底层容器：vector/deque(缺省)/list
	
	push	-> push_back
	pop		-> pop_back
	top		->back
	size	->size
	clear	->clear
	empty	->empty



五、队列
	#include<queue>
	queue<元素类型,底层容器>
	底层容器:deque(缺省)/list
	push-> push_back
	pop -> pop_front - 向量(vector)不能适配队列
	front -> front
	back ->back
	size	->size
	clear	->clear
	empty	->empty


六、优先队列
#include<queue>
priority_queue<元素类型,底层容器,小于比较器>
默认大者优先,通过小于比较器可以自定义优先级。
底层容器：vector/deque(缺省)
  
	每次压入元素,优先队列调整元素位置,保证优先级越高的元素越靠近队首,
    以保证优者先出的规则。

	小于比较器是优先队列类模板的类型参数,优先队列内部负责将该类实例化为对象,
	因此只能使用定义"()"操作符的类，而不能使用函数指针。

	注意:任何容器的迭代器都存在有效期,任何一种对容器内存布局构成影响的操作,
	  	都应该重置该迭代器。


七、映射
	#include<map>
	map<键类型,值类型>
	现实世界中普遍存在某种一一对应的关系,如
	  居民身份证号码 -> 个人信息
	  学号  -> 成绩
	查询线索称为健,被查询的信息称为值。在映射中,可以根据健在对数时间(O(logN))内
	找到和它相对应的值。

	映射在逻辑层用一个平衡有序二叉树保存每个节点中的健和值。
	
平衡有序二叉树： 每个节点的左右子树中的元素个数最多相差一个的有序二叉树。
				保证搜索过程中的最优时间复杂度 = 最差时间复杂度 = 平均时间复杂度

	映射基本元素是pair,每个pair包含健和值两份数据。

template<typename FIRST,typename SECOND>
class pair{
public:
	pair (FIRST const& f,SECOND const& s):
		first(f),second (s){}
	FIRST first;
	SECOND second;
};
	映射节点中存放pair对象,其中first表示健,second表示值,一句健构成有序树。
		

	投票选举系统
	五个候选人
	十个人投票
	A——E五个字符分别对应每个候选人

	map<char,Candicate>

	可以通过比较器类型自定义建的排序规则。


八、多重映射
	允许健重复的映射,表示一对多的关系。不再支持下标访问。
	
	IT lower_bound (KEY const& key); //返回匹配下限
	IT upper_bound (KEY const& key); //返回匹配上限
	
	A - 100
	A - 200
	B - 300 <- lower_bound('B')
	B - 400
	B - 500
	C - 600 <- upper_bound('B')
	C - 700

	pair<IT,IT> equal_range (KEY const& key);
		//返回匹配范围,其中first是匹配下限,second是匹配上限
	



九、集合
	#include<set>
	set<元素类型>
	没有值的映射。

十、多重集合
	#include<set>
	multiset<元素类型>
	没有值的多重映射。


十一、其他工具
	遍历：for_each





















