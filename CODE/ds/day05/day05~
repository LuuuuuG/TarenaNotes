/**************************************************************************/
*									   *		
*				day_05					   *	
*									   *
/**************************************************************************/



		


			/*二叉树 Binary Tree*/

	1. 二叉树
	1.1 基本概念
		1)栈/队列/链表 属于逻辑结构中的线性结构；
		二叉树 属于逻辑结构中的树型结构；

		2)在计算机中，二叉树就是指每个节点最多只有两个子节点的树型结构，
			也就是最多只有两个分叉的树型结构。
		
		3)树型结构的起始节点叫做/*根节点*/，除了根节点之外，
		其他每个节点有且只有一个父节点，而整颗树有且只有一个根节点。

		4)其中没有任何子节点的节点叫做//叶子节点，
		叶子节点有父节点但是没有子节点。


		5)除了根结点和叶子节点之外，其他节点叫做//枝节点。
		枝节点有父节点也有子节点；

		6)左边的子节点叫做/*左子节点*/，右边的子节点叫做/*右子节点*/。

		7)高度(层数)h
		  每层节点个数	2^(h-1)
		  最多节点	2^h

		8)如果该二叉树中每层节点个数都达到了最大值，
		  并且所有枝节点都有两个子节点，这样的二叉树称为/*满二叉树*/。

		9)如果该二叉树中,除了最下面一层，其他每层节点个数都达到了最大值，
		并且最下面一层的所有节点都连续集中在左侧，此二叉树/*完全二叉树*/。



	1.2 基本特征
		二叉树具有递归嵌套式的空间结构特征，
		因此采用递归的方法去处理二叉树问题，会使处理算法更加简洁，
		方法如下:
		
	    处理(二叉树){
				if(二叉树为空)直接处理；
			}
			else{
				处理左子树(以左子节点为根节点的小二叉树); -递归
				处理右子树(以右子节点为根节点的小二叉树); -递归
				处理根结点;
			}
		}


		
	1.3 存储结构
		
		1) 顺序存储

			一般来说，从上到下，从左到右依次存放各个节点，
			对于非完全二叉树需要使用虚节点补成完全二叉树。

		2) 链式存储
	
			一般来说，每个节点包括三部分内容:一个记录数据元素本身，
			和两个分别指向左右子节点地址的指针。
			如:
				typedef struct node{
				    int data;//记录数据元素本身
				    struct node* left;//记录左子节点地址
				    struct node* right;//记录右子节点地址
				}Node;	

			//三叉链表，多了一个记录父节点的地址。


	1.4 基本操作
		
		创建		binary_tree_create
		销毁		binary_tree_destroy
		插入		binary_tree_insert
		遍历		binary_tree_travel
		删除		binary_tree_delete
		修改		binary_tree_modify
		查找		binary_tree_find
		判空		binary_tree_empty
		判满		binary_tree_full
		查看根结点元素	binary_tree_root
		计算有效元素	binary_tree_size
		清空		binary_tree_clear	

	1.5 遍历方式

		1) 先序遍历(DLR => data left right)
				
			先遍历根节点，再左子树，最后右子树。
			又称 先根遍历。

		2) 中序遍历(LDR => left data right)	
			
			先遍历左子树，再根节点，最后右子树。
			又称 中根遍历
	
		3) 后序遍历(LDR => left right data)

			先遍历左子树，再右子树，最后根节点。
			又称 后根遍历


		e.g.		30
			       /   \
			      20    35		(有序二叉树)
 			     /  \  /  \			
			    15  25 30  40 	


		先根 : (30) [20] 15  25  [35]  40
		中根 :  15  [20] 25 (30) [35]  40
		后根 :  15   25 [20] 40  [35] (30)
			

	1.6 有序二叉树
  	   满足一下三个条件的非空二叉树就叫做有序二叉树
	   1)如果左子树不为空，则左子树中所有节点的元素值都小于等于根节点元素值；
		
	   2)如果右子树不为空，则左子树中所有节点的元素值都大于等于根节点元素值

	   3)左右字数内部依然满足上述规则；

	实际应用:
		主要用于需要进行查找和排序的场合中，又叫做二叉查找树。


	【练习】
		组合成有序二叉树，使用三种方法进行遍历

		50(root) 70 20 60 40 30 10 90 80
			 root	
			  -->   50
			       /  \
			     20    70
			    / \   /  \
                           10 40 60   90
		   	      /	      /
			     30      80

		
		先 50 20 10 40 30 70 60 90 80 
		中 10 20 30 40 50 60 70 80 90
		后 10 30 40 20 60 80 90 70 50 				  

		

			/*二级指针复习*/

	/*二级指针的主要用途为用作形参接收一级指针实参的地址*/

		________________________________	
		    |  |      |  |        |  |    	
		    |  |      |  |        |  | 	
		____|__|______|__|________|__|__

		int num = 20;
		int* pn = &num;
		=>int* pn; pn = &num;

		int** ppn = &pn;
		=>int** ppn; ppn = &pn;



		************************
		&num = 0x10 ; num = 20;
		
		&pn = 0x20 ;pn = & num = 0x10
		*pn = *(&num) = num = 20;

		 &ppn = 0x30 ;
		  ppn = pn = 0x20 
			//二级指针变量名表示 一级指针的地址
		 *ppn = *(&pn) = pn = &num = 0x10 
			//*二级指针变量名 --一级指针的内容 -- 普通变量的地址
		**ppn = *(*ppn) = *(&nnum) = num = 20;
			//**二级指针变量名 -- 普通变量的内容

	
		二级指针变量名表示一级指针的地址



****************************************


作业：
   编程实现有序二叉树的其他基本操作；
预习：
   (1)算法的概念和评价
   (2)常用的查找算法
   (3)常用的排序算法


























		
		
