/**************************************************************************/
*									   *		
*				day_06					   *	
*									   *
/**************************************************************************/


	
				/*算法*/

	1. 算法的概念和评价

	  1.1 基本概念

		算法就是对解题方案准确而又完整的描述，是一系列清晰的指令
		
	  1.2 评价标准

		(1)时间复杂度(重点！！！)
		   
		  -主要描述算法的时间消耗与问题规模之间的函数关系；
		
		(2)空间复杂度
	
		  -主要描述算法的空间消耗与问题规模之间的函数关系；

		(3)正确性

		  -主要描述算法的执行结果是否满足要求；

		(4)可读性

		  -主要描述算法本身是否便于阅读；

		(5)健壮性

		  -主要描述算法对非正常输入的反应和处理能力；

	1.3 描述方式
	
		常见的算法描述方式主要有:
		    自然语言、伪代码、结构化流程图、PAD图 ...



				/*查找算法*/

	2. 常用的查找算法
	
	2.1 线性查找算法(顺序查找算法)	//	O(N)
	    (1) 算法流程

		使用目标元素与样本数列中的第一个元素起，依次进行比较，
		如果找到了与目标元素相等的元素则表示查找成功；

		或者与所有的样本元素全部比较完毕，
		也没有找到与目标元素相等的元素，则表示查找失败。

   	    (2) 算法评价

		平均时间复杂都O(N),对样本的有序性不敏感。


	2.2 二分查找算法(折半查找算法)	//	O(log N)
		
	    (1) 算法流程
			
		假定样本数列中的所有元素从小到大依次进行排列，
		使用目标元素与样本数列中的中间元素进行比较，如果相等则查找成功;
		如果中间元素小于目标元素，则去中间元素的右边进行查找;
		如果中间元素大于目标元素，则去中间元素的左边进行查找;
		重复以上上过程，知道找到满足条件的目标元素为止则表示查找成功,
		或者与需要比较的元素比较完毕，则表示查找失败;

	    (2)	算法评价

		平均时间复杂度O(log N),要求样本元素必须有序;


**************************
//使用查找算法查找指定的目标元素
#include<stdio.h>


//1.0 实现线性查找
//平均时间复杂度O(N),对样本的有序性不敏感
int find(int arr[],int len,int data){
    int i = 0;
    for(i = 0;i < len;i++){
        if(data == arr[i]){
            return i;  //返回元素对应的下标
        }   
    }   
    return -1;  //表示查找失败;
}

//2.0 实现二分查找算法
//平均时间复杂度O(log N),要求样本元素必须有序;
int find_binary(int arr[],int left,int right,int data){
    
    if(left <= right){
        //1.计算中间元素的下标
        int p = (left + right) / 2;
        //2.使用目标元素与中间元素比较大小，相等返回
        if (data == arr[p]){
            return p;
        }   
        //3.如果目标元素小于中间元素，则在左边查找 --递归
        else if(data < arr[p]){
            return find_binary(arr,left,p - 1,data);
        }   
        //4.如果目标元素大于中间元素，则在右边查找 --递归
        else{
            return find_binary(arr,p + 1,right,data);
        }   
    }   
    return -1;  //表示查找失败
}
int main(){
    int arr[9] = {10,20,30,40,50,60,70,80,90};
    //int pos = find(arr,9,40);
    int pos = find_binary(arr,0,8,400);
    if(-1 != pos){
        printf("查找目标元素成功，所在下标是:%d\n",pos);//3     
    }
    else{
        printf("目标元素不存在\n");
    }
    return 0;
}
     



*******************************
			


				/*排序算法*/


	3 常用排序算法
		
	3.1 冒泡排序算法(重点)  /*每次保证选出一个位置确定的最大数*/
	
	    (1) 算法流程
		
			      (第1轮) (第2轮) (第3轮) (第4轮)	(n-1轮)	
			20	20	20	20  |	10	
			30	30	30  |	10  V	20
			50  |	40  |	10  V	30	30
			40  | 	10  V	40	40	40
			10  V 	50	50	50	50
	      【下沉】	      (最大)  (次大) 				
			
	
	

	    a.比较相邻位置的元素，如果第一个元素比第二个元素大，
	      则交换两个元素；	
	    b.从最开始的一对相邻位置元素到最后一对相邻位置的元素做同样的工作，
	      经过这一步，最后的元素将是最大值。
		
	    c.针对所有元素重复以上步骤，除了最后一个元素；

	    d.持续每次对越来越少的元素重复以上步骤，
  	      直到没有元素需要交换为止。	

		
		第一轮:
			j 和 j+1 比较，j的取值范围:[0，4)
		第二轮:
			j 和 j+1 比较，j的取值范围:[0，3)
		第三轮:
			j 和 j+1 比较，j的取值范围:[0，2)
		第四轮:
			j 和 j+1 比较，j的取值范围:[0，1)


		j 的取值范围: [0,n - i)

		
	    (2) 算法评价
		
		平均时间复杂度 O(N^2), 稳定，(加了flag)对样本的有序性非常敏感;



	3.2 插入排序算法

	    (1)算法流程
		
		【e.g.】 斗地主 码牌的过程就是不断的进行插入排序
		
		a.从第一个元素起，该元素可以认为已经有序
		b.将下一个元素取出，在已经有序的元素中从后向前进行扫描和比较
		c.如果左边元素大于取出的元素，则将左边元素赋值到下一个位置上(右移)
		d.如果左边元素小雨等于取出的元素，则将取出的元素插入到左边元素右边
		e.重复步骤b，直到处理完毕所有元素为止；
			


	    (2)算法评价
		
		平均时间复杂度O(N^2), 稳定，对样本的有序性非常敏感，
		但是赋值的次数比冒泡排序少，因此一般情况下略优于冒泡排序。


	3.3 选择排序算法	/*每次保证选出一个位置确定的最小数*/

	    (1)算法流程
		
		a.从第一个元素起依次取出，假定取出的元素是最小值，
		  并且使用变量min来记录该元素的下标；
		b.使用min记录的最小值与后续所有元素依次进行比较,
		  如果后续元素中有比min记录的最小值还小的元素,
		  则重新记录该元素的下标到min中,
		  也就是后续元素变成了min记录的最小值。
		c.知道min记录的最小值与后续所有元素比较完毕，
		  交换min记录的最小值和最开始假定的最小值；
		d.重复以上过程，知道处理完毕所有元素为止。



	    (2)算法评价
		
		平均时间复杂度  O(N^2),不稳定(相同数值的元素次序会发生改变),
		对样本有序性不敏感。
		虽然比较的次数比较多,但是交换的次数比较少,因此一般情况下略优于冒泡
		

	3.4 快速排序算法(BAT深度笔试题)

	    (1) 算法流程
	
		a.从样本数列中选择中间元素作为基准值，单独保存起来;
		b.重组数列，将所有比基准值小的元素都放在基准之的左边，
		  将所有比基准值大的元素都放在基准之的右边，
		  与基准之相等的元素可以放在任意一边，这个过程叫做分组。
		c.以递归的方式对小于基准值的分组和大于基准之的分组分别进行分组排序
	

		35 10 20 5 15 25 12 30 3 
		^	   ^	       ^	
		|	   |	       |
		i	   p 	       j


	    (2) 算法评价

		平均时间复杂度 O(log N),不稳定,有样本有序性不敏感。



************************
//变成实现各种排序算法
#include<stdio.h>

//1.0 冒泡排序算法
// 平均时间复杂度 O(N^2) 稳定 (加了flag)对样本的有序性非常敏感
void bubble(int arr[],int len){
    int i = 0,j = 0;
    //1 使用循环来控制比较的轮数
    for(i = 1;i < len;i++){
        //定义标志位,用来判断内层循环是否进行了交换
        int flag = 1;
        //2 使用循环来控制比较的元素下标范围
        for(j = 0;j < len - i;j++){
            //3 如果左边元素大于右边元素，则交换
            if(arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                flag = 0;
            }
        }
        //如果没有发生任何交换,说明已经是从小到大排序,结束冒泡排序
        if(1 == flag){
            break;//跳出循环
        }
    }
}

//2.0 插入排序
// 平均时间复杂度  O(N^2) 稳定，对样本的有序性非常敏感
void insert(int arr[],int len){
    int i = 0,j = 0;
    //1 使用循环将后续的元素依次取出
    for(i = 1;i < len;i++){
        //2 将取出的元素单独保存起来，避免被覆盖
        int temp = arr[i];
        /*
          3 使用取出的元素与左边元素一次进行比较，
            如果左边元素大于取出的元素，则左边元素右移          */
        for(j = i;arr[j - 1] > temp && j >= 1;j--){
            arr[j] = arr[j - 1];
        }
        //4 知道左边元素不再大于取出元素，则插入取出元素到左边元素的右边
        if(j != i){ //为了避免元素自己给自己赋值
            arr[j] = temp;
        }
    }
}

//3.0 选择排序
// 平均时间复杂度  O(N^2) 不稳定,对样本有序性不敏感
void choose(int arr[],int len){
    int i= 0,j = 0;
    //1 使用循环将第一个元素起依次取出
    for(i = 0;i < len - 1;i++){
        //2 使用临时变量记录取出元素的下标
        int min = i;
        //3 使用min记录的最小值与后续元素一次比较
        for(j = i + 1;j < len;j++){
            //4 如果后续元素中有小于min记录最小值的元素，则重新记录后续的这个元>素
            if(arr[j] < arr[min]){
                min = j;
            }
        }
        //5 直到使用min记录的元素与后续所有元素比较完毕为止,交换记录元素与最开始
假定的元素
        if(min != i){   //min变化了才交换
            int temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
    }
}

//4.0 快速排序
// 平均时间复杂度 O(log N),不稳定,有样本有序性不敏感。
void quick(int arr[],int left,int right){
    //1 计算中间元素的下标,单独保存起来
    int p = (left + right) / 2;
    int pivot = arr[p];
    //2 分别使用左右变量的元素依次和基准之进行比较，小放左，大放右
    int i = 0,j = 0;
    for(i = left,j = right;i < j;){
        //左有元素且小于基准元素,比较下一个元素
        while(i < p && arr[i] < pivot){
            i++;
        }
        //左有元素,但不再小于基准值,则将左边元素移动到p指向的位置,p指向该元素原>来的位置
        if(i < p/*左有元素*/){
            arr[p] = arr[i];
            p = i;
        }
        //右有元素且大于基准值,比较上一个元素
        while(j > p && arr[j] >= pivot){
            j--;
        }
        //右有元素,但不大于基准值,将右边元素移动到p指向的位置,p指向该元素原来的>位置
        if(j > p/*右有元素*/){
            arr[p] = arr[j];
            p = j;
        }
    }
    //3 直到左右两边元素下标重合时，放入基准值元素
    arr[p] = pivot;
    //4 对左右两边的分组递归再分组
    if(p - left > 1){
        quick(arr,left,p-1);
    }
    if(right - p > 1){
        quick(arr,p+1,right);
    }
}


int main(){
    int arr[9] = {35,10,30,5,15,30,12,20,3};
    //调用排序算法进行排序
//  bubble(arr,9);  //1.0 冒泡
//  insert(arr,9);  //2.0 插入
//  choose(arr,9);  //3.0 选择
    quick(arr,0,8); //4.0 快排
    //打印
    int i = 0;
    for(i = 0;i < 9;i++){
        printf("%d ",arr[i]);
    }
    printf("\n");
    return 0;
}








