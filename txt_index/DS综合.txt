
	DATESTRUCTURE
1、老师
	老师 马如忠 Maruzhong/ruzhong Ma
	小马哥	
	
	marz@tedu.cn

2、学习方法
	(1)课堂以听懂为主，尽量记笔记和代码;
	(2)程序员是代码喂出来的;
	(3)永久性的作业:苦练指法
 
3、课程简介
	(1)数据结构
	  栈，队列，链表，二叉树
	(2)算法
	  2种查找算法 + 4种排序算法
	(3)课程时间
	  时间 4 ~ 5 天
	(4)注意事项
   	  重点理解数据结构的特性以及算法的思想。

 ************************************************






/**************************************************************************/
*									   *		
*				day_01					   *	
*									   *
/**************************************************************************/



	1、数据结构的概念和分类
	2、栈的基本特征和基本操作




		/* 1. 数据结构的概念和分类 */
 
	如:
	   编程实现输入5个学生成绩并计算总成绩和平均成绩？？？
		int scores[5];

	/*数组名表示数组的首地址，也就是数组中第一个元素的首地址，
	  数组名是个常量，不可改变；*/
		scores = &scores[0];
	通过数组名加下标的方式可以访问连续内存中的任意一块区域，
         但是切记不要越界访问；
	
	scores[2] <=> *(scores + 2) <=> *(2 + scores) <=> 2[scores]
					//笔试题！
		


	1.1 基本概念

	在计算机中，/*数据结构*/就是指数据在计算机中的存储和组织形式，
        	也就是一种或者多种特定关系的数据的集合。

	一般来说，数据结构的选择会直接影响到程序的执行效率(时间复杂度)和存储效率(空间复杂度) 
	
//	计算机程序 = 数据结构 + 算法;



	1.2 数据结构的三个层次

	1)逻辑结构 (集合结构、线性结构、树型结构、网状结构)
	  	-主要描述数据元素之间的逻辑关系；


	2)物理结构 (顺序结构、链式结构)
		-主要描述数据元素在计算机中的存储形式，也就是位置关系；


	3)运算结构
		-主要描述数据结构的实现方式以及基本特征；


	1.3 逻辑结构的分类

	1)集合结构
		-主要描述所有数据元素都属于一个整体，不强调数据元素之间的关系；
		【e.g.】
			-CSD1602班 
			-2 3 5 7 11 13 17 ... 统称为 质数/素数
			

	2)线性结构
		-主要描述数据元素之间存在一对一的前后关系；

		该结构中有且仅有唯一的首元素,有且仅有唯一的尾元素。
		除首元素之外，结构中每个元素有且仅有一个前驱元素，
		除尾元素之外，结构中每个元素有且仅有一个后继元素。
		
		【e.g.】
			等公交/地铁时排的队伍
			
	3)树型结构
		-足要描述结构中的数据元素之间存在一对多的父子关系；
		
		-该结构中存在唯一的根元素，也就是起始元素。//		A
		-其中该结构中顶端的元素叫做叶元素。	//	       / \
							//	      B   C
							//	     / \
								    D   E
		除了根元素之外，结构中的每个元素有且只有一个前趋元素；
		出来叶元素之外，结构中的每个元素可以拥有一个或多个后继元素；


	4)图形结构/网状结构
		-主要描述数据元素之间存在多对多的交叉映射结构。
		-该结构中的每个元素都可以有多个前趋和多个后继元素；
		-该结构中的任意两个元素之间都可以建立关联；





	1.4 物理结构分类
	
	1)顺序结构
		-主要描述采用一组连续的存储但愿一次存储逻辑上相邻的各个元素，
		如果每个元素都具有相同的属性，则每个元素占用的存储空间相同。
	
		-物理结构中的顺序结构可以采用C语言中的数组类型加以描述；



思考:
	该结构有什么优点以及缺点？？？
	
优点:
	a.支持下标访问，实现/*随机访问*/也比较方便。

	b.除了申请存储数据元素本身之外的存储空间，不需要额外的存储空间来表达数据元素之间的逻辑关系，
	  因此比较//节省内存。

缺点:
	a.申请连续的存储空间时需要预知元素的个数来确定存储空间的大小，
	  若太小则可能不够，若太大则可能造成浪费。

	b.要求申请连续的存储空间，导致小块空闲区域无法有效利用，因此整个内存空间的利用率比较低。

	c.当插入或删除元素时，可能会导致大量数据元素的移动，因此执行效率比较低。





	2)链式结构
		-主要描述采用一组地址不连续的存储单元来依次存放各个元素，
		 不保证逻辑上相邻的元素在物理位置上也连续。
	
		-为每个元素构造一个节点，而节点中的内容包括两部分：
			存储数据元素本身 + 记录下一个节点的首地址。

		-该结构无法使用C语言中的数据类型加以描述，因此需要程序员
		   手动编码去实现该结构；

思考：

	该结构的优点，缺点。


优点：
	a.不需要预知元素的个数，而是使用动态内存，
	  为每个元素构造节点，或者释放节点。
	
	b.不需要申请连续的存储空间，因此空间利用率比较高。

	c.插入或删除元素时比较方便，不需要移动其他元素的位置。

缺点：
	
	a.不支持下标访问，随机访问也不方便。

	b.除了申请存放数据元素本身的存储空间之外，还需要申请额外的存储空间
	  表达数据元素之间的逻辑关系，也就是记录下一个节点的地址，因此比较消耗内存空间。



	1.5 逻辑结构和物理结构之间的关系

	每种逻辑结构采用何种物理结构来实现并没有具体的规定，通常根据实现的难易程度，
	以及在时间复杂度和空间复杂度等方面的考虑，来选择合适的物理结构，也不排除
	同一种逻辑结构需要使用多种物理结构实现的可能；



	1.6 运算结构

	主要描述数据结构的创建，销毁，增删改查以及相关的算法使用。








			/* 2. 栈 Statck */
	2.1 基本概念

	-栈就是一种具有后进先出特性的数据结构，简称LIFO(Last In First Out)

	1)栈顶，允许进行插入、删除操作的一端。
	2)栈属于逻辑结构中的线性结构。


	2.2 基本操作

	创建(stack_create) 
	销毁(stack_destroy)
	判断是否为空(stack_empty)
	判断是否为满(stack_full)	
	入栈(stack_push)
	出栈(stack_pop)				
	查看栈顶元素(stack_peek)
	计算栈中有效元素个数(stack_size)
	遍历栈中所有元素(stack_travel)		//把所有元素打印出来

	2.3 使用顺序结构实现栈的基本操作

//使用顺序结构实现栈的基本操作
//01stack_arr.c
#include <stdio.h>
#include <stdlib.h>
//定义栈的数据类型
typedef struct{
//	int arr[5];
	int* arr;
	int len;//记录数组中可以存放的元素个数
	int pos;//记录数组下标
}Stack;
//1 实现栈的创建
Stack* stack_create(int len);
//2 实现栈的销毁
void stack_destroy(Stack* ps);

//3 判断栈是否为空
int stack_empty(Stack* ps);
//4 判断栈是否为满
int stack_full(Stack* ps);
//5 入栈
void stack_push(Stack* ps);
//6 出栈
void stack_pop(Stack* ps);
//7 查看栈顶元素
void stack_peek(Stack* ps);
//8 计算栈中有效元素个数
int stack_size(Stack* ps);
//9 遍历栈中所有元素
void stack_travel(Stack* ps);

int main(void)
{
	//创建栈，调用stack_create函数
	Stack* ps = stack_create(5);

	printf("%s\n",stack_empty(ps)?"栈已经空了":"栈没有空"); // 栈已经空了
	printf("%s\n",stack_full(ps)?"栈已经满了":"栈没有满"); // 栈没有满
	stack_push(ps);//入栈
	stack_peek(ps);	//查看栈顶元素
	int size = stack_size(ps);
	printf("有效元素个数是:%d\n",size);
	stack_pop(ps);
	
	//销毁栈，调用stack_destroy函数
	stack_destroy(ps);
	ps = NULL;
	return 0;
}


//8 计算栈中有效元素个数
int stack_size(Stack* ps){
	int arr[] = {0};
	return arr[ps->pos-1];
}

//9 遍历栈中所有元素
void stack_travel(Stack* ps){
	int num = 0;
	for(num = 0;num <= ps->len;num++){
		*(ps->arr + num) = num + 1;
		ps->pos++;
		printf("%d ",*(ps->arr + num));
	}
}

//7 查看栈顶元素
void stack_peek(Stack* ps){
	printf("%d\n",ps->pos - 1);
}

//5 入栈
void stack_push(Stack* ps){
	int num = 0;
	for(num = 0;num <= ps->len;num++){
		*(ps->arr + num) = num + 1;
		ps->pos++;
	}
}
//6 出栈
void stack_pop(Stack* ps){
	int num = 0;
	for(num = ps->len;num > 0;num--){
		ps->pos--;
	}
}

//3 判断栈是否为空
int stack_empty(Stack* ps)
{
	return 0 == ps->pos;
}

//4 判断栈是否为满
int stack_full(Stack* ps)
{
	return ps->len == ps->pos;
}


//2 销毁
void stack_destroy(Stack* ps){
	free(ps->arr);
	ps->arr = NULL;
	free(ps);
	ps = NULL;
}
//创建
Stack* stack_create(int len){
	//1 创建栈 
//	Stack stack;	//局部变量	error
//	return &stack;	//永远不要返回局部变量的地址
//使用static关键字进行修饰   error~
	Stack* ps = (Stack*)malloc(sizeof(Stack));//动态内存分配
	if(NULL == ps){
		printf("创建栈失败，程序结束\n");
		exit(-1);//异常终止整个程序
	}
	
	//2 初始化栈中的所有成员
	ps->arr = (int*)malloc(sizeof(int)*len);
	if(NULL == ps->arr){
		printf("创建栈失败，程序结束\n");
		exit(-1);
	}
	ps->len = len;
	ps->pos = 0;
	//3  返回栈的首地址				
	return ps;
}


***************************************
作业：
	编程实现顺序结构栈中的基本操作；









/**************************************************************************/
*									   *		
*				day_02					   *	
*									   *
/**************************************************************************/


vi Makefile 批处理文件
	
	期望生成的文件 ： 依赖的文件
	[一个Tab的距离]	该依赖文件生成方式
	
	【e.g.】
  1 stack_arr:main.o stack_arr.o
  2     cc main.o stack_arr.o -o stack_arr
  3 main.o:main.c
  4     cc -c main.c
  5 stack_arr.o:stack_arr.c
  6     cc -c stack_arr.c
  7 clean:			//清除
  8     rm *.o stack_arr

************************
-make
-./stack_arr
-make clean

			/*栈(续)*/
	1、栈

	1.1 使用链式结构来实现栈的基本操作。
	     a.定义节点的数据类型
		typedef struct node{
		    int data;//记录数据元素本身
		    struct node* next;//记录下一个节点地址
		}	
	     b.top的数值
		struct node* /Node * top
		top = 0x10; top->data = 11;
		top->next = 0x20;


*******************************
//03strack_list.c
//使用链式结构实现栈的基本操作
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

//定义节点的数据类型
typedef struct node{
	int data;//记录数据元素本身
	struct node* next;//记录下一个节点地址
}Node;


//定义栈的数据类型
typedef struct{
	Node* top;//记录第一个节点的地址
	int cnt;//记录有效元素的个数
}Stack;

//1实现栈的创建 
Stack* stack_create(void);
//2实现栈的销毁
void stack_destroy(Stack* ps);
//3实现入栈操作
void stack_push(Stack* ps,int data);
//4实现遍历
void stack_travel(Stack* ps);
//5判断栈是否空
bool stack_empty(Stack* ps);    //布尔类型
//6判断栈是否满
bool stack_full(Stack* ps);
//7查看栈顶元素
int stack_peek(Stack* ps);
//8计算栈中有效元素的个数
int stack_size(Stack* ps);
//9出栈
int stack_pop(Stack* ps);
//10 清空栈中内容
void stack_clear(Stack* ps);

/*-------------------------------------*/

int main(){
	//1创建栈
	Stack* ps = stack_create();
	
	int i = 0;
	for(i = 1;i < 7;i++){
		stack_push(ps,i*10 + i);//入栈
		stack_travel(ps);	//遍历
	}
	printf("--------------------------------\n");
	printf("%s\n",stack_empty(ps)?"栈空":"栈不空");
	printf("%s\n",stack_full(ps)?"栈满":"栈不满");
	
	printf("栈顶元素是:%d\n",stack_peek(ps));//查看栈顶元素
	printf("栈中有效元素是:%d\n",stack_size(ps));
	
	printf("--------------------------------\n");
	printf("出栈的元素是:%d\n",stack_pop(ps));//66
	printf("栈顶的元素是:%d\n",stack_peek(ps));//55
	printf("栈中有效元素是:%d\n",stack_size(ps));//5
	stack_travel(ps);// 55 44 33 22 11
	
	printf("--------------------------------\n");
	stack_clear(ps);
	stack_travel(ps);//nothing

	//2销毁栈
	stack_destroy(ps);
	ps = NULL;

	return 0;
}


/*-------------------------------------*/
//9出栈
int stack_pop(Stack* ps){
	if(stack_empty(ps)){
		return -1;//表示出栈失败
	}
	Node* pt = ps->top;
	ps->top = ps->top->next;
	int temp = pt->data;
	free(pt);
	pt = NULL;
	ps->cnt--;
	return temp;
}
//10 清空栈中内容
void stack_clear(Stack* ps){
	while(-1 != stack_pop(ps)){
		
	}
}

//5判断栈是否空
bool stack_empty(Stack* ps){
	return NULL == ps->top;
}
//6判断栈是否满
bool stack_full(Stack* ps){
	return false;
}
//7查看栈顶元素
int stack_peek(Stack* ps){
	//return stack_empty(ps) ? -1:ps->top->data;
	if(stack_empty(ps)){
		return -1;
	}
	return ps->top->data;
}


//8计算栈中有效元素的个数		/*HARD*/
int stack_size(Stack* ps){
/*	Node* pt = ps->top;//定义临时指针代替top
	int cnt = 0;
	while(pt != NULL){
		cnt++;
		pt = pt->next;
	}
	return cnt;
*/
	return ps->cnt;
}


//3实现入栈操作
void stack_push(Stack* ps,int data){
	//创建新节点
	Node* pn = (Node*)malloc(sizeof(Node));
	if(NULL == pn){
		printf("fail to creat new node!");
		exit(-1);
	}
	pn->data = data;
	pn->next = NULL;
	//将新节点插入到合适的位置
	pn->next = ps->top;
	ps->top = pn;
	//有效元素个数加1
	ps->cnt++;
}

//4实现遍历
void stack_travel(Stack* ps){
	printf("栈中元素有：");
	Node* pt = ps->top;//指定临时指针代替top进行遍历
	while(pt != NULL){
		printf("%d ",pt->data);
		//指向下一个节点
		pt = pt->next;
	}
	printf("\n");
}


//1实现栈的创建 
Stack* stack_create(void){
	//1创建栈
	Stack* ps = (Stack*)malloc(sizeof(Stack));
	if(NULL == ps){
		printf("fail to create stack!\n");
		exit(-1);
	}
	//2初始化栈中成员
	ps->top = NULL;
	ps->cnt = 0;
	//3返回栈的首地址
	return ps;
}
//2实现栈的销毁
void stack_destroy(Stack* ps){
	free(ps);
	ps = NULL;
}

*****************************


	
	1.2 实际应用：
		可以用于小鼠走迷宫游戏等场合中；



*************************
作业：
	1、将文件03stack_list.c 拆分为三个文件：
	   stack_list.h stack_list.c main.c
	   将这3个文件放到目录stack_list中，
	编写Makefile文件进行编译链接；



		



/**************************************************************************/
*									   *		
*				day_03					   *	
*									   *
/**************************************************************************/


作业：






		
			/*队列*/
	1.队列(Queue)
	1.1 基本概念
		队列就是具有先进先出特性的数据结构,简称FIFO
					(First In First Out)
	
		
		――――――――――――――――――――	
	  back――――>		 ――――――>front
		――――――――――――――――――――

		队列是一种可以在两端进行增删操作的数据结构，
		其中插入元素的端点叫做后端，也就是队尾；
		其中删除元素的端点叫做前端，也就是队首/队头。
	
		队列属于逻辑接哦股中的线性结构；

	1.2 基本操作
	
		创建			queue_create
		销毁			queue_destroy
		判断队列是否空			queue_empty
		判断队列是否满			queue_full
		入队			queue_push
		遍历			queue_travel
		计算有效元素个数	queue_size
		查看队列中队首元素	queue_front
		查看队列中队尾元素、 	queue_back
		出队			queue_pop
		清空队列中所有元素	queue_clear



	1.3 使用顺序结构实现队列的基本操作
	
			       77  66 			
		――――――――――――――――――――――
    int arr[];  | 55| 44| 33| 22| 11 |   
		――――――――――――――――――――――
		  4   3   2   1    0
	
	思路：
		int arr[];
		int front;
		int cnt;
		当队列放满时：front = 0;cnt = 5;
		此时进行第一次出队：
		arr[front % 5] = arr[0] = 11;
		front++;  //front = 1;
		cnt--;    //cnt = 4;
		此时插入元素 66 时:
		arr[(front+cnt) % 5] = arr[0] = 66;
		cnt++; //cnt = 5

		第二次
		arr[front % 5] = arr[1] = 22;
		front++;  //front = 2;
		cnt--;    //cnt = 4;
		此时插入元素 77 时:
		arr[(front+cnt) % 5] = arr[1] = 77;
		cnt++; //cnt = 5



	/* CODE */
	



	1.4 使用链式结构实现队列的基本操作









	1.5 实际应用
		可以用于打印机打印任务的控制、银行取号系统等；



*********************************************
作业：
	将01queue_arr.c 03queue_list.c分别拆分为三个文件
	各自放在独立的目录中，编写Makefile文件进行编译链接。





/**************************************************************************/
*									   *		
*				day_04					   *	
*									   *
/**************************************************************************/




		
		
			/*链表 List*/

	1.1 基本概念
		由若干个地址不连续的节点序列组成，
  		不同的节点之间彼此通过指针连接组成的数据结构。


	1.2 基本分类
		(1) 单向线性链表

		每个节点中除了存储数据元素本身之外，
		还需要保存下一个节点地址的指针，叫做//后指针。
			
		其中链表中第一个节点，叫做//头节点；
		指向头节点的指针叫做//头指针；

		其中链表中最后一个节点，叫做//尾节点；
		指向尾节点的指针叫做//尾指针；
		
		尾节点中的后指针是一个//空指针。			


		(2) 单向循环链表

		与单向线性链表类似，所不同的是让尾节点的后指针指向头节点，
		首尾相接构成环状结构；
					
		
		(3) 双向线性链表

		每个节点中除了存储数据元素本身之外，还需要两个指针；
		
		其中一个用于记录下一个节点的地址，叫做后指针；
		另外一个用于记录前一个节点的地址，叫做前指针；	
		
		头节点中的前指针后尾节点中的后指针都是空指针。


		(4) 双向循环链表   
		
		与双向线性链表类似，所不同的是让尾节点的后指针指向头节点，
		让头节点的前指针指向尾节点，首尾相接构成环状结构。

		(5) 数组链表(了解)
		
		链表中的每一个元素都是一个数组，也就是由数组构成的链表；

		(6) 链表数组(了解)
		
				/*概念问题*/
		字符数组 -- 数组中的每一个元素都是一个字符；
		整型数组 -- 数组中的每一个元素都是一个整形；
		结构体数组 -数组中的每一个元素都是一个结构体；
		指针数组 -- 数组中的每一个元素都是一个指针；
		链表数组 -- 数组中的每一个元素都是一个链表；


		(7) 二维数组(了解)
		
		二维数组 - 数组中的每个一个元素都是一个一维数组。
		e.g. 
			int arr[2][3] = {{1,2,3},{4,5,6}};// = {X,Y}


	1.3 变成实现单向线性链表的各种基本操作(/*重中之重*/)
		
		/*插入新元素到单链表指定位置:*/
		当pos = 1 时：
		pn->next = head->next;
		head->next = pn;
		当pos = 2 时：
		pn->next = head->next->next;
		head->next->next = pn;



//01list.c		
//6.3 插入新元素到指定位置
void list_push_pos(List* pl,int data,int pos){
    //1判断坐标的合法性
    if(pos < 0 || pos > list_size(pl)){
        printf("坐标不合法，插入元素%d失败\n",data);
        return ;
        //pos = 0;  //默认插入到开头位置
        //pos = list_size(pl);  //默认插入到末尾位置
    }   
    //2当pos = 0时，新元素插入到开头位置
    else if(0 == pos){
        list_push_head(pl,data);
    }   
    //3当pos = cnt时，插入到末尾位置
    else if(pos == list_size(pl)){
        list_push_tail(pl,data);
    }   
    //4当pos = pos时，采用归纳发插入到中间位置
    else{
        //创建新节点
        Node* pn = node_create(data);
        if(NULL == pn){
            printf("fail to create new node,program end\n");
            return ;
        }   
        //使用循环将相对于pos=1时多出来的next执行完
        Node* pt = pl->head;
        int i = 0;
        for(i = 1;i < pos;i++){
            pt = pt->next;//指向下一个节点。
        }   
        //编写pos = 1时的处理代码即可
        pn->next = pt->next;
        pt->next = pn; 
        //节点个数加1.
        pl->cnt++;
    }
}
*******************************
//main函数中调用
    printf("\n------------指定插入--------------------\n");
    list_push_pos(pl,88,-2);//插入88失败        
    list_travel(pl);        //66 55 44 33 22 11 77
    list_push_pos(pl,88,0);    
    list_travel(pl);        //88 66 55 44 33 22 11 77
    list_push_pos(pl,99,2);    
    list_travel(pl);        //88 66 99 55 44 33 22 11 77
    list_push_pos(pl,111,8);    
    list_travel(pl);        //88 66 99 55 44 33 22 11 111 77
    list_push_pos(pl,222,10);    
    list_travel(pl);        //88 66 99 55 44 33 22 11 111 77 222
    printf("单链表中有效元素的个数是:%d\n",list_size(pl));//11

    printf("\n----------------------------------\n");

		




		/*删除单链表指定位置元素*/

	
		当pos = 1 时
		Node* pt = head->next;
		head->next = pt->next;
		int temp = pt->data;
		free(pt);
		pt = NULL;
		cnt--;
		当pos = 2 时
		Node* pt = head->next->next;
		head->next->next= pt->next;
		int temp = pt->next->data;
		free(pt);
		pt = NULL;
		cnt--;
				
************************





//12 删除指定编号的元素
int list_pop_pos(List* pl,int pos){
    //1 判断坐标的合法性    
    if(pos < 0 || pos >= list_size(pl)){
        printf("坐标不合法，删除元素失败\n");
        return -1; 
    }   
    //2 当pos = 0时相当于删除头节点
    if(0 == pos){
        return list_pop_head(pl);
    }   
    //3 当pos = list_szie(pl) - 1时，相当于删除尾节点
    else if(pos == list_size(pl) - 1){ 
        return list_pop_tail(pl);
    }   
    //4 当pos = pos时，采用归纳发来删除指定节点。
    else{
        //1 使用临时指针替代head
        Node* pt = pl->head;
        //2 使用循环将pos = 1时多出来的next执行完
        int i = 0;
        for(i = 1;i < pos;i++){
            pt = pt->next;
        }   
        //3编写pos = 1时的代码
        Node* pm = pt->next;
        pt->next = pm->next;
        //4 使用临时变量记录哟啊删除节点的元素值
        int temp = pm->data;
        //5 释放节点的动态内存
        free(pm);
        pm = NULL;
        pl->cnt--;
        return temp;
    }   
}
**********************************
//Main函数中调用

    printf("\n------------指定删除--------------------\n");
    printf("单链表中删除的尾节点的元素是%d\n",list_pop_pos(pl,-2));//-1
    printf("单链表中删除的尾节点的元素是%d\n",list_pop_pos(pl,0));//66
    printf("单链表中删除的尾节点的元素是%d\n",list_pop_pos(pl,2));//44
    printf("单链表中删除的尾节点的元素是%d\n",list_pop_pos(pl,6));//77
    printf("单链表中头节点的元素是%d\n",list_get_head(pl));//99
    printf("单链表中尾节点的元素是%d\n",list_get_tail(pl));//111
    printf("单链表中有效元素的个数是:%d\n",list_size(pl));//6
    list_travel(pl);//99 55 33 22 11 111


************************************



	扩展训练:
		a.实现返回单链表中中间节点的元素值。
		b.实现闭环和开环操作(首尾相连)
		c.实现单链表中所有节点元素值的排序(从小到大)
		d.实现将两个有序单链表合并成一个有序单链表。
		e.实现逆转单链表中所有节点的次序以及逆序打印所有节点元素。
			(tip:使用递归算法)


	1.4 实际应用
		主要用于大量需要进行增删操作的场合中。



作业：
	1.复习理解单链表中的基本操作代码；
	2.将01list.c文件拆分为多文件结构，编写Makefile文件；


	




/**************************************************************************/
*									   *		
*				day_05					   *	
*									   *
/**************************************************************************/



		


			/*二叉树 Binary Tree*/

	1. 二叉树
	1.1 基本概念
		1)栈/队列/链表 属于逻辑结构中的线性结构；
		二叉树 属于逻辑结构中的树型结构；

		2)在计算机中，二叉树就是指每个节点最多只有两个子节点的树型结构，
			也就是最多只有两个分叉的树型结构。
		
		3)树型结构的起始节点叫做/*根节点*/，除了根节点之外，
		其他每个节点有且只有一个父节点，而整颗树有且只有一个根节点。

		4)其中没有任何子节点的节点叫做//叶子节点，
		叶子节点有父节点但是没有子节点。


		5)除了根结点和叶子节点之外，其他节点叫做//枝节点。
		枝节点有父节点也有子节点；

		6)左边的子节点叫做/*左子节点*/，右边的子节点叫做/*右子节点*/。

		7)高度(层数)h
		  每层节点个数	2^(h-1)
		  最多节点	2^h

		8)如果该二叉树中每层节点个数都达到了最大值，
		  并且所有枝节点都有两个子节点，这样的二叉树称为/*满二叉树*/。

		9)如果该二叉树中,除了最下面一层，其他每层节点个数都达到了最大值，
		并且最下面一层的所有节点都连续集中在左侧，此二叉树/*完全二叉树*/。



	1.2 基本特征
		二叉树具有递归嵌套式的空间结构特征，
		因此采用递归的方法去处理二叉树问题，会使处理算法更加简洁，
		方法如下:
		
	    处理(二叉树){
				if(二叉树为空)直接处理；
			}
			else{
				处理左子树(以左子节点为根节点的小二叉树); -递归
				处理右子树(以右子节点为根节点的小二叉树); -递归
				处理根结点;
			}
		}


		
	1.3 存储结构
		
		1) 顺序存储

			一般来说，从上到下，从左到右依次存放各个节点，
			对于非完全二叉树需要使用虚节点补成完全二叉树。

		2) 链式存储
	
			一般来说，每个节点包括三部分内容:一个记录数据元素本身，
			和两个分别指向左右子节点地址的指针。
			如:
				typedef struct node{
				    int data;//记录数据元素本身
				    struct node* left;//记录左子节点地址
				    struct node* right;//记录右子节点地址
				}Node;	

			//三叉链表，多了一个记录父节点的地址。


	1.4 基本操作
		
		创建		binary_tree_create
		销毁		binary_tree_destroy
		插入		binary_tree_insert
		遍历		binary_tree_travel
		删除		binary_tree_delete
		修改		binary_tree_modify
		查找		binary_tree_find
		判空		binary_tree_empty
		判满		binary_tree_full
		查看根结点元素	binary_tree_root
		计算有效元素	binary_tree_size
		清空		binary_tree_clear	

	1.5 遍历方式

		1) 先序遍历(DLR => data left right)
				
			先遍历根节点，再左子树，最后右子树。
			又称 先根遍历。

		2) 中序遍历(LDR => left data right)	
			
			先遍历左子树，再根节点，最后右子树。
			又称 中根遍历
	
		3) 后序遍历(LDR => left right data)

			先遍历左子树，再右子树，最后根节点。
			又称 后根遍历


		e.g.		30
			       /   \
			      20    35		(有序二叉树)
 			     /  \  /  \			
			    15  25 30  40 	


		先根 : (30) [20] 15  25  [35]  40
		中根 :  15  [20] 25 (30) [35]  40
		后根 :  15   25 [20] 40  [35] (30)
			

	1.6 有序二叉树
  	   满足一下三个条件的非空二叉树就叫做有序二叉树
	   1)如果左子树不为空，则左子树中所有节点的元素值都小于等于根节点元素值；
		
	   2)如果右子树不为空，则左子树中所有节点的元素值都大于等于根节点元素值

	   3)左右字数内部依然满足上述规则；

	实际应用:
		主要用于需要进行查找和排序的场合中，又叫做二叉查找树。


	【练习】
		组合成有序二叉树，使用三种方法进行遍历

		50(root) 70 20 60 40 30 10 90 80
			 root	
			  -->   50
			       /  \
			     20    70
			    / \   /  \
                           10 40 60   90
		   	      /	      /
			     30      80

		
		先 50 20 10 40 30 70 60 90 80 
		中 10 20 30 40 50 60 70 80 90
		后 10 30 40 20 60 80 90 70 50 				  

		

			/*二级指针复习*/

	/*二级指针的主要用途为用作形参接收一级指针实参的地址*/

		________________________________	
		    |  |      |  |        |  |    	
		    |  |      |  |        |  | 	
		____|__|______|__|________|__|__

		int num = 20;
		int* pn = &num;
		=>int* pn; pn = &num;

		int** ppn = &pn;
		=>int** ppn; ppn = &pn;



		************************
		&num = 0x10 ; num = 20;
		
		&pn = 0x20 ;pn = & num = 0x10
		*pn = *(&num) = num = 20;

		 &ppn = 0x30 ;
		  ppn = pn = 0x20 
			//二级指针变量名表示 一级指针的地址
		 *ppn = *(&pn) = pn = &num = 0x10 
			//*二级指针变量名 --一级指针的内容 -- 普通变量的地址
		**ppn = *(*ppn) = *(&nnum) = num = 20;
			//**二级指针变量名 -- 普通变量的内容

	
		



****************************************


作业：
   编程实现有序二叉树的其他基本操作；
预习：
   (1)算法的概念和评价
   (2)常用的查找算法
   (3)常用的排序算法






/**************************************************************************/
*									   *		
*				day_06					   *	
*									   *
/**************************************************************************/


	
				/*算法*/

	1. 算法的概念和评价

	  1.1 基本概念

		算法就是对解题方案准确而又完整的描述，是一系列清晰的指令
		
	  1.2 评价标准

		(1)时间复杂度(重点！！！)
		   
		  -主要描述算法的时间消耗与问题规模之间的函数关系；
		
		(2)空间复杂度
	
		  -主要描述算法的空间消耗与问题规模之间的函数关系；

		(3)正确性

		  -主要描述算法的执行结果是否满足要求；

		(4)可读性

		  -主要描述算法本身是否便于阅读；

		(5)健壮性

		  -主要描述算法对非正常输入的反应和处理能力；

	1.3 描述方式
	
		常见的算法描述方式主要有:
		    自然语言、伪代码、结构化流程图、PAD图 ...



				/*查找算法*/

	2. 常用的查找算法
	
	2.1 线性查找算法(顺序查找算法)	//	O(N)
	    (1) 算法流程

		使用目标元素与样本数列中的第一个元素起，依次进行比较，
		如果找到了与目标元素相等的元素则表示查找成功；

		或者与所有的样本元素全部比较完毕，
		也没有找到与目标元素相等的元素，则表示查找失败。

   	    (2) 算法评价

		平均时间复杂都O(N),对样本的有序性不敏感。


	2.2 二分查找算法(折半查找算法)	//	O(log N)
		
	    (1) 算法流程
			
		假定样本数列中的所有元素从小到大依次进行排列，
		使用目标元素与样本数列中的中间元素进行比较，如果相等则查找成功;
		如果中间元素小于目标元素，则去中间元素的右边进行查找;
		如果中间元素大于目标元素，则去中间元素的左边进行查找;
		重复以上上过程，知道找到满足条件的目标元素为止则表示查找成功,
		或者与需要比较的元素比较完毕，则表示查找失败;

	    (2)	算法评价

		平均时间复杂度O(log N),要求样本元素必须有序;


**************************
//使用查找算法查找指定的目标元素
#include<stdio.h>


//1.0 实现线性查找
//平均时间复杂度O(N),对样本的有序性不敏感
int find(int arr[],int len,int data){
    int i = 0;
    for(i = 0;i < len;i++){
        if(data == arr[i]){
            return i;  //返回元素对应的下标
        }   
    }   
    return -1;  //表示查找失败;
}

//2.0 实现二分查找算法
//平均时间复杂度O(log N),要求样本元素必须有序;
int find_binary(int arr[],int left,int right,int data){
    
    if(left <= right){
        //1.计算中间元素的下标
        int p = (left + right) / 2;
        //2.使用目标元素与中间元素比较大小，相等返回
        if (data == arr[p]){
            return p;
        }   
        //3.如果目标元素小于中间元素，则在左边查找 --递归
        else if(data < arr[p]){
            return find_binary(arr,left,p - 1,data);
        }   
        //4.如果目标元素大于中间元素，则在右边查找 --递归
        else{
            return find_binary(arr,p + 1,right,data);
        }   
    }   
    return -1;  //表示查找失败
}
int main(){
    int arr[9] = {10,20,30,40,50,60,70,80,90};
    //int pos = find(arr,9,40);
    int pos = find_binary(arr,0,8,400);
    if(-1 != pos){
        printf("查找目标元素成功，所在下标是:%d\n",pos);//3     
    }
    else{
        printf("目标元素不存在\n");
    }
    return 0;
}
     



*******************************
			


				/*排序算法*/


	3 常用排序算法
		
	3.1 冒泡排序算法(重点)  /*每次保证选出一个位置确定的最大数*/
	
	    (1) 算法流程
		
			      (第1轮) (第2轮) (第3轮) (第4轮)	(n-1轮)	
			20	20	20	20  |	10	
			30	30	30  |	10  V	20
			50  |	40  |	10  V	30	30
			40  | 	10  V	40	40	40
			10  V 	50	50	50	50
	      【下沉】	      (最大)  (次大) 				
			
	
	

	    a.比较相邻位置的元素，如果第一个元素比第二个元素大，
	      则交换两个元素；	
	    b.从最开始的一对相邻位置元素到最后一对相邻位置的元素做同样的工作，
	      经过这一步，最后的元素将是最大值。
		
	    c.针对所有元素重复以上步骤，除了最后一个元素；

	    d.持续每次对越来越少的元素重复以上步骤，
  	      直到没有元素需要交换为止。	

		
		第一轮:
			j 和 j+1 比较，j的取值范围:[0，4)
		第二轮:
			j 和 j+1 比较，j的取值范围:[0，3)
		第三轮:
			j 和 j+1 比较，j的取值范围:[0，2)
		第四轮:
			j 和 j+1 比较，j的取值范围:[0，1)


		j 的取值范围: [0,n - i)

		
	    (2) 算法评价
		
		平均时间复杂度 O(N^2), 稳定，(加了flag)对样本的有序性非常敏感;



	3.2 插入排序算法

	    (1)算法流程
		
		【e.g.】 斗地主 码牌的过程就是不断的进行插入排序
		
		a.从第一个元素起，该元素可以认为已经有序
		b.将下一个元素取出，在已经有序的元素中从后向前进行扫描和比较
		c.如果左边元素大于取出的元素，则将左边元素赋值到下一个位置上(右移)
		d.如果左边元素小雨等于取出的元素，则将取出的元素插入到左边元素右边
		e.重复步骤b，直到处理完毕所有元素为止；
			


	    (2)算法评价
		
		平均时间复杂度O(N^2), 稳定，对样本的有序性非常敏感，
		但是赋值的次数比冒泡排序少，因此一般情况下略优于冒泡排序。


	3.3 选择排序算法	/*每次保证选出一个位置确定的最小数*/

	    (1)算法流程
		
		a.从第一个元素起依次取出，假定取出的元素是最小值，
		  并且使用变量min来记录该元素的下标；
		b.使用min记录的最小值与后续所有元素依次进行比较,
		  如果后续元素中有比min记录的最小值还小的元素,
		  则重新记录该元素的下标到min中,
		  也就是后续元素变成了min记录的最小值。
		c.知道min记录的最小值与后续所有元素比较完毕，
		  交换min记录的最小值和最开始假定的最小值；
		d.重复以上过程，知道处理完毕所有元素为止。



	    (2)算法评价
		
		平均时间复杂度  O(N^2),不稳定(相同数值的元素次序会发生改变),
		对样本有序性不敏感。
		虽然比较的次数比较多,但是交换的次数比较少,因此一般情况下略优于冒泡
		

	3.4 快速排序算法(BAT深度笔试题)

	    (1) 算法流程
	
		a.从样本数列中选择中间元素作为基准值，单独保存起来;
		b.重组数列，将所有比基准值小的元素都放在基准之的左边，
		  将所有比基准值大的元素都放在基准之的右边，
		  与基准之相等的元素可以放在任意一边，这个过程叫做分组。
		c.以递归的方式对小于基准值的分组和大于基准之的分组分别进行分组排序
	

		35 10 20 5 15 25 12 30 3 
		^	   ^	       ^	
		|	   |	       |
		i	   p 	       j


	    (2) 算法评价

		平均时间复杂度 O(Nlog N),不稳定,有样本有序性不敏感。



************************
//编程实现各种排序算法
#include<stdio.h>

//1.0 冒泡排序算法
// 平均时间复杂度 O(N^2) 稳定 (加了flag)对样本的有序性非常敏感
void bubble(int arr[],int len){
    int i = 0,j = 0;
    //1 使用循环来控制比较的轮数
    for(i = 1;i < len;i++){
        //定义标志位,用来判断内层循环是否进行了交换
        int flag = 1;
        //2 使用循环来控制比较的元素下标范围
        for(j = 0;j < len - i;j++){
            //3 如果左边元素大于右边元素，则交换
            if(arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                flag = 0;
            }
        }
        //如果没有发生任何交换,说明已经是从小到大排序,结束冒泡排序
        if(1 == flag){
            break;//跳出循环
        }
    }
}

//2.0 插入排序
// 平均时间复杂度  O(N^2) 稳定，对样本的有序性非常敏感
void insert(int arr[],int len){
    int i = 0,j = 0;
    //1 使用循环将后续的元素依次取出
    for(i = 1;i < len;i++){
        //2 将取出的元素单独保存起来，避免被覆盖
        int temp = arr[i];
        /*
          3 使用取出的元素与左边元素依次进行比较，
            如果左边元素大于取出的元素，则左边元素右移          */
        for(j = i;arr[j - 1] > temp && j >= 1;j--){
            arr[j] = arr[j - 1];
        }
        //4 直到左边元素不再大于取出元素，则插入取出元素到左边元素的右边
        if(j != i){ //为了避免元素自己给自己赋值
            arr[j] = temp;
        }
    }
}

//3.0 选择排序
// 平均时间复杂度  O(N^2) 不稳定,对样本有序性不敏感
void choose(int arr[],int len){
    int i= 0,j = 0;
    //1 使用循环将第一个元素起依次取出
    for(i = 0;i < len - 1;i++){
        //2 使用临时变量记录取出元素的下标
        int min = i;
        //3 使用min记录的最小值与后续元素一次比较
        for(j = i + 1;j < len;j++){
            //4 如果后续元素中有小于min记录最小值的元素，则重新记录后续的这个元素
            if(arr[j] < arr[min]){
                min = j;
            }
        }
        //5 直到使用min记录的元素与后续所有元素比较完毕为止,交换记录元素与最开始
假定的元素
        if(min != i){   //min变化了才交换
            int temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
    }
}

//4.0 快速排序
// 平均时间复杂度 O(Nlog N),不稳定,有样本有序性不敏感。
void quick(int arr[],int left,int right){
    //1 计算中间元素的下标,单独保存起来
    int p = (left + right) / 2;
    int pivot = arr[p];
    //2 分别使用左右变量的元素依次和基准之进行比较，小放左，大放右
    int i = 0,j = 0;
    for(i = left,j = right;i < j;){
        //左有元素且小于基准元素,比较下一个元素
        while(i < p && arr[i] < pivot){
            i++;
        }
        //左有元素,但不再小于基准值,则将左边元素移动到p指向的位置,p指向该元素原>来的位置
        if(i < p/*左有元素*/){
            arr[p] = arr[i];
            p = i;
        }
        //右有元素且大于基准值,比较上一个元素
        while(j > p && arr[j] >= pivot){
            j--;
        }
        //右有元素,但不大于基准值,将右边元素移动到p指向的位置,p指向该元素原来的>位置
        if(j > p/*右有元素*/){
            arr[p] = arr[j];
            p = j;
        }
    }
    //3 直到左右两边元素下标重合时，放入基准值元素
    arr[p] = pivot;
    //4 对左右两边的分组递归再分组
    if(p - left > 1){
        quick(arr,left,p-1);
    }
    if(right - p > 1){
        quick(arr,p+1,right);
    }
}


int main(){
    int arr[9] = {35,10,30,5,15,30,12,20,3};
    //调用排序算法进行排序
//  bubble(arr,9);  //1.0 冒泡
//  insert(arr,9);  //2.0 插入
//  choose(arr,9);  //3.0 选择
    quick(arr,0,8); //4.0 快排
    //打印
    int i = 0;
    for(i = 0;i < 9;i++){
        printf("%d ",arr[i]);
    }
    printf("\n");
    return 0;
}











