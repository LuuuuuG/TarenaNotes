/**************************************************************************/
*															              *	*							  day_01	                                  *	
*									                                      *
/**************************************************************************/


标准C++语言
 
讲师 ：闵卫，minwei@tedu.cn

从C到C++语言
  
  类和对象
  操作符重载
  继承和多态  
  异常
  I/O流

一、C++语言背景介绍
	1.致敬与缅怀
	  Ken Thompson，肯.汤普逊，B语言之父
	  Algo 68 1968年发布  --Fotran 77/90(小众 强项：数值计算)
						  --CPL	系统编程，太复杂。
						  --BCPL,CPL语言简化版本
						  --B语言,第一个UNICS/UNIX操作系统内核,缺乏数据类型,
							     缺少指针


	  Dennis Ritchie，丹尼斯.里奇,C语言之父，UNIX之父，黑客之父。


	  Bjarne Stroustrup,本贾尼.斯特劳斯特卢普，C++之父
		1979-Cpre，用C语言的宏定义模拟类型simula中类的概念
		1983-C with Classes,纯粹的前端编译器,得名C++语言
		1985-CFront 1.0，第一个商用C++编译器
		1987-GNU C++发布
		1990-Borland C++发布
		1992-Microsoft C++发布，IBM C++发布
		1998-ISO C++98标准
  		2003-ISO C++03标准，对98标准修订
		2011-ISO C++11标准，对98标准革命性的改变和升级
		2014-ISO C++14标准，对11标准的扩充
		2017-ISO 预计推出最新的语言标准...

二、第一个C++程序————Hello,World!
1. 编译器
  g++ hello.cpp
  gcc hello.cpp -lstdc++

2. 扩展名
	.cpp/.cc/.C/.cxx
  也可以用.c,但是要加上-x c++编译选项
	
3. 头文件
	#include<iostream>
  也可以用
	#include<cstdio>
  或者
	#include<stdio.h>

4.I/O流对象
  C++对象	     C流指针  UC文件描述符
	cout-标准输出  -stdout - 1
	cin -标准输入  -stdin  - 0
	cerr-标准出错  -stderr - 2
	
					
5. 插入和提取运算符
	<< -插入，将右操作数对象插入到左操作数对象中
	>> -提取，从左操作数对象中提取数据到右操作数对象中

	
6.名字空间和作用域限定操作符
	std  - 所有标准C++提供的类型、函数、对象都位于该名字空间中
	::   - 表示其右操作数是隶属于左操作数所表示的作用域————相当于"的"



三、名字空间
  1. 为什么需要名字空间————WHY？
	1)名字冲突
	  namespace ns1{
	    int x=10;
	  }
	  namespace ns2{
	  	int x=20;
	  }
	2)模块划分
	namespace network{
	  send
	  recv
	  connect
	  ...
	}
	namespace biz{
	  save
	  draw
	  query
	  ...
	}

  2. 什么是名字空间————WHAT？
	namespace 名字空间名{
	  名字空间成员1;
	  名字空间成员2;
	  ...
	}
	名字空间成员:变量、函数或者类型，但是红定义不受名字空间限制。
	同名名字空间的成员无论分别声明在同一个文件中还是不同文件中，最终都会被编译器合并为一个名字空间:
	
	namespace 名字空间名{
	  名字空间成员1;
    }
	namespace 名字空间名{
	  名字空间成员2;
    }
	namespace 名字空间名{
	  ...
	}

  名字空间中的函数，声明和定义如果分开书写，其定义部分必须借助作用域限定操作符"::"
明确所定义的函数隶属于哪个名字空间，以与该函数的声明保持一致。


  3. 怎么用名字空间————HOW?
	1) 在名字空间内部访问本空间中的名字，可以直接访问，无需做任何限定。
	2) 在名字空间外部访问某空间中的名字
	   A. 作用域限定操作符：名字空间名::名字空间成员名;
			如：icbc::save(10000);

	   B. 名字空间指令：using namespace 名字空间名;	
		  名字空间指令以后的代码，对指令中的名字空间中的所有成员均可见，
		  在不发生冲突的前提下，可以省略作用域限定操作符，直接访问之。

	   C. 名字空间声明：using 名字空间名::名字空间成员名;
		  将特定名字空间中的特定成员引入当前作用域，在不发生冲突的前提下，
		  可以省略作用域限定操作符，直接访问之。


	   D. 匿名名字空间：不属于任何有名空间的标识符，会被编译器缺省地置入匿名
		  名字空间中，当存在名字冲突时，可以通过作用域限定操作符，指明所访问的
		  标识符源自该匿名空间。

 
	   E. 名字空间内部还可以定义名字空间，形成名字空间嵌套。访问内层空间中的标识符，
		  需要通过作用域限定操作符从外到内逐层分解，
		  也可以利用名字空间别名，简化空间路径的书写形式。

			

四、结构、联合、枚举
	1. 用这三种自定义类型声明变量，其前导关键字可以省略。
		struct Student {
			char name[64];
			int age;
			int sex;
		};

		struct Student sa={"张飞",22,1},sc={"赵云",20,0};
	   ___^__
	 前导关键字
		Student sa={"张飞",22,1},sc={"赵云",20,0};

	2. C++的结构体允许定义函数形式的成员，谓之成员函数，而变量形式的成员，
		则被称为成员变量。

	3. C++增加了匿名联合的用法，所谓匿名联合其本质并不是定义数据类型，而是规定了变量在内存中的布局形式。

	4. C++的枚举是独立的数据类型，和整型之间的类型转换需要服从编译器内置的转换规则：
		枚举 - 隐式 -> 整型
		枚举 <- 显式 - 整型

五、字符串
	#include<string>
	typedef basic_string <char> string;
	   string s1,s2;

六、 布尔型
	bool -true/false  
	  占用1个字节，1就是true，0就是false。
	
	任何类型的字面值、变量或表达式都可以被隱式转换为bool类型，
	其传哈u你规则就是源值为零即假，非零即真。

七、操作符别名
	{ - <%
	} - %>
	[ - <:
	] - :>
	&&- and
	||- or
	! - not
	& - bitand
	| - bitor
	^ - xor
	...
	int main()<%
		int a<::> = <%1,2,3,4,5%>;
		int b=a<:0:> xor a<:1:>;  
	%>

	ISO-646标准

八、函数重载
	1. 同一个作用域中，函数名相同，参数表不同的函数，构成重载关系。
		overload

	2. 编译器根据调用函数所提供实参的类型，在多个重载版本中挑选一个匹配程度
最高的版本，以供调用，这个过程叫做重载解析。



/**************************************************************************/
*															              *	*							  day_02	                                  *	
*									                                      *
/**************************************************************************/



八、函数重载

	1. ...
	2. ...
	3. 类型转换对重载解析的影响
//		加常转换 》升级转换 》有损转换 》省略号匹配
	4. C++换名
		add.c 和 add.cpp 代码相同
/*
gcc -c add.c -o c_add.o
nm c_add.o 
00000000 T add

gcc -c add.cpp -o cpp_add.o
nm cpp_add.o 
00000000 T _Z3addii   
         U __gxx_personality_v0

其中 _Z是还名标志 3 表示函数名的字节数  ii表示参数类型
*/

	1)函数重载实际上是通过编译器对函数名的替换实现的，被换过的函数名中包含了
	参数表的类型信息，因此具有重载关系的函数，在目标模块中的函数名是不同的。

	2)通过extern "C"关键字可以要求C++编译器按照C的方式处理函数接口，即不做换名，
		当然也就无法重载

	3)如果一个头文件同时被C和C++编译器处理，可以通过预定义宏__cplusplus加以区分，
	  该宏仅在C++编译器中有定义。





/*----------------------------------------------------------*/


一、缺省参数
    1. 可以为函数的部分或全部参数指定缺省值，调用该函数时如果未提供相应的实参，
	  则该参数取缺省值。

 	2. 如果函数的某一个参数带有缺省值，那么该参数后面的所有参数都必须带有缺省值

	3. 函数的缺省参数是在编译阶段解决的，因此只能用 常量/常量表达式/全局变量
	   等非局部化数值作为函数的缺省参数。

	4. 如果需要将函数的声明和定义分开书写，那么该函数参数的缺省值只能出现在
		函数的声明部分，函数定义不能带有缺省参数，

	5. 尽量避免缺省参数和重载发生歧义；


二、哑元
	1. 只有类型没有名字的函数形参，谓之哑元。
	2. 哑元主要用于向下兼容 和 构成重载。



三、内联
	1. 内联就是用函数已被编译好的二进制代码，替换对该函数的调用指令。
	2. 内联在保证函数特性的同时，避免了函数调用的开销。
	3. 内联通过牺牲代码空间，赢得运行时间。
	4. 内联除了作为编译器默认的优化策略以外，也可以人为指定：
		1)在结构体和类中直接给出函数的定义
		  struct Dog{
			...
			void who(void){...} //隐式内联
			...
		  }
		2) 通过inline关键字显示指定内联
			inline void fuck(void){...} //显示内联

		  struct Dog{
			...
			void who(void){...} //显示内联
			...
		  }
		  void Dog::who (void){...}

		1)无论隐式还是显式，所谓的“认为指定”内联并非强制，而是一种对编译器内联机制
		建议或者说是一种期望，最终是否真的会被内联，还是要由编译器的优化策略决定。
		2)编译器的优化策略：对于频繁调用的简单函数进行内联，对于稀少调用的复杂函数
	   	  拒绝内联。
		3)还有一些函数不能被内联，如递归函数和带有动态绑定特性的函数
			(即只有到运行时才能确定入口的函数)。
			自递归：
			inline void digui(){ //编译器直接忽略inline
				digui();
			}
			
			交叉递归：
			void fuck(void){
				shit();
			}
			void shit(void){
				fuck();
			}
			
			循环递归：
			void fuck(){
				shit();
			}
			void shit(){
				damn();
			}
			void damn(){
				fuck();
			}		
			

四、动态内存分配
	1. 完全兼容C方式的动态内存分配
	  #include<stdlib.h>
	  malloc/calloc/realloc --分配
	  free	--释放

	2. 独立的内存分配操作符
		new/delete		--分配/销毁 单个对象
		new[]/delete[]	--分配/销毁 对象数组

		操作符都是编译器提供的，不需要标准库，也不需要头文件。


	3. 用malloc/calloc/realloc分配的内存用free释放，用new分配的内存
		通过delete释放,用new[]分配的内存通过delete[]释放,不要混合使用分配和释放。

	4. 避免重释放。
		free (p);
		free (p);//吐核
		delete p;		  > double free
		delete p;//吐核
		

	5. 与malloc/calloc/realloc函数通过返回空指针报告内存分配内存失败不同，
	  new 以抛出


	6. new 和 malloc/calloc/realloc的不同之处在于除了分配堆内存以外，
	  还会调用相应类型的构造函数, delete 和 free 的不同之处在于除了释放所分配的
	  堆内存以外，还会调用相应类型的析构函数。
		new = malloc + 调用构造函数
		delete = 调用析构函数 + free
		
五、引用
	1. 概念：引用即别名
		int a=10;
		int& b = a;//b是a的引用(别名)
	  A. 引用必须初始化
		int a;
		int& b; //error

	  B. 引用不能为空
		int* p = NULL;//空指针
		int& b = NULL;//error

	  C.引用的目标不能更换
		int a,b;
		int* p = &a;//p的目标是a
		p = &b;//p的目标变为b
		/*-------------------*/
		int a,b;
		int& r = a;//r的目标是a
		r = b;	//将b的值赋给a

	2. 应用
	  1)引用型参数
		通过将函数的形参声明为对实参的引用，使函数得以修改实参变量的值，
		提供比指针传递更加简洁安全的数据输出方式。
	
	  2)常引用型参数
		A.通过将函数的形参声明为对实参的常引用，一方面避免了参数传递过程中的
		  内存复制开销，另一方面有效防止在函数内部意外修改实参的风险。

		B. 常引用型参数还可以用于接收右值形式的实参。
			可以放在赋值运算符左侧的就叫左值，只能放在赋值运算符右侧的就叫右值。
			 其值可被修改的即左值，不可修改的即右值。

		  int a; // a是左值
		  int const a;//a是右值
		  cout << 10 << endl; //10 右值

		  int a = 1, b = 2;
		  cout << a + b << endl; //a+b是右值

		  int a = 10; 
		  double b = (double)a;//(double)a 是右值
	
		  常引用亦称万能引用，既可以引用左值，也可以引用右值。
		  但普通引用只能引用左值，不能引用右值。

	  3)返回引用
		fuck() = 100;
		永远不要返回引用局部变量的引用，除非有特殊需要。
		


	练习：仿照swap.cpp中的 swap2和swap3函数，编写swap4和swap5函数，分别用于
		交换两个字符串变量。



	3. 引用与指针
	  1)同性：引用的本质就是指针。
		
  	  2)异性：引用和指针在高级语言的语言层面语法特性不同。

		A.指针可以定义而不初始化，但是引用必须在定义的同时初始化
		    int* p;//ok
		    int& r;//error
			
		B.指针存在空指针，但是引用没有空引用。
			int* p = NULL;//ok
			int& r = NULL;//error
			
		C.可以定义指向指针的指针,但是无法定义引用引用的引用。
			int* p;  int** pp = &p; //ok
			int& a;  int& r = a;  int&& rr = r;//error
		
		D.可以定义引用指针的引用，但是无法定义指向引用的指针。
			char* p;  char*& rp = p;//ok
			int a;  int& r = a;  int&* pr = &r;//error

		E.可以定义指针数组，无法定义引用数组，但是可以定义数组引用
			int a,b,c;
			int* ps[] = {&a,&b,&c};//ok
			int& rs[] = {a,b,c};//error
			int arr[3] = {...};
			int (&rarr)[3] = arr;//ok,数组引用
			int (*parr)[3] = &arr;//ok，数组指针




/**************************************************************************/
*															              *	*							  day_03	                                  *	
*									                                      *
/**************************************************************************/




一、显式类型转换
	
	1. 静态类型转换(编译阶段进行)
	  目标类型对象 = static_cast<目标类型> (源类型对象)
		SRC src;
		DST dst = static_cast<DST> (src);
	    源类型和目标类型必须相容(相似)。如果从A类型到B类型可以做隐式转换，
	  则说明A和B类型足够相容(相似)，因此从B类型到A类型就可以做静态转换。
	  静态转换主要用于类类型对象的向下造型。
		人   --基类
		男人 --子类
		人  human；
		男人 man；
		human = man;//向上造型，隐式转换
		man = human;//向下造型，	存在转换风险
		如果程序猿确信human里全是man 可以使用
		man  = static_cast<男人>(human);//向下造型

	2. 动态类型转换(运行阶段进行)
	  目标类型指针/引用 = dynamic_cast<目标类型指针/引用> (源类型对象的指针/引用)
		DST dst;	
		SRC& rsrc = dst;
		DST& rdst = dynamic_cast<DST&>(rsrc);
		SRC& psrc = &dst;
		DST* pdst = dynamic_cast<DST*>(psrc);
	    在运行阶段检查rsrc/psrc的实际目标对象到底是不是期望转换得到的DST类型对象
	  如果是则转换成功，否则通过返回空指针或者抛出异常表示转换失败。主要用于具有
	  多态特性的父子类之间转换。


	3. 去常类型转换

		某种类型对象的指针/引用 = const_cast<某种类型指针/引用> (
			某种类型对象的常指针/常引用)
	
		TYPE var;
		TYPE const& cr = var;
		cr = ...;//error
		TYPE& r = const_cast<TYPE&> (cr);
		r = ...;//ok
		TYPE const* cp = &var;
		*cp = ...;//error
		TYPE* P = const_cast <TYPE*> (cp);
		*p = ...;//ok

	4. 重解类型转换
		另一种类型对象的指针/引用 = reinterpret_cast<另一种类型指针/引用> (
			另一种类型对象的常指针/常引用)
		用不同的方式操作同一块数据。



三、类和对象
	1. 什么是对象？
	  万物皆对象。
	2. 如何描述对象？
	  1)通过属性和行为描述对象。
	  	对象：狗
		属性：犬种、犬龄、体重、毛色
		行为：进食、睡眠、玩耍
	  ---------------------------------
		对象：学生
		属性：姓名、年龄、学号
		行为：吃饭、睡觉、学习
	  ---------------------------------
		对象：手机
		属性：品牌、型号、价格
		行为：接打电话、收发短信、上网、玩游戏
	  ---------------------------------


	  2)拥有相同属性和行为的对象被分成一组，即一个类，因此可以说类就是对象的抽象表示
		
	3. 类的表示
	  1)自然语言：人人交互
	  2)数据类型：人机交互
		A.简单类型	- 只能表示一个属性，难以表示更加复杂的信息
		B.数组类型	- 可以表示多个属性，但是类型过于单一
		C.结构类型	- 可以表示多个属性，而且类型可以不同，但是欠缺对行为的描述。
		D.类类型		- 可以表示多个属性，而且类型可以不同，
					  同时可以通过多个不同的成员函数描述不同的行为。
	  
	4. 现实与虚拟
	 	现实空间 --> 逻辑空间-->	虚拟空间
		真实对象 -->    类   --> 逻辑对象


		e.g.
	  一条一岁大，半公斤重的棕色的吉娃娃，啃了一块骨头，睡了一个小时，愉快地去玩耍
		
四、类的定义与实例化
	1. 类的一般形式
		struct/class 类名：继承方式 基类，...{
			访问控制限定符:
				//构造函数————初始化
				类名(形参表):成员变量(初值),...{
					函数体;				
				};
				//析构函数————清理
				~类名(void){
					函数体;
				};
				//成员函数————行为
				返回类型 函数名 (形参表) 常属性 异常说明 {
					函数体;				
				};
				//成员变量————属性
				数据类型 变量名;
		};

		访问控制限定符
		public	  -公有，谁都可以访问
		private   -私有，只有自己可以访问
		protected -保护，只有自己和自己的子类可以访问。


	在C++中struct和class关键字唯一区别就是，缺省访问控制属性不同，struct缺省为公有
	class缺省为私有。

	面向对象的三大基本特性：封装、继承、多态。
	  封装：通过类把事物的属性和行为进行封装。
			通过访问控制限定符对属性和行为的可访问性进行区分。

	  继承：
	

	  多态：



	2.构造函数
	  1)函数名与类型相同，没有返回类型。
		class 类名{
		public:
			类名(构造形参表){
			  构造函数体;
			}
		}
		构造函数在创建对象被系统自动调用。构造函数在对象的整个生命周期中
			一定会被调用，且只被调用一次。
		构造函数通常负责设置对象的初始状态：为成员变量赋初值、分配资源、为对象
		的后续操作做准备工作，等等。


	  2)构造函数可以通过参数表的区别，来差别化对象的初始化方式。

	  3)典型构造函数
		A.缺省构造函数：表示对象的缺省状态。
		  如果一个类没有显式地定义任何构造函数，编译器会自动为其提供一个
		缺省构造函数，该构造函数对于基本类型的成员变量不做任何初始化；
		对于类类型的成员变量，用缺省方式初始化。	
	
		B.类型转换构造函数：可以通过单个不同类型的参数调用的构造函数。在任何涉及
		  类型转换的语境下，被自动执行，完成目标类型的初始化。
	
		C.拷贝构造函数：构造同类型对象的副本(克隆)对象。
		  如果一个类没有显式定义拷贝构造函数，编译器会自动提供一个缺省拷贝构造函数，
		该函数会对所有成员变量按字节复制，多数情况下，缺省拷贝构造函数足够适用，
		无需自行定义，但个别情况下，缺省拷贝构造函数会不够完美，这时就有必要用
		自定义的拷贝构造函数取代之。

			/*-------------*/		/*----------------*/
			自己定义构造函数			编译器提供的构造函数
			/*--------------------------------------------------*/
				无					缺省构造函数、缺省拷贝构造函数
			----------------------------------------------
			  除拷贝构造函数以外  	缺省拷贝构造函数
			的任何构造函数
			----------------------------------------------		
			  拷贝构造函数				无
			----------------------------------------------

			所有编译器提供的构造函数都是公有函数。
			如何禁止对象被复制？   //将拷贝构造函数声明为私有函数。




			【练习】 定义一个时钟类，在控制台上显示一个电子时钟，
				以秒为单位现实当前系统时间。
				






/**************************************************************************/
*															              *	*							  day_04	                                  *	
*									                                      *
/**************************************************************************/





四、...
	2. ...
	  4)初始化表
		初始化表是类构造函数中的特殊结构，用于告诉编译器如何生成对成员变量进行
		初始化变量进行初始化的代码。
		class 类名 {
			//构造函数
			类名(形参表):成员变量1(初始值),成员变量2(初始值){
				...		|< ----------初始化表----------->|
			}
			数据类型 成员变量1;
			数据类型 成员变量2;
		}

		一般而言，对成员变量的初始化既可以在构造函数体中通过赋值完成，
		也可以在初始化表中完成，但是以下两种情况只能悬着后者：
		A. 类类型的成员变量或基类子对象，如果没有缺省构造函数，那么他们就只能
		   在初始化表中，显式指明所要调用的有参构造函数版本

		B. 类中的常量或者引用型成员变量也只能通过初始化指定初值。
			类的成员变量按其在类中的声明顺序依次被初始化，而与其在初始化表中的
		  排列顺序无关。初始化表并不是可执行语句，它的作用仅仅是告诉编译器
		  生成初始化代码时所引用的初始值是什么。


五、非内联的形式定义类
	内联形式定义：将类的构造函数和成员函数直接定义在类的声明中，这些函数只要不是
	  递归函数也不是动态函数，编译器会缺省地将其以内联的方式进行优化。
	非内联形式定义：将类的声明放在头文件(.h)中，将类的实现，即函数定义，
	  放在源文件中(.cpp)中，而将对类的实例化再放在一个独立的源文件(.cpp)中。
	独立的源文件中。现代版本的编译器,对非内联形式定义的类,也会进行必要的内联优化。


	
六、this指针
	1. 类的每个成员函数都有一个隐藏的指针型参数，名为this，该指针指向调用这个成
员函数的对象。类的构造和析构函数中同样有this指针，指向这个正在被构造或析构的对象。
	2. 在类的成员函数、构造函数以及析构函数中，对所有成员变量的访问，都是通过this指针进行的。
	3. 多数情况下，并不需要显式地使用this指针，除非在以下上下文中：
		
	  A. 作用域的名字冲突。
	  B. 从成员函数中返回调用对象的自拷贝或自引用。 
	  C. 从成员函数内部向外传递调用对象自身。



七、常函数
	1. 如果一个类的成员函数被声明为常函数，那么他的this指针就是一个常量指针，在该
	  函数中一切试图修改成员变量的操作都会被认为是非法。除非该变量带有mutable关键字

	2. 原型相同的成员函数其常版本和非常版本可以构成重载关系,常对象/常引用/常指针
	  匹配常版本,非常对象/非常引用/非常指针匹配非常版本,但是如果没有非常版本,
		那么他们也可以匹配常版本。
			常 -> 常
			非 -> 非/常

	3. 只要一个类的成员函数不修改该类的任何成员变量,也不调用任何可能修改成员变量
		的成员函数,那么该成员函数就可以被声明为常函数。 



八、析构函数
	1. 析构函数是类中特殊的成员函数：
	  1)函数名就是类名前面加"~";
	  2)没有返回类型
	  3)没有参数
	  4)不能重载
	
		class 类名{
		public:
			~类名(void){
			  析构函数体：
			}
		};
	2. 析构函数在对象没销毁时由系统自动调用
	  1)静态对象离开作用域时被销毁
	  2) 动态对象由 delete/delete[]操作符销毁
	  3) 析构函数在对象的整个生命周期仅被调用一次

	3. 析构函数主要任务就是释放对象生命过程中所产生的资源。
		
	4. 如果一个类没有显式定义析构函数，编译器也会提供一个缺省析构函数,该析构函数
	  只负责调用类类型成员变量和基类的析构函数,对我们自己动态分配的资源不予理睬,
	  因此有必要为这些资源编写自己的析构函数,予以释放,防止出现内存泄露.






九、支持深拷贝的拷贝构造 拷贝赋值
	  1. 编译器提供的缺省拷贝只对对象进行浅拷贝,指针类型的成员只是按字节复制其本身,
	而不复制其目标内容,这样的结果就是拷贝目标对象和拷贝源对象共享一份内容资源,
	不仅发生资源偶和,而且还有double free异常风险。

	  2. 通过自己定义拷贝构造函数和拷贝赋值操作符函数,可以实现同类型对象间的
	深拷贝语义,即分配独立资源并复制内容,既保证拷贝目标对象和源对象不发生资源偶和,
	同时避免了double free一场的风险。
	
	  3. 只要一个类含有指针类型成员变量,而且该变量所指向的内存是该类动态产生的,
	那么就有必要为其定义支持深拷贝的拷贝构造函数和拷贝赋值操作符函数。
	
	  4. 拷贝构造和赋值不仅开销巨大而且还有浅拷贝风险,因此应该尽可能避免出现拷贝
	构造和赋值。比如通过引用来传递参数,或者从函数返回。




	/*练习：
		实现一个整型数组类,通过构造函数指定容量,拷贝构造和拷贝赋值需要支持深拷贝
	接口：
		push	-在数组的尾部存入一个元素
		pop		-从数组的尾部弹出一个元素
		get		-根据下标获取一个元素
		set		-根据下标修改一个元素
		clear	-清空数组
		empty	-判断数组是否空
		find	-返回指定元素第一次出现的下标
		replace	-全部替换
		reverse -逆转
		sort	-从小到大排序
		print	-打印		

*/







/**************************************************************************/
*															              *	*							  day_05	                                  *	
*									                                      *
/**************************************************************************/



﻿局部变量	--栈区
静态局部变量- \
全局变量	 	-  >	静态区(数据区+Bss区)
静态全局变量- /
动态变量		--堆区
成员变量	--对象所在区


一、静态成员
  1.静态成员变量
  	1)静态成员变量是类的一部分，而不是对象的一部分呢，不存在该类任何对象内部。
  	却可为该类的任何对象所共享，和全局变量一样存放在静态区中，既可以通过对象
  	访问，也可以通过类直接访问。
	
		2)语法：声明时需要增加static关键字，定义和初始化必须在类的外部单独进行。
		
		3)场景应用：既满足类型的封装和保护，同时又为该类的对象所共享。
			  既像成员变量受类型和访问控制属性的限制，又像全局变量不
			  拘泥于某一个具体的对象。
class Account{
public:
	string m_name;
	int m_id;
	string m_passwd;
	double m_balance;
	...//静态成员函数
	static void setRate(float rate){
		m_rate = rate;
	}
	...
private：
	static float m_rate;
};

	2.静态成员函数
		1)被声明为静态成员函数的成员函数，没有this指针，因此不需要通过
		对象来调用，当然也就无法访问任何于对象有关的资源。
		
		2)静态成员函数只能访问静态成员,
		但是非静态成员函数既可以访问非静态成员也可以访问静态成员。
		
	3.静态成员的应用---单例模式
	 1)构造函数私有化---静止在外部创建对象
	 2)在类的内部创建唯一对象实例(静态成员)---内部可以访问私有构造函数
	 3)提供公开接口(静态成员)以方便在类的外部获取对象实例
		
二、成员指针
class Student{...};
Student student;
string* pname = &student.m_name;//不是成员指针
	1.指向成员变量的指针
	类型 类名::*成员变量指针；
	成员变量指针 = &类名::成员变量；
	对象*成员变量指针 //.* 成员指针解引用运算符
	对象指针->*成员变量指针// ->* 间接成员指针解引用运算符
	
	成员变量指针的本质，就是特定成员变量在类对象实例中的相对地址。
	成员变量指针解引用，就是根据类对象实例的起始地址，结合成员变量指针
	中相对地址，计算出具体成员变量的绝对地址，并访问之。
	
	2.指向成员函数的指针
	返回类型（类名::*成员函数指针）(形参表)[常属性]；
	成员函数指针 = &类名::成员函数名；
	(对象.*成员函数指针)(实参表);
	(对象指针->*成员函数指针)(实参表);
		
		 虽然成员函数并不存在存储在对象中，不存在根据相对地址计算绝对地址的问题，
		但也要通过对象或对象指针对成员函数指针引用，起目的只有一个，
		即提供this指针。
		
		
		
三、操作符重载
	1.基本思想：在特定条件下，C++编译器有能力把一个由操作数和操作符组成的表达式解释为一个全局或者成员函数调用，该全局或成员函数被称为操作符函数。程序设计者，通过自己定义操作符函数，就可以实现针对自定义类型的运算法则，并使之与内置类型一样参与各种表达式的运算。
		
		复数：3+4i
		
	2. 运算类双目操作符
		L#R
	L.operator#(R);//左调右参
	::operator#(L,R); //左一右二		

	3. 插入提取操作符
	cout << R;
	::operator << (cout,R);
	cout >> R;
	::operator >> (cin,R);
		
	4. 运算类单目操作符
		#O/O# 
	  O.operator#();
	  ::operator#(O);:		
		
	5. 自增减操作符
	  ++O
	  O.operator++();
	  ::operator++(O);

	  O++
	  O.operator++(0);//0只是区分重载,没有其他意义
	  ::operator++(O,0);




	

---------------------------------------------
(1)	int a = 4;
	A. a += (a++); //a = a + (a++)  9	
	B. a += (++a); //a = a + (++a)  10
	C. (a++) += a; //error
	D. (++a) += (a++);// 11

	// a++ 等价 a+1
	// ++a 等价 a = a+1;


(2) 在C++运算符集合中，有一些运算符是不能被重载的，这种制度是处于安全方面考虑的。
	可以防止错误和混乱。
	不能被重载的运算符： .  #  @  $  ::






/**************************************************************************/
*															              *	*							  day_06	                                  *	
*									                                      *
/**************************************************************************/




三、...
	6. 下标操作符([])
	用于在容器类型中以下标方式访问其中的数据元素。

class 容器类型：
public:
	元素类型& operator[](int i){...}
	元素类型 const& operator[] (int i) const{
		return const_case<容器类型&>(*this)[i];
	}
};


	7. 函数操作符(())
	如果为一个类定义了形如：operator()的操作符函数,那么该类的实例化对象
	  就可以被当作函数看待,所调用的就是operator()操作符函数,该操作符函数是唯一
	一种参数个数和返回值类型完全自由指定的操作符函数。


	8. 解引用(*)和间接成员访问(->)操作符

目标对象类型& operator* (void){
	return 目标对象;
}
目标对象类型* operator->(void){
	return 目标对象的地址;
}
智能指针
#include <memory>
auto_ptr<T>   T可以是任何类型,用于封装一个动态对象的指针,通过局部智能指针对象在离开
		作用域时被析构的过程,delete动态创建的对象,避免内存泄露。




	9. 自定义类型转换
	  1)类型转换构造函数
class 目标类型{
	目标类型(源类型 const& src){...}
};


	  2)类型转换操作符函数
class 源类型{
	operator 目标类型 (void) {return 目标类型对象;}
};


	  3)源类型是基本类型,只能通过构造函数实现自定义类型转换;
		a.目标类型是基本类型,只能通过类型转换操作符函数实现自定义类型转换;
		b.源类型和目标类型都不是基本类型,两种自定义类型转换的实现方式可以任取其一,
			但是不要同时使用,避免歧义;
		c.源类型和目标类型都是基本类型,无法实现自定义类型转换,完全由编译器的内置
		  规则实现两种类型的转换。
		
	  4)explicit关键字的作用是将自定义类型转化强制为显示
			
		即：
a.通过构造函数实现自定义的类型转换
   基本类型--》类类型
   类类型  --》类类型
   
b.通过类型转换操作符函数实现自定义的类型转换
   类类型  --》基本类型
   类类型  --》类类型
   operator 目标类型(void)const{...}
   
c.两个基本类型不能自定义转换
d.两个自定义类型两种方式都可以实现

	11. 操作符重载的限制

1）不是所有的操作符都能重载，下面这些不能重载
作用域限定操作符"::"
直接成员访问操作符"."
直接成员指针解引用操作符".*"
条件操作符“?:”
字节长度操作符"sizeof"
类型信息操作符"typeid"//获取一个类型或变量信息

2）如果一个操作符的操作数都是基本类型，则无法重载
 int operator+ (int a，int b ){//error
    return a-b;
 }
 int x = 1 + 1;//0？ NO!

3)操作符的重载不会改变编译器预定的优先级
Integer const operator^ (Integer const& x,int y){...}
计算x的y次方
d = a + b ^ c; //(a+ b)^c
4)操作符重载不会改变操作数的目数
double operator%(Integer const& i){
	return i.m_i/100.0
}
x = 50%;//0.5?
5)无法通过操作符重载发明新的操作符
Double const operator @ (Double const& a,
	Double const& b){
	return Double (sqrt(a.m_d*a.m_d+b.m_d*b.m_d));
}
c = 3.0@4.0;//5.0?
6) 重载操作符不要违背正常人类的习惯,不要破坏代码的可读性,
	不要使操作符重载成为炫耀语法特性的奇淫巧计。



/*--------------------------------------------------*/

一、类的继承
  1. 继承的基本概念
	1)共性与个性
	第一级抽象：从对象的属性和行为到类
	  学生类：姓名、年龄、学号、吃饭、睡觉、学习
 	  教师类：姓名、年龄、工资、吃饭、睡觉、讲课
	第二级抽象：从不同的类型提取共同属性和行为
	  共性：类型相同的属性和行为
	  个性：类型间不同的属性和行为

      人类(基类、父类)			派生
     /    \					  	 V  	^
 学生类  教师类(派生类、子类)			   继承


	2. 继承的语法
class 子类：继承方式1 基类1,继承方式2 基类, ... {...};
		   |<----------继承表---------------->|	

	所有基类中的成员除了构造和析构函数以外都可以被子类所继承,
	无论是在子类内部还是在子类外部,只要所访问的成员不是私有成员,
	都可以和子类自身成员一样,直接访问。————皆然性
		————一个子类对象就是一个基类对象(ISA)。


	继承方式：
	public 		-共有继承,最为常见
	protected 	-保护继承\  不多见
	private		-私有继承/  应避免


	3. 公有继承
	  1) 逻辑：子类即基类
	  2) 物理：父类的子类对象是其父类子对象的父对象。




 	练习：增加一个下标操作符,使得矩阵对象可以通过类似二维数组的方式访问指定
	  行列的元素。








/**************************************************************************/
*															              *	*							  day_07	                                  *	
*									                                      *
/**************************************************************************/
 

一、...
	3. 公有继承
	  1) 逻辑：子类即基类
	  2) 物理：父类的子类对象是其父类子对象的父对象。
	  3）向上和向下造型
		A. 向上造型：把一个子类类型的指针或引用转换为其基类类型的指针或引用。
		  向上造型在编译器看来是安全的,因此可以隐式完成。

		B. 向下造型：把一个基类类型的指针或引用转换为其子类类型的指针或引用.
		  向下造型在编译器看来是有风险的,因此必须显式完成。
			
		C. 编译器对类型安全所做的检测,仅仅基于指针或引用本身的数据类型,而与其
		   目标对象的实际类型无关。基类类型的指针或引用实际目标对象的类型,究竟
		   是否与需要转换的指针或引用的目的类型一致,完全由程序员自己判断。在确认
		   安全性的前提下,可以通过静态类型转换(static_cast<>)实现显式的向下造型
	  4) 保护成员
		被protected访问控制属性约束的成员被成为类的保护成员,该成员仅可以被声明
		该成员的类及其子类访问。	
		
					类内部	子类中	类外部	友元中
		公有成员		 OK		  OK	  OK	 OK
		保护成员		 OK		  OK	/*NO*/	 OK
		私有成员		 OK		/*NO*/	/*NO*/ 	 OK

	5）区分隐藏和重载
		A. 只要子类中含有和基类中同名的标识符即构成名字隐藏,在不使用任何作用域限定
		的前提下,直接访问到的都是子类中的名字,通过作用域限定才会有访问到基类中的名称
		B. 基类和子类虽然存在派生和继承的逻辑关系,但它们毕竟是两个不同的类型,即各自
		 拥有独立的作用域,因此即使是同名异参的成员函数也不能构成重载关系,除非通过
		 using 声明强制其同处于一个作用域中。


 	4. 私有继承和保护继承
	  1)继承方式对访问控制属性的影响
		当通过一个子类类型的对象访问它从基类继承的成员时,不同的继承方式会影响该成员
		在子类中访问控制属性。

		公有继承,基类中的访控属性和子类中访控属性完全一致。
		私有继承,基类中的所有成员在子类中都被视为私有成员。
		保护继承,基类中的公有成员在子类中被视为保护成员。

class DCT {//$100
public:
	void codec(void){...}
};

class Jpeg : /*private*/protected DCT{ //私有继承 //保护继承
public:
	void render (const char* jpgFile){
		...
		codec ();
		...
	}
};
class Jpeg2000:public Jpeg{
public:
	void render (const char* jpgFile){
		...
		codec ();
		...
	}
};

Jpeg jpeg (...);
jpeg.render("sea.jph");
jpeg.codec(); //报错

	私有继承：防止基类中的公有成员通过子类被扩散出去。	
	保护继承：防止基类中的公有成员通过子类被扩散到继承链的外部,但是并不妨碍子类
		的子类继续访问。
	私有继承和保护继承在逻辑上不存在皆然性,即没有IsA的关系.
	 因此无论哪中继承都不能隐式地向上造型。


	5. 子类的构造、析构、拷贝构造和拷贝赋值
	  子类对象中包含了基类子对象，因此子类的构造、析构、拷贝构造和拷贝赋值,
	  就必须同时兼顾其基类子对象的构造、析构、拷贝构造和拷贝赋值。

		1) 子类的构造函数：
		  A.隐式构造基类部分：如果子类的构造函数没有显式指明基类部分的构造方式,
			那么编译器会选择基类的缺省构造函数,构造该子类对象中的基类子对象。
			这样做的前提就是基类中必须有缺省构造函数，否则将导致编译失败。

		  B. 显式构造基类部分：子类的构造函数可以在初始化表中显式指明其基类部分的
			构造方式,即通过其基类的特定构造函数,构造该子类对象中的基类子对象。
	
		  C. 子类对象的构造过程：子类的构造函数执行如下步骤
			a.首先,按照继承表的顺序,一次调用各个基类的构造函数,
			  构造子类对象中的基类子对象；
			b.其次,按照声明顺序,一次调用各个类类型成员变量相应类型的构造函数,
			  构造子类对象中的成员子对象;
			c.最后,执行子类构造函数体中的代码,完成整个构造过程。


		2) 子类的析构函数
		A.	子类的析构函数,无论是自己定义的,还是编译器提供的,在执行完其中的析构代码
		 并析构万所有的类类型成员子对象以后,会自动调用其基类的析构函数,析构该子类
		 对象中的基类子对象。析构顺序和构造的顺序一定是严格对称的。
		B. 对一个指向子类对象的基类指针使用delete操作符,实际被调用的将是基类的析构
		   函数,该函数不会调用子类的析构函数,其所析构的仅仅是子类对象中的基类子对象
		   而子类的扩展部分极有可能因此而形成内存泄露。
		实践中可以通过静态类型转换对基类指针做向下造型,解决此问题。



		3) 子类对象的拷贝
		 A.如果子类没有定义拷贝构造/拷贝赋值函数,那么编译器会为子类提供缺省的
		  拷贝构造/拷贝赋值函数,该函数会自动调用其基类的拷贝构造/拷贝赋值函数,
		  拷贝子类对象中的基类子对象。

		 B.如果子类定义了拷贝构造/拷贝赋值函数,但是没有显式指明基类子对象的拷贝方式
		  那么编译器要么以缺省方式初始化该子对象,要么令该子对象保持原状,
		  均无法获得完整意义上的子对象副本。

	     C.如果子类定义了拷贝构造/拷贝赋值函数,同时也显式指明了基类子对象的拷贝方式
		  那么子对象中基类部分和扩展部分将被一起复制,最终得到完整意义上的子对象副本



6. 多重继承
	1)概念
		如果一个子类同时从多个基类继承,就形成多重继承的结构。
	//多重继承的例子：
		技术员	 经理    销售员
			\   /   \   /
		  技术主管  销售主管

		学生   教师
			\ /
		  项目经理

		电话	  播放器	 计算机
			\   |   /
			 智能手机

	2)语法：在类的继承表中依次写出子类的每个基类及其继承方式。
class 子类: 继承方式1 基类1,继承方式2 基类2,...{..};

	子类从多个基类中继承他们的成员,任意一个基类的成员都可以被当做子类的成员,
	在子类的内部或外部被访问, 前提是不违背访问控制属性和继承方式的约束。


	3)对象模型
	  A.子类对象中的多个基类子对象,按照继承表的顺序一次被构造,并从地地址到高地址
		排序,析构的顺序则与构造的顺序相反。
	  B.将继承自多个基类的子类类型的指针,隐式或静态转换为它的基类类型,编译器会根据
	    各个基类子对象在子类对象中的内存布局,进行适当的偏移计算,以保证指针的类型与
		其所指向目标对象的类型一致,反之亦然。



	4)名字冲突与重载
	  A. 如果多个基类存在相同的标识符,将在子类中产生名字冲突

	  B. 在不同基类中声明的同名异参成员函数,由于存在名字冲突,且作用域不同,
		因而无法在子类中形成重载,除非通过using声明将其强制引入子类的作用域,
		构成重载关系。







/**************************************************************************/
*															              *	*							  day_08	                                  *	
*									                                      *
/**************************************************************************/


一、钻石继承
	1. 派生一个子类的多个基类源于共同的祖先,这样的继承结构被称为钻石继承(菱形继承)
				A			——公共基类(总基类)
			   / \			
			  B	  C			——中间基类/中间子类(中间类)
			   \ /			
				D			——汇聚子类(混合类)

				员 工								人
			   /  |   \							   /  \
		技术员	 经理    销售员					学生   教师
			\   /   \   /						   \ /
		  技术主管  销售主管						 项目经理

			 电子设备		
		    /   |    \
		电话	  播放器	 计算机
			\   |   /
			 智能手机

	问题：当通过汇聚子类沿着不同继承路径访问公共基类中成员,会出现数据不一致的问题.
		  其原因就是在不同的中间子类存在多个独立的公共基类子对象。


	2. 虚继承
		在继承方式中增加virtual关键字,这样得到的子类就是其基类的虚子类,所有中间
	  子类中的公共基类子对象将只有一个实例,且同时为这些虚子类所共享。即使沿着不同
	  的继承路径访问公共基类子对象中的数据,也不可能不一致。

	  1)解决钻石继承结构中的数据不一致问题。
	  2)阻断继承——禁止一个类被继承。


二、虚函数和多态
	
				图形:位置、绘制
				/	\
	矩形:长宽、绘制   圆形:半径、绘制
	

	1. 虚函数
	形如：
class 类名{
	virtual 返回类型 函数名 (形参表) [const] {...}
};
	的成员函数,称为虚函数或方法。
	
	2. 覆盖
	  如果子类的成员函数和基类中的虚函数具有相同的函数原型,那么该成员函数
	  就也是虚函数,无论是否带有virtual关键字,且对基类中的虚函数构成覆盖关系。

	3. 多态
	  如果子类提供了对基类虚函数的有效覆盖,那么通过一个指向子类对象的基类指针,
	  或者引用子类对象的基类引用,调用该虚函数,实际被调用的是子类中的覆盖版本,而非
	  基类中的原始版本,这种语法现象称为多态。

	4. 多态的意义
	  多态的重要意义在于,一般情况下,调用那个类的成员函数是由调用者指针或引用本身的
	  类型决定的,而当多态发生时,调用哪个类的成员函数则完全由调用者指针或引用的实际
	  目标对象的类型决定。这样以来,源自同一种类型的同一中激励,竟然可以产生不同的响应
		谓之多态。

	  高聚低耦
	
三、覆盖的条件
	1. 必须是(非静态)成员函数。
	2. 必须是虚函数。
	3. 函数的签名(函数名+形参表+常属性)必须相同。
	4. 一般而言返回类型也应该相同,但是只有一个例外:类型协变(基类对基类/子类对子类)。
	
	如果基类中的虚函数返回的是一个类的指针或引用,那么其子类中的覆盖版本允许返回基类
	版本所返回的指针或引用的目标类型的子类的指针或引用,这就叫返回类型协变。
	
	注意：基类的原始版本和子类的覆盖版本,他们的访问控制属性不一定非得一样。

	vi 05overRide.cpp


四、多态的条件
	1. 多态特性除了需要在基类中声明虚函数之外,还必须借助指针或者引用
		调用该虚函数才能表现出来。
	2. 调用虚函数的指针也可能是成员函数中的this指针,只要它是一个指向子类对象的
		基类指针,同样可以多态。
	3. 当基类的构造函数被子类的构造函数调用时,子类对象尚不能说是子类类型的,它中
		表现出基类类型的外观和行为。这事调用虚函数,没有多态性。
	4. 当基类的析构函数被子类的析构函数调用时,子类对象已不再是子类类型的了,它只
	  	表现出基类类型的外观和行为。这时调用虚函数,没有多态性。


五、纯虚函数、抽象类、纯抽象类
	1. 纯虚函数
	  形如
class 类名{
	virtual 返回类型 函数名 (形参表) [const] = 0;
};
	的虚函数,称为纯虚函数或抽象方法。
	
	2. 抽象类
	  至少包含一个纯虚函数的类称为抽象类。抽象类不能被实例化为对象。
	  如果抽象类的子类不对基类中所有的纯虚函数都提供有效覆盖,
		那么它就会继承未被覆盖的纯虚函数,进而也成为抽象类。

	3. 纯抽象类
	  如果一个类出来构造函数和静态成员函数以外,所有的成员函数都是纯虚函数,
		那么这样的类就是纯抽象类。纯抽象类亦称接口类,旨在定义功能性接口,
	  但是不需要提供接口的具体实现,具体实现由子类给出。
	


六、虚函数调用的工作原理
	1. 虚函数表
		包含虚函数的类
class B{
	virtual int f1 (void);
	virtual void f2 (int);
	virtual int f3 (int);
};

		编译器会为每个包含虚函数的类生成一张虚函数表,即存放每个虚函数地址的
		函数指针数组,简称（vtbl),每个虚函数对应一个虚函数表中的下标。

			0-> B::f1
			1-> B::f2
			2-> B::f3		
		
		  除了为包含虚函数的类生成虚函数表以外,编译器还会为该类增加一个隐式成员
		变量,通常在该类实例化对象的起始位置,用于存放虚函数表的首地址,该变量被称为
		虚函数指针,简称虚指针(vptr)
	代码：
B* pb = new B;
pb->f3(12);
被编译为：
	pb->vptr[2](pb,12);//B::f3

		虚表是一个类一张,而不是一个对象一张,同一个类的多个对象,通过各自的虚指针,
		共享同一张虚表。
		继承自B的子类
		class D : public B{
			int f1 (void);
			int f3 (int);		
			virtual void f4 (void);
		};
		子类覆盖了基类的f1和f3,继承了基类的f2,增加了自己的f4,编译器同样会为子类
		生成一张专属于它的虚表。
			0->D::f1
			1->B::f2
			2->D::f3
			3->D::f4
		指向子类虚表的虚指针就存放在子类对象的基类子对象中,通常在起始位置。
	代码：
B* pb = new D;
pb->f3(12);
被编译为：
pb->vptr[2] (pb,12);//D::f3

		这就是多态的工作原理







	2. 动态绑定
		当编译器看到通过指针或者引用调用基类中的虚函数时,并不急于生成有关函数调用的
	  指令,相反它会用一段代码替代该调用语句,这段代码在运行时被执行,完成如下操作:
		1)根据调用指针或引用的目标对象找到其内部的虚表指针;
		2)根据虚表指针找到其所指向的虚函数表;
		3)根据虚函数名和函数指针在虚函数表中的下标中的索引,找到所调用虚函数的
		  入口地址;
		4)在完成函数调用的准备工作以后,直接跳转到虚函数入口地址处顺序执行函数体
		  指令序列,知道从函数中返回。
	
	3. 动态绑定对性能的影响
		1)虚函数表和虚指针的存在势必要增加内存空间的开销。
		2)和普通函数调用相比,虚函数调用要多出一个步骤,增加运行时间的开销。
		3)动态绑定会妨碍编译器通过内敛优化代码,虚函数不能内联。
	  鉴于以上三点,只有在确实需要多态特性的场合下才会使用虚函数,否则还是尽量使用普通函数。

	
七、运行时类型信息
	1. typeid 操作符
	  typeid 操作符可以作用于任何类型的对象或变量,既可以是类类型的,
	  也可以是基本类型的。该操作符会返回一个类型为typeinfo的对象的常引用,
	  通过该对象可以获得有关类型的信息。
	typeinfo::name(): 返回类型名标签
	typeinfo::operator ==/!= :类型比较
	typeid 操作符既可以在静态模式下工作,获取有关类型的静态信息,也可以在动态模式
	下工作,获取运行时类型信息。但是为了获取运行时类型信息,必须存在多态继承。

	2. dynamic_cast 动态类型转换
	  将多态基类的指针或引用造型为其子类类型的指针或者引用,如果该指针或引用的
	  目标对象确实为要求的类型,造型成功,否则失败,返回空指针(指针)或抛出一场(引用)。



八、虚析构
	1. delete 一个指向子类对象的基类指针,实际被调用的仅仅是基类的析构函数,该函数只
	  负责析构子类对象中的基类子对象,而基类的析构函数不会调用子类的析构函数,因此在
	  子类中分配的资源将形成内存泄露。

	2. 如果将基类的析构函数声明为虚函数,即虚析构,那么当delete一个指向子类对象的基类
	  指针时,实际被调用的将是子类的析构函数。子类的析构函数将首先析构子类对象的扩展
	  部分,然后在通过基类的析构函数析构该对象的基类部分,最终实现完美的资源释放。

	3. 没有分配任何资源的类,无需定义析构函数。没有定义析构函数的类,编译器会为其提供
	  一个缺省析构函数,但缺省析构函数并不是虚函数。为了保证delete一个指向子类对象
	  的基类指针时,能够正确调用子类的析构函数,就必须把基类的析构函数声明为虚函数,
	  即使它是一个什么也不做的空函数,谓之空虚析构。

	4. 一般而言,只要一个类包含了虚函数,而且有可能从该类派生出子类,那么就应该将该类的
	  析构函数声明为虚函数,至少不会有坏处。


	哪些函数可以是虚函数？		(-X 不能虚  -O 能虚)
		全局函数				-X
		静态成员函数			-X
		非静态成员函数		-O
		构造函数				-X
		析构函数				-O
		成员函数形式的操作符函数	-O
		友元函数形式的操作符函数	-X

	/*-----------------------------------*/
	  不能通过对象找到指针的都不能是虚函数。


	
九、异常
	1. 异常的作用
	  解决在分析、设计、编码和测试阶段都无法预见的故障和错误。

	2. 异常的处理
	  1)通过返回值表示异常
	利:调用路径中各级函数的局部对象都能得到正确的析构
	弊：调用路径中逐层判断返回值,流程复杂,源代码量大
	  
	  2)通过setjmp/longjmp远程跳转处理异常
	利:无需逐层判断返回值,流程简单,源代码量小
	弊:调用路径中各级函数的局部对象的不到正确的析构

	  3)C++异常————两全其美的解决之道
		既无需逐层判断返回值,流程简单,源代码量小,同时沿着函数调用的逆序做调用栈的
	  辗转开解(即一次执行调用路径中每个函数的右花括号),保证所有的局部对象都能
	  得到正确的析构。

	3. 异常语法
	  1)抛出异常：throw 异常对象;
	异常对象既可以是基本类型,也可以是类类型。
	throw -1;
	throw "文件打开失败！";
	throw FileError (...);//抛出匿名对象(建议)
	FileError ex(...);
	throw ex;//抛出有名对象(不推荐)

			
	  2)捕获异常
	try{
		可能抛出异常的语句;
	}
	catch (异常类型1& 异常对象){
		针对异常类型1的异常处理;
	}

	catch (异常类型2& 异常对象){
		针对异常类型2的异常处理;
	}
	...
	catch (...){
		处理其他异常;
	}



	4. 异常流程
	  1)不发生异常时
		两个执行:throw 之后的代码执行,try 块中引发异常语句之后的代码执行。
		两个不执行:throw 语句不执行, catch 块不执行。

	  2)发生异常时
		两个执行：throw 语句执行, catch 块执行。	
		两个执行:throw 之后的代码不执行,try 块中引发异常语句之后的代码不执行。

	检查异常条件->执行throw语句->沿着所调用函数的右花括号一路回溯,析构局部对象
		->知道try的右花括号->匹配catch块的异常类型->执行catch块中的代码,
		  处理所捕获的异常->执行 try-catch 结构以后的代码。





	练习： 通过异常向函数的调用者提供更多的故障信息。
			故障原因、源文件、行号、函数。





/**************************************************************************/
*															              *	*							  day_09	                                  *	
*									                                      *
/**************************************************************************/




九、...
	5. 异常说明
	  1)异常说明是函数原型一部分,旨在说明函数可能抛出的异常范围。
		函数原型：返回类型+函数名+形参表+常属性+异常说明
	    异常说明：throw(异常类型表)
	void fuck (int x,int y)throw(MemoryError,
			FileError,DivByZero){
		void* pv = malloc (1024);
		if(!pv)
			throw MemoryError(..);
		..
		FILE* fp = fopen ("none","r");
		if(!fp)
			throw FileError(..);
		..
		if(y == 0)
		  	throw DivByZero(..);
	}


	异常说明是一种承诺,承诺函数不会抛出异常说明以外的异常类型。如果函数违背承诺,
  抛出了异常说明以外的异常,那么所抛出的异常无法被该函数的调用者捕获,最终这些异常
  会被C++标准库捕获,知道杀灭进程,同时将与该异常有关的类型信息打印在标准输出(1)或
  标准出错(2)上。


	  2)异常说明的两个特殊形式
		A.throw() -该函数不抛出任何异常
		B. 没有异常说明 -该函数可以抛出任何异常

	  3)如果基类中的虚函数带有异常说明,那么该函数在子类中的覆盖版本不能说明比基类
		版本抛出更多的异常。




	6. 异常的特殊用法
	  1)不处理异常：如果一个函数对于可能引发的异常不予捕获,那么该异常会向这个函数的
		调用者继续抛出,知道被捕获.如果知道mian函数都没有捕获这个异常,那么标准库会
		捕获它,同时杀灭进程。
	
	  2)捕获并继续抛出异常：在catch块中继续抛出所捕获的异常。
			用法：  throw;

	  3)在构造函数中抛出异常：在对象的初始化或资源分配过程中遇到的各种错误,但是
		要注意,如果构造函数抛出异常,那么该对象的析构函数就不会被执行,有关动态资源
		释放的操作必须在构造函数抛出异常之前手动完成。
		
	基类子对象、成员子对象、通过auto_ptr<T>管理的动态对象,无需考虑内存泄露问题
因为构造函数的自动回滚机制,可以保证这些对象的析构函数在异常抛出的同时被正确执行。


	  4)析构函数抛出异常
		  警告：最好不要从析构函数中抛出异常。因为析构函数本身就是异常处理的一部分。
		如果在析构函数中抛出异常,就会打断函数栈帧辗转开解的过程,进而引发更多的异常,
		最终导致进程崩溃。为了防止被析构函数调用的其他函数抛出的异常从析构函数中被继续抛出,还应该在析构函数返回以前,尽可能捕获所有可能的异常。





十、I/O流
	1. I/O流类库
	  1)文件I/O
		#include <fstream>
		ifstream	-读文件
		ofstream	-写文件
		fstream		-读写文件
		
	  2)内存I/O
		#include <sstream>
		istrstream	-读内存
		ostrstream	-写内存
		strstream	-读写内存

	2. I/O流的打开和关闭
	  1)直接利用I/O流类的构造函数打开I/O流
		I/O流类名I/O流类对象(路径,模式);
		fstream fs("/some.txt",ios::in|ios::out);

	  2)调用I/O类所提供open成员函数打开I/O流
		I/O流类对象.open (路径,模式);

	  3)调用I/O类所提供从咯色成员函数关闭I/O流
		I/O流对象.close();
		fs.close();

	  4)直接利用I/O类的析构函数关闭I/O流

{
	fstream fs("/some.txt",ios::in|ios::out);
	//...
}-> fstream::~fstream()  //关闭fs所对应的I/O流

	其中模式：

	ios::in //C:fopen(..,"r");
	打开文件用于读取,不存在则失败,存在不清空
	适用于ifstream(缺省)/fstream

  	ios::out //C:fopen(..,"w");
	带开文件用于写入,不存在则创建,存在则清空
	适用于ofstream(缺省)/fstream

	ios::app //C:fopen(..,"a");
	打开文件用于追加,不存在则创建,已存在不清空
	适用于ofstream(缺省)/fstream

	ios::trunc //
	打开文件时清空原内容
	适用于ofstream/fstream

	iso::ate  //at end 
	打开时定位到文件尾
	适用于fstream/ofstream/fstream

	iso::binary//C:fopen(..,"b");
	以二进制方式读写
	适用于ifstream/ofstream/fstream

	打开模式可以组合使用:ios::in|ios::out -既读又写
	无意义组合结果未定义:ios::in|ios::trunc -清空了怎么读???
	
	合理的组合结果有定义:ios::in|ios::trunc|ios::out 
				-清空原内容,写入新内容,读取新写入的内容


	3. I/O流的状态
	  每个I/O流对象内部都有一个表示状态的成员变量,通常就是一个unsigned int,其中每个
	  二进制位表示一种状态,
			常用状态:
			good,好,状态位全零,表示流对象正常可用 -> 流对象->bool = true
			bad,坏,文件系统发生致命错误		\
			eof,文件尾,文件位置到达文件末尾   > 流对象-> bool = false
			fail,失败,最后一次I/O出错        /

	  ios::clear() - 复位流状态,使流对象继续工作




	4. I/O流的格式化
	  1)流函数:在ios总基类里定义的一组与输入输出格式控制有关的成员函数,调用这些函数
	  	会对以后的输入输出格式造成不同的影响。
		  A.浮点数的精度
			int ios::precision (int);//设置,设置新值返回旧值
			int ios::precision (void) const;//获取,返回当前值
		  对于浮点小数,精度是指有效数字的位数。
			  123.4567000 --精度10
		  对于科学计数法表示的定点小数,精度是指小数部分的位数。
			  1.234567000E2 -精度9
	
		  B.域宽、
			int ios::width (int);
			int ios::width (void) const;
		
		  C.填充字符
			char ios::fill (char);
			char ios::fill (void) const;

		  D.格式标志
			long ios::setf (long);	//添加标志位,返回原标志
			long ios::setf (long),long);
			//先清除互斥域(第二个参数),再添加标志位,返回原标志
			
			long ios::unsetf (long); //清除标志位,返回原标志


		标志位				互斥域			说明
	----------------------------------------------
		ios::left							左对齐
		ios::right		ios::adjustfield	右对齐
		ios::internal						两端对齐,左号右数
	-----------------------------------------------
		ios::dec							十进制
		ios::oct		ios::basefield		八进制
		ios::hex							十六进制
	-----------------------------------------------
		ios::fixed		ios::floatfield		普通定点小数
		ios::scientific 					科学计数法
	-----------------------------------------------
		ios::showpos						显示正号
		ios::showbase						显示进制前缀0/0x
		ios::showpoint						显示小数点和尾数0
		ios::uppercase						数字中的字母大写
		ios::boolalpha						用字符串显示布尔值
		ios::unitbuf						每次插入刷流缓冲
		ios::skipws 						以空白字符作为分隔符


	  2)流控制符：直接插入到流对象中,控制输入输出格式,其作用与流函数相当。如果使用
		流控制带有参数,需要包含头文件：
			#include <iomanip>
		 left/right/internal
		 dec/oct/hex
		 fixed/scientific
		 (no)showpos		
		 (no)showbase
		 (no)showpoint
		 (no)uppercase
		 (no)boolalpha
		 (no)unitbuf
		 (no)skipws
		  ends(空字符)/endl(换行)/flush(刷流)
		  setprecision (int) //设置精度
		  setw (int)	//设置域宽
		  setfill (char) //设置填充字符
		  



	5. 二进制I/O
	  istream& istream::read(char* buf,size_t num);
	  从输入流中读取num个字节到buf缓冲区中。返回的是输入流对象本身。可以通过
	istream::gcount()函数最后一次读取到的字节数。如果实际读取的字节数和num参数
	相等,输入流状态就是good,否则就是bad/eof。

	  ostream& ostream::write(char* buf,size_t num);
	  从buf缓冲区中向输出流写入num个zijie。写入成功输出流状态为good,否则为bad/fail
	

	6. 随机I/O
	  istream& istream::seekg (int offset,int origin);//设置读位置
	  ostream& ostream::seekp (int offset,int origin);//设置写位置
		origin:
		ios::beg	-从文件头(SEEK_SET)
		ios::cur	-从当前位置(SEEK_CUR)
		ios::end	-从文件尾(SEEK_END)

	  int istream::tellg (void);//获取读位置
	  int ostream::tellp (void);//获取写位置



	7. 字符串流
	  istringstream/ostringstream


		练习：实现一个基于异或算法的加密解密程序
			1. 生成单字节的随机密钥K；
			2. 用密钥K和铭文文件中的每一个字节做异或运算,写入密文文件
				P ^ K = C
			3. 用密钥K和铭文文件中的每一个字节做异或运算,得到明文文件
				Ｃ ^ K = P
			其中 Ｐ - 明文字节
				 Ｃ - 密文字节
				 Ｋ - 密钥字节

		





