/**************************************************************************/
*															    		  *	
*								day_10					   				  *	
*									   									  *
/**************************************************************************/




		一、进程的管理
		二、信号的处理


	1. 进程的管理
	1.1 进程的创建
		(1) fork函数
	
		#include <unistd.h>

        pid_t fork(void);
		

	函数功能：
		主要用于以复制当前正在调用进程的方式来启动一个新进程,而其中新启动的进程
	  叫做子进程,原来的进程叫做副进程,函数调用成功时父进程返回/*子进程的进程号*/，
	  /*子进程返回 0*/，函数调用失败时直接返回-1，没有子进程被创建;
		

	注意：
		父子进程的执行次序由操作系统的调度算法决定；


		(2)父子进程的执行次序
	
			a.对于fork函数之前的代码,父进程执行一次;
			b.对于fork函数之后的代码,父子进程各自执行一次;
			c.fork函数的返回值由父子进程各自返回一次;




		(3)父子进程之间的关系
		a.父进程启动了子进程,父子进程同时启动,如果子进程先于父进程结束,则会给
	  父进程发送信号,由父进程负责回首子进程资源。
		b.如果父进程先于子进程结束,则子进程变成孤儿进程,子进程会变父进程(一般
	  重新设置init(1)为新的父进程),inti进程收养了孤儿进程，所以叫做孤儿院。
		c.如果子进程先于父进程结束,但是父进程由于各种原因没有接收到子进程发来的
	  信号,也就没有回收子进程的资源,但是子进程已经结束了,因此子进程变成了僵尸进程;





		(4)父子进程之间的复制关系
			使用fork函数创建子进程后,子进程会复制父进程中除了代码区之外的
		  其他内存区域,而代码区和父进程共享;
			
			使用fork函数创建子进程后,子进程会复制父进程中的文件描述符总表,
		  但不会复制文件表结构,使得父子进程中的文件描述符对应同一个文件表结构;
		



		(5)扩展
			a.如何创建3个进程一共4个进程?
	
				fork();
				fork();

				4个进程：1个父进程+2个子进程+1个孙子进程
				/* 调用 n此fork() 一共2^n 个进程 */

			b.如何创建2个进程一共3个进程？
			
				pid = fork();
				if(pid > 0){
					fork(); // 只让父进程再调用fork函数
				}
				3个进程: 1个父进程+2个子进程

			c.俗称"fork炸弹"
				while(1){
				 	fork();	
				}




	练习:
		使用open函数创建一个文件a.txt,使用fork函数创建子进程,分别使用父进程和
	子进程向文件a.txt中分别写入数据“hello”和“world”,最后关闭文件

		vi 04fd.c





	3.2 进程的终止
		(1)正常终止进程的方式
		   	a.执行了main函数中的return语句;
			b.调用exit()函数进行终止;
			c.调用_exit()和_Exit()函数进行终止;
			d.最后一个线程返回;
			e.最后一个线程调用了pthread_exit()函数;


		(2)非正常终止进程的方式
			a.采用信号终止进程的执行;
			b.最后一个线程被其他线程取消;



		(3)终止进程相关函数的解析
		//_exit() _Exit()
       #include <unistd.h>
       void _exit(int status);	=> UC函数

       #include <stdlib.h>
       void _Exit(int status);	=> 标C函数

		函数功能：
			主要用于终止当前正在调用的进程;关闭所有属于当前进程的打开的文件描述符;
		  让该进程的所有子进程变更父进程为init进程;给父进程发送SIGCHLD 信号
		  帮其进行善后处理;
			参数status的数值被返回给当前进程的父进程作为当前进程的退出状态信息,
		  如果父进程收集该状态信息,则需要调用wait系列函数进行收集;

			函数_Exit() 和 函数_exit() 之间是等价关系;
		


		//exit()
       #include <stdlib.h>
       void exit(int status);

		函数功能：
  			主要用于引起正常进程的终止,参数status & 0377 之后的结果返回给父进程
		  作为该进程的退出状态信息,父进程可以使用wait系列的函数进行获取;
			该函数会自动调用所有由atexit()和on_exit()函数注册过的函数,该用法主要
		  用于进行/*善后处理*/;

			EXIT_SUCCESS and EXIT_FAILURE 作为函数exit的实参可以表示正常结束和
		  非正常结束程序的含义,但本质上就是0 和 -1；



		//atexit()
       #include <stdlib.h>
       int atexit(void (*function)(void));

		函数功能：
			主要用于注册参数指定的函数,该注册的函数会在正常进程终止时被调用,而正常
		  进程终止的方式有：调用exit()函数 和 执行main函数中的return;
			成功返回0 失败返回非0；
		

		//on_exit()

       #include <stdlib.h>
       int on_exit(void (*function)(int , void *), void *arg);


	1.3 进程的等待
		(1)wait 函数
			
       #include <sys/types.h>
       #include <sys/wait.h>
       pid_t wait(int *status);


		函数功能：
			主要用于挂起当前正在执行的进程知道有一个子进程终止为止;
		    当参数status不为空时,则将获取到的退出状态信息存放到该参数指定的
		  int类型存储空间中,为了正确的解析退出状态信息需要借助以下的宏定义:
					
	       WIFEXITED(*status) 	-当子进程正常终止时返回真,而子进程正常终止
		  		的方式有:  调用exit()/_exit()/执行了return语句；
		


		   WEXITSTATUS(*status)	-返回子进程的退出状态信息;

				成功返回终止子进程的进程号,失败返回-1


		(1)waitpid 函数

       #include <sys/types.h>
       #include <sys/wait.h>
       pid_t wait(int *status);
       pid_t waitpid(pid_t pid, int *status, int options);

		第一个参数：进程的编号(等待哪一个进程)
					< -1 表示等待任意一个进程组ID为pid绝对值的子进程(了解)
					= -1 表示等待任意一个子进程(重点)
					=  0 表示等待任意一个进程组ID为当前正在调用进程ID的子进程
						(了解)	
					>  0 表示等待进程号为pid的子进程(重点)

		第二个参数：指针变量,用于获取子进程的退出状态信息
		第三个参数：等待的方式,默认给0即可,表示阻塞的效果
					WNOHANG	   - 如果没有子进程退出则立即返回,不会等待

		返回值：如果使用阻塞的方式(第三个参数是 0 ) 成功返回子进程的进程号
				如果使用非阻塞方式(第三个参数是WNOHANG) 成功返回0
				失败都返回 -1；

		函数功能：
			主要用于等待参数指定的进程,并获取退出状态信息;

/*
			  waitpid(-1, &status, 0)	等价  wait(&status)   
*/




	作业：
		使用fork函数创建子进程，在子进程中申请一个int类型大小的动态内存，提示用户
	  输入半径,根据用户的输入计算周长并打印,要求当子进程终止时自动释放动态内存,
	  父进程等待子进程结束,并获取退出状态信息,打印出来;





























