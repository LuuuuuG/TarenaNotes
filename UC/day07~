/**************************************************************************/
*									   *		
*				day_07					   *	
*									   *
/**************************************************************************/






				/*文件的管理*/

	1. 文件管理	
	1.1 基本操作的相关函数
	    (1)lseek函数
			
       #include <sys/types.h>
       #include <unistd.h>

	   off_t lseek(int fd, off_t offset, int whence);

		第一个参数：文件描述符，open函数的返回值(调整那个文件)
		第二个参数：偏移量(调整多少字节);
					> 0		-向文件末尾方向偏移
					= 0		-表示不偏移
					< 0		-向文件开头方向偏移
			

		第三个参数：起始位置(从什么地方开始偏移)

			SEEK_SET	-文件开始位置
						-向后偏移合理,向前偏移不合理(极端情况不考虑)
			SEEK_CUR	-文件当前位置
			SEEK_END	-文件末尾位置
						-向前向后偏移都合理(特殊情况不考虑)
						

		返回值：
			成功返回当前位置距离文件开头位置的偏移量，
			失败返回(off_t)-1；
			
		函数功能：
			主要用于调整指定文件中的读写位置;


		注意：
			当把文件的读写位置调整到SEEK_END后面的位置再写入数据时,数据也是
		  可以写入的，只是中间有一块区域空闲,该现象叫做文件的空洞现象,该区域
		  会被计算到文件的大小中,但是没有有效数据,获取内容时得到的是'\0' ;


		扩展：
			如何获取一个文件的大小信息？？？
			a.使用fseek函数调整文件读写位置到末尾,使用ftell函数返回；
			b.使用lseek函数调整文件读写位置到末尾,返回值就是文件大小。



	1.2 标C和UC文件操作函数的比较

		


		练习：
			分别使用标C和UC的文件操作函数编写以下代码：

		a. vi 04fwrite.c, 将[1~10^6]之间的每一个整数写入到文件num.dat中； a.out
		b. vi 05write.c,将[1~10^6]之间的每一个整数写入到文件num2.dat中； b.out


		由程序的结果可知;标C的文件操作函数执行效率高于UC的文件操作函数,
		因为标C的文件操作函数内部提供了输入输出缓冲区,当数据积累到一定数量之后
		才去访问内核,才会将数据写入到文件中。
	
//time a.out
打开/创建文件成功
写入数据成功
成功关闭

real	0m0.058s  /*关注*/
user	0m0.044s
sys	0m0.012s

//time b.out
打开/创建文件成功
成功写入数据
成功关闭文件

real	0m1.584s	/*.*/
user	0m0.052s
sys	0m1.528s
day07$



		可以通过自定义缓冲区的方式来提高效率,但并不是缓冲区越大效率越高;





	1.3 文件描述符的工作原理(尽量理解)

		文件描述符本质上就是一个整数,可以代表一个打开的文件,但是文件的管理信息并不
	  是存放在文件描述符中,而是存放在/*文件表*/等数据结构中,使用open函数打开
	  文件时, 操作系统会将文件的相关信息加载到文件表等数据结构中,但是处于安全
	  和效率等因素的考虑,文件表等数据结构不适合直接操作,而是给文件表等结构指定
	  一个编号,使用编号来操作文件,该编号就是文件描述符；

	  	在每个进程的内部都有一张文件描述符总表，当有新的文件描述符需求时，
	会从文件描述符从表中查找最小的未被使用的文件描述符返回，文件描述符虽然是int
	类型，但是本质上是非负整数，也就是从0开始，其中0 1 2 已经被系统占用,分别代表
	标准输入，标准输出以及标准错误，因此一般从3开始使用，文件描述符的最大值可以
	到OPEN_MAX(当前教学环境是1024)

	    使用close函数关闭文件时,本质上就是将文件描述符和文件表等数据结构的对应关系
	从文件描述符总表中移除,不一定会删除文件表等数据结构,只有当文件表没有和任何
	其它文件描述符对应时(也就是一个文件表可以同时对应多个文件描述符)，才会删除
	文件表等数据结构,close函数也不会改变文件描述符本身的整数值,只是让该文件描述符
	无法代表一个文件而已；




	1.4 dup/dup2函数
       #include <unistd.h>

       int dup(int oldfd);
 		
		
		函数功能：
			主要用于实现对参数oldfd的复制,从文件描述符总表中查找最小的未被使用
			的文件描述符作为oldfd的副本,成功返回新的文件描述符,失败返回-1；

       int dup2(int oldfd, int newfd);
		
		函数功能：
			主要用于实现oldfd到newfd的复制,如果文件描述符newfd已经被其他文件占用
		  则先关闭在复制,成功返回新的文件描述符,失败返回-1；



		注意：
			复制文件描述符的本质就是复制文件描述符所对应的文件表地址信息，使得多个
		  文件描述符可以对应同一个文件,因此无论使用那个文件描述符都可以访问文件；

		

	作业：
		a. vi 09write_emp.c 文件 要求定义一个员工类型的结构体变量并且进行初始化,将该员工信息写入到文件emp.dat中，其中员工的信息主要有：员工的编号。员工的姓名，员工的薪水；
		b. vi 10read_emp.c 文件，要求读取emp.dat中员工信息，并打印出来；

		c.查询fcntl函数；

	



















