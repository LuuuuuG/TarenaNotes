/**************************************************************************/
*									   *		
*				day_02					   *	
*									   *
/**************************************************************************/


	一、预处理指令
	二、环境变量



			/*预处理指令*/

	1. 常用的预处理指令
	1.1 复习标C学过的预处理指令
	
		#include... 	包含指定的头文件
		#define...	进行宏定义
		#undef...	取消宏定义
		#if...		如果
		#ifndef...	如果没有定义
		#elif...	如果定义	/*特别注意*/
		#else...	否则如果
		#endif...	结束如果

	1.2 学习常用的预处理指令
		#line 整数
			=>主要用于降下一行的行号标记为第N行	
			=>主要用于调试程序的场合中


		#warning  字符串
			=> 在编译阶段产生警告信息
		#error  字符串
			=> 在编译阶段产生错误信息
			=> 主要用于调试程序的场合中


	  注意:
		if 与 #if 的区别
		1)#if  -预处理指令,也就是在预编译阶段进行条件的判断
		2)if   -条件分支结构，也就是在运行阶段进行条件的判断

		
		#pragma	   GCC  dependency 文件名

		=> 主要用于关联两个文件的时间,如果指定文件名的最后一次修改时间晚于
		   当前文件,则产生/*警告信息*/仍然会生成可执行文件 

****************
// *pragma GCC dependency 的使用
#include<stdio.h>
//当前文件依赖于02lin.c
#pragma  GCC dependency  "01line.c"
int main(){
    printf("指定的文件有没有发生改动呢？？\n");
    return 0;
}
*****************
 



		/*ls -l 查看当前目录下文件最后修改时间*/

		#pragma  GCC    poison 	标识符

		=> 主要用于将后面指定的标识符设置成毒药，一旦使用则//报错！
			不能生成可执行文件。


***************
// #pragma  GCC  poison的使用

#include <stdio.h>
//采用宏定义进行瞒天过海
#define GOTO goto
//设置goto为毒药
#pragma GCC poison  goto
int main(){
    ok:         //标识符
        sleep(1);   //睡一秒~~~
        printf("I am strong !\n");
    GOTO ok; 
    return 0;
}
********************


		#pragma	pack(整数n) //n必须是2的整数次方
	
		=>主要用于设置结构题的对齐和补齐方式
		=>结构体的对齐和补齐方式就是为了存取数据方便,从而提高效率
		  但是这样会浪费内存空间,使用该指令可以节省内存。
			
****************
//#pragma pack(整数n)
#include<stdio.h>
//按照2的倍数进行对齐和补齐
//#pragma pack(2) //8
//#pragma pack(1) //6
//#pragma pack(3) //error 默认按照4进行对齐和补齐
//#pragma pack(4) //默认情况
//#pragma pack(8) //超过按照4计算

int main(){
    struct S{
        char c1; 
        int i;
        char c2; 
    };  
    printf("sizeof(struct S) = %d\n",sizeof(struct S));
    return 0;
}
****************


	1.3 常见的预定义宏

	    __FILE__	主要用于获取当前文件的文件名信息	%s
	    __LINE__	主要用于获取当前宏所在的行号信息	%d
	    __TIME__	主要用于获取当前宏所在文件的最后一次编译时间 	%s
	    __DATE__	主要用于获取当前宏所在文件的最后一次编译日期	%s
		...

*****************
//预定义宏
#include <stdio.h>

int main(){
    printf("%s\n",__FILE__);	//07hong.c
    printf("%d\n",__LINE__);	//6
    printf("%s\n",__TIME__);	//19:36:50
    printf("%s\n",__DATE__);	//Apr  7 2016

    return 0;
}
*******************








			
				/*环境变量*/




	2 环境变量的概念和使用
	2.1 基本概念
	    
	    环境变量一般指在操作系统中用来指定操作系统运行环境的一些参数信息,也就是用于存放和系统/软件环境相关信息的特殊变量;
	
	Path/PATH 本质上就是一种环境变量,可以存放可执行文件的路径信息,而一旦放入可执行文件的路径信息之后,就可以直接通过可执行文件的名称来启动该程序,而不再需要增加路径信息;


	2.2 配置方法
	    (1) Windows Xp系统的配置方法：
		 我的电脑 => 右击,选择属性 => 高级 => 环境变量 => 系统变量 
		 => 找到Path点击编辑 => 在Path变量值的最后增加分号,再增加新路径 
		 其中分号是不同路径之间的分隔符，切记不要删除Path变量原来的内容；
		
	    (2) Linux系统中的配置方法：
		  打开任意一个终端执行以下指令：
			1. export PATH=$PATH:.
	          $PATH  -表示获取PATH变量原来的变量值的内容
	             .   -表示当前目录,也就是a.out的路径信息
	     	执行上述指令之后就可以省略路径信息直接通过a.out来执行该文件。

		上面配置方法只对当前终端有效,为了使得环境变量的配置对后续打开的
		终端都有效,则按照一下步骤操作:
			1. vi ~/.bashrc 文件，在文件的最后增加指令:
			2. export PATH=$PATH:.
			3. 在vi中 source ~/.bashrc使得配置文件立即生效。		
	/*	~ 	-表示主目录
		.xxx 	-表示隐藏文件		*/
		



	2.3 编程相关的常用环境变量
	    CPATH/C_INCLUDE_PATH	主要用于存放c语言头文件的路径信息
	    CPLUS_INCLUDE_PATH		主要用于存放c++语言头文件的路径信息
	    LIBRARY_PATH		主要用于存放库文件的路径信息,解决编译链接时找不到库文件的问题，	
	    LD_LIBRARY_PATH		主要用于存放共享库文件的路径信息,解决运行时找不到库文件的问题



//	【练习】

		创建目录add，在目录add中编写一下三个文件：
	add.h	-声明一个计算两个int类型参数和并返回的函数,函数名为add_int
	add.c	-定义上述函数；
	main.c	-调用add_int函数，参数直接手动指定即可，不同输入，并将计算结果打印出来。



	2.4 头文件的查找方式

	    (1) #include<> 
		-表示从系统默认的路径中查找该文件
		-当前系统中默认的路径是:/usr/include
		-使用命令whereis stdio.h来查找该头文件的位置

	    (2) #include"" 
		-表示优先从当前工作目录中进行查找,查找不到时也会去系统
		  默认的路径中进行查找
	
	    (3) 配置环境变量CPATH/C_INCLUDE_PATH
		export CPATH=$CPATH:..(头文件所在的路径信息)	
	
    /*BEST*/(4) 通过编译选项来指定头文件的路径信息
		gcc/cc   xxx.c -I 头文件的路径
		//e.g.  gcc/cc *.c -I ..



	NOTICE：
		方式(1)(2)的缺点在于:一旦头文件的路径发生了改变,
		则必须修改源代码才能解决该问题;

		方式(3)的缺点在于:当多个项目被创建时，
		配置环境变量可能会引发冲突问题
		
		方式(4)及不需要修改源代码,也不会引起多个项目之间的冲突,
		因此推荐使用该方法。		
			
 


************************
	作业：
		(1)编程打印常见的预定义宏;
		(2)(扩展)使用标C中文件操作函数实现学生信息管理系统;
			增删改查操作必须在文件内部操作

		删 将后面人员的信息向前移动覆盖,最后一个人的信息使用
		truncate 处理


	明日预报:
		(1)库文件的概念和使用
		(2)C语言中的错误处理







