/**************************************************************************/
*															    		  *	
*								day_14					   				  *	
*									   									  *
/**************************************************************************/


		
	
	1. 使用信号量集实现进程间的通信
	1.1 基本概念
	  (1) 什么是信号量？？？
		信号量本质就是一种计数器,主要用于控制同时访问同一种共享资源的进程/线程个数;
	
	  (2) 什么是信号量集？？？
		信号量集本质就是信号量的集合,主要用于控制多种共享资源分别同时被访问的
	  进程/线程个数。



	1.2 信号量的工作方式
		(1)初始化信号量为最大值
		(2)如果有进程申请到了一个共享资源,则信号量的数值减1;
		(3)当信号量的数值为0时,申请共i轩昂资源的进程进入阻塞状态;
		(4)如果有进程释放了一个共享资源,则信号量的数值加1；
		(5)当信号量的数值 >0 时,等待申请共享资源的进程可以继续抢占共享资源,抢不到
		  共享资源的进程继续阻塞；
	



	1.3 使用信号量集实现进程间通信的模型
		(1)获取key值,		ftok
		(2)创建/获取信号量集 semget
		(3)初始化			semctl
		(4)操作信号量集控制进程/线程个数 semop
		(5)如过不再使用则删除 semctl


	1.4 相关函数的解析
		(1)semget函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>
       int semget(key_t key, int nsems, int semflg);

		第一个参数：key值,ftok函数的返回值
		第二个参数：信号量集的大小,也就是信号量的个数
			0 	-获取已经存在的信号量集
		地三个参数：具体的操作标志
			IPC_CREAT	-如果不存在则创建,存在则打开 	
			IPC_EXCL	-与IPC_CREAT搭配使用，若存在则创建失败
			0			-获取已经存在的信号量集

		返回值：成功返回信号量集的ID,失败返回-1；
		
		函数功能：
			主要用于创建/获取信号量集；

		注意：
			当创建新的信号量集时,需要指定权限信息,如：0664,
		  指定的方式为按位或在第三个参数中；


		(2)semctl函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>
       int semctl(int semid, int semnum, int cmd, ...);


		第一个参数：信号量集的ID,semget函数的返回值;
		第二个参数：信号量集的下标,从0开始
		第三个参数：具体的操作命令
/*
			IPC_RMID 	-删除整个信号量集,忽略sumnum,不需要第四个参数；
			SETVAL	-使用第四个参数的值来初始化下标为semnum的信号量
*/
		第四个参数：可边长参数,是否需要取决于cmd

		函数功能：
			主要用于对之i的那个的信号量集执行指定的操作；



		(3)semop函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>
       int semop(int semid, struct sembuf *sops, unsigned nsops);

		第一个参数：信号量集的ID,semget函数的返回值
		第二个参数：结构体指针,可以指向结构体变量,也可以指向数组
			struct sembuf{
	           unsigned short sem_num;  /* semaphore number(下标) */
	           short          sem_op;   /* semaphore operation(正增负减0不变)*/
	           short          sem_flg;  /* operation flags(默认给0) */				
			}

		第三个参数：当结构体指针指向数组时,该参数表示数组元素个数；

		函数功能：
			主要用于操作指定的信号量;
/*
		ipcs	-s		表示查看西哦他那个中已经存在的信号量集
		ipcrm -s semid	 表示删除指定的信号量集
		ipcs	-a 表示查看系统中所有ipc结构,包括共享内存,消息队列,信号量集；

*/




	2. 综合小项目
	2.1 项目的名称
		银行账户管理系统(模拟ATM)

	2.2 项目的功能
 		开户、销户、存款、取款、查询、转帐、

	2.3 项目的架构
		采用C/S架构进行设计(Client客户端/Server服务器)
		
	  	客户端： 提供界面让用户选择具体的业务,将用户选择的业务编号发送给服务器
				 进行处理,等待服务器的处理结果并现实给客户;
				 
		服务器：根据客户端传来的业务编号,通过访问数据库的方式进行处理,并将最终的
				处理结果发送给客户端即可；

	2.4 项目的设计和分析
		(1)如何实现客户端和服务器之间的通信呢？？？
			采用两个消息队列实现进程间的通信;
				消息队列一：	客户端 => 服务器
				消息队列二： 服务器 => 客户端
		
		(2)如何区分不同的业务编号呢？？？
			采用消息的类型来区分不同的业务编号,需要8中类型：
				6 种业务编号 + 成功 + 失败               

		(3)如何设计账户和消息的数据类型呢？？？
			账户信息：帐号、账户名称、账户密码、余额；
			采用结构体类型来设计账户和消息的数据类型；
			使用账户信息的结构体变量作为消息的数据内容；

		(4)以开户为例 分析项目的执行流程

			客户端：
				a.绘制字符界面,供用户选择具体的业务编号; 
					=> printf函数打印
				b.根据用户的选择,进入不同的业务分支进行处理
					=> 使用scanf 接收输入，使用switch-case结构进入不同的分支；
				c.提示用户输入开户的信息(不需要输账号信息)
					=> 使用结构体变量来保存用户的输入
				d.打包用户输入的信息到消息的结构体变量中,发送给服务器
					=> 设置消息的类型为1,代表开户业务
					=> 使用smgsnd函数将消息发送到消息队列一中
				e.接收消息队列二中的消息,并显示处理结果；
					=> 使用msgrcv函数接收消息
					=> 如果消息的类型为7,则表示处理成功
					=> 如果消息的类型为8,则表示处理失败

			服务器：
				a.创建两个消息队列,作为服务器的初始化工作
					=> 使用ftok函数生成ey值,msgget函数创建；
				b.接收客户端发来的消息,根据业务编号进行处理;
					=> 使用msgrcv函数接收消息队列一中的消息
					=> 判断消息类型是否为1,若是 则表示开户业务
				c.自动生成一个帐号补充完整客户账户信息;
					=> 调用generator_id函数自动生成帐号
				d.保存账户信息到文件中,并判断是否保存成功：
					=> 每个账户信息都保存在一个独立的文件中
					=> 采用帐号作为文件名来确保唯一性,使用sprintf函数

				e.根据处理结果修改消息的类型,并发送给客户端
					=> 如果处理成功,则修改消息的类型为7
						       失败                 8
					=> 使用msgsnd函数将消息发送到消息队列二中
				f.要求服务器不断的运行,知道按下ctrl+c才能关闭服务器;
					=> 使用无限循环保证服务器不停的工作
					=> 使用signal函数对信号SIGINT(2)进行自定义处理
					=> 通过信号处理机制来删除两个消息队列,使用msgctl函数
				


	2.5 项目要求
		(1)要求采用多函数多文件的防护死编码,并支持Ｍakefile文件
		(2)要求实现开户功能即可,有与里的同学实现所有功能；


	2.6 项目的提示
		vi bank.h	-编写结构体的定义等公共代码
		vi client.c	-编写客户端的功能代码,打印界面的函数等
		vi server.c -编写服务器的功能代码,创建消息队列的函数等
		vi dao.c	-编写自动生成帐号的函数代码等
		... ...			


























