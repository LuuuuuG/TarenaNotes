/**************************************************************************/
*															              *	*							  day_01	                                  *	
*									                                      *
/**************************************************************************/


	1. 课程简介
	1.1 Unix/Linux系统下的基本命令
	    => 主要学习常用的基本命令 以及vi的基本操作
	    => 依赖于Unix/Linux系统，部分命令和windows系统相同

	    标准C语言
	   => C语言的基本语法知识;
	   => 不依赖与具体的操作系统，支持Unix/Linux/Windows系统

	    数据结构和算法
	  => 主要学习常见数据结构的特性以及常用的算法,理解思想
	  => 不依赖于具体的操作系统,支持Unix/Linux/Windows系统
	  => 不依赖于具体的变成语言,支持C/C++/...

	    Unix/Linux系统下的高级C编程
	  => 主要学习操作系统提供的API函数以及操作系统的部分原理;
	  => 依赖于具体的操作系统,支持Unix/Linux系统;
	  => 主要使用C语言进行编程
	  => 理论时间: 15 天

		目前主流的主机操作系统:Unix/Linux/windows系列
	    		windows系列:Xp系统、vista、win7、win8、win10

		目前主流的主机操作系统:Android/IOS/Windows phone

		

	1.2 UC课程简介

	    (1)Unix/Linux系统的概述以及编程基础;
	    (2)Unix/Linux系统的内存管理技术
	    (3)Unix/Linux系统下的文件管理以及目录操作;
	    (4)Unix/Linux系统下的进程管理技术;
	    (5)Unix/Linux系统下的信号处理技术;
	    (6)Unix/Linux系统下的进程间通信技术;
	    (7)Unix/Linux系统下的网络编程技术;
	    (8)Unix/Linux系统下的多线程开发技术;


**************************************************


	

	1. Unix和Linux系统简介
	1.1 Unix系统的简介
	    在1969年左右，编写操作系统使用汇编语言,在编写和维护时都非常不方便。
	贝尔实验室汤普逊研发了一们语言,叫做B语言,后期由丹尼斯-李奇做了修改和扩展,命名为 Nwe B语言,后来改名为C语言;
	    C语言诞生于1972年，至今在编程语言排行榜上占据重要的地位。
	    Unix系统诞生于1970年,具有支持多用户多任务以及多种处理器的特性;

	1.2 Linux系统的简介

		Linux系统是一款自由免费开放源代码的类 Unix操作系统;

		当前教学环境: ubuntu 12.04  32位操作系统

		ubuntu系统每半年(4月 10月)发布一个新版本;

		



	2. gcc编译器的使用
	2.1 基本概念
		gcc原名叫做GNU C Compiler(编译器),支持对C语言的编译链接，
	后来对编译器进行了扩展,支持了更多的编程语言,如C++、Object-c等，
	改名为 GNU Compiler Collection.

	2.2 基本功能
		目前主流的编程基本上都是使用高级语言进行,如C语言,
	但是高级语言编写的程序无法被计算机直接执行,需要先翻译成汇编语言,
	再翻译成机器指令,最后被计算机执行。
		
		为了实现高级语言代码到机器指令的翻译,
		则需要使用gcc编译器进行编译链接,而生成的过程主要分成以下四步:
	
		(1) 预编译/预处理
			-主要用于实现头文件的扩展以及宏替换;
			gcc -E 01hello.c -o 01hello.i
			//生成 01hello.i
		(2) 编译	
			-主要用于将高级语言代码翻译成汇编语言,得到汇编文件;
			gcc -S 01hello.i/01hello.c 
			//生成 01hello.s
		(3) 汇编
			-主要用于将汇编语言翻译成机器语言指令,得到目标文件;
			gcc -c 01hello.s/01hello.i/01hello.c
			//生成 01hello.o
		(4) 链接
			-主要将目标文件和库文件进行链接,得到可执行文件	
			gcc 01hello.o/01hello.s/01hello.i/01hello.c
			//生成a.out 可执行文件


【练习】
		
	cc -E 01hello.c -o 01hello.i
	cc -S 01hello.i/01hello.c
	cc -c 01hello.s/01hello.i/01hello.c
	cc 01hello.o/01hello.s/01hello.i/01hello.c



	2.3 常用的编译选项
	    (1)熟练掌握的选项
		gcc/cc -E 预处理,默认输出到屏幕,可以使用-o来指定输入文件(xxx.i)
		gcc/cc -S 编译,将高级语言文件翻译成汇编语言文件(xxx.s)
		gcc/cc -c 汇编,将汇编语言文件翻译成机器语言文件(xxx.o)
		gcc/cc 编译链接,默认生成a.out的可执行文件

	    (2)熟悉的选项
		gcc/cc -std 	指定执行的C标准(C89 C99)
		gcc/cc -v   	查看gcc的版本信息
		gcc/cc -Wall	尽可能显示所有的警告信息(Warning all)
		gcc/cc -Werror	将警告当作错误来处理 
				(Warning error)		

	    (3)了解选项
		gcc/cc -g	生成调试信息,可以进行GDB调试
		gcc/cc -x	显示指定源代码的编程语言		
		gcc/cc -O	对代码进行优化处理

	    (4)扩展的选项
		man  命令/函数/gcc -查看相关的命令/函数/gcc编译器




	2.4 常见的编程相关的文件后缀

		.h	-头文件
		.c	-源文件
		.i	-预处理文件
		.s	-汇编文件
		.o	-目标文件
		.a	-静态库文件
		.so	-共享库文件


	3. 多文件结构的编程
	3.1 多文件结构的主要组成
		.h	头文件,主要存放结构题的定义、函数的声明等
		.c	源文件,主要存放函数的定义等
		.a	静态库文件,主要对功能函数的打包
		.so	共享库文件,主要对功能函数的打包

	3.2 头文件的详细组成(重点)
	    (1)头文件的卫士
		#ifndef _xxx_H
		#define _xxx_H
		...
		#endif //_xxx_H

	    (2)包含其他头文件
		#include<stdio.h>
		...

	    (3)进行宏定义
		#define  PI  3.14

	    (4)进行结构题的定义以及对数据类型起别名
		typedef struct node{
			int data;
			struct node* next;
		}Node;

	    (5)外部变量和函数的声明
		exter int num;
		void show(void);
	    

*****************************

	作业:
		(1)创建目录circle,在circle目录中编写以下3个文件

		circle.h -声明计算圆形周长和面积的函数,函数分别为:
			circle_length 和 circle_area;
		circle.c -定义原型周长和面积的函数;
		main.c	 -定义main函数,调用计算周长和面积的函数,其中半径由用户手动输入；	







/**************************************************************************/
*									   *		
*				day_02					   *	
*									   *
/**************************************************************************/


	一、预处理指令
	二、环境变量



			/*预处理指令*/

	1. 常用的预处理指令
	1.1 复习标C学过的预处理指令
	
		#include... 	包含指定的头文件
		#define...	进行宏定义
		#undef...	取消宏定义
		#if...		如果
		#ifndef...	如果没有定义
		#elif...	如果定义	/*特别注意*/
		#else...	否则如果
		#endif...	结束如果

	1.2 学习常用的预处理指令
		#line 整数
			=>主要用于降下一行的行号标记为第N行	
			=>主要用于调试程序的场合中


		#warning  字符串
			=> 在编译阶段产生警告信息
		#error  字符串
			=> 在编译阶段产生错误信息
			=> 主要用于调试程序的场合中


	  注意:
		if 与 #if 的区别
		1)#if  -预处理指令,也就是在预编译阶段进行条件的判断
		2)if   -条件分支结构，也就是在运行阶段进行条件的判断

		
		#pragma	   GCC  dependency 文件名

		=> 主要用于关联两个文件的时间,如果指定文件名的最后一次修改时间晚于
		   当前文件,则产生/*警告信息*/仍然会生成可执行文件 

****************
// *pragma GCC dependency 的使用
#include<stdio.h>
//当前文件依赖于02lin.c
#pragma  GCC dependency  "01line.c"
int main(){
    printf("指定的文件有没有发生改动呢？？\n");
    return 0;
}
*****************
 



		/*ls -l 查看当前目录下文件最后修改时间*/

		#pragma  GCC    poison 	标识符

		=> 主要用于将后面指定的标识符设置成毒药，一旦使用则//报错！
			不能生成可执行文件。


***************
// #pragma  GCC  poison的使用

#include <stdio.h>
//采用宏定义进行瞒天过海
#define GOTO goto
//设置goto为毒药
#pragma GCC poison  goto
int main(){
    ok:         //标识符
        sleep(1);   //睡一秒~~~
        printf("I am strong !\n");
    GOTO ok; 
    return 0;
}
********************


		#pragma	pack(整数n) //n必须是2的整数次方
	
		=>主要用于设置结构题的对齐和补齐方式
		=>结构体的对齐和补齐方式就是为了存取数据方便,从而提高效率
		  但是这样会浪费内存空间,使用该指令可以节省内存。
			
****************
//#pragma pack(整数n)
#include<stdio.h>
//按照2的倍数进行对齐和补齐
//#pragma pack(2) //8
//#pragma pack(1) //6
//#pragma pack(3) //error 默认按照4进行对齐和补齐
//#pragma pack(4) //默认情况
//#pragma pack(8) //超过按照4计算

int main(){
    struct S{
        char c1; 
        int i;
        char c2; 
    };  
    printf("sizeof(struct S) = %d\n",sizeof(struct S));
    return 0;
}
****************


	1.3 常见的预定义宏

	    __FILE__	主要用于获取当前文件的文件名信息	%s
	    __LINE__	主要用于获取当前宏所在的行号信息	%d
	    __TIME__	主要用于获取当前宏所在文件的最后一次编译时间 	%s
	    __DATE__	主要用于获取当前宏所在文件的最后一次编译日期	%s
		...

*****************
//预定义宏
#include <stdio.h>

int main(){
    printf("%s\n",__FILE__);	//07hong.c
    printf("%d\n",__LINE__);	//6
    printf("%s\n",__TIME__);	//19:36:50
    printf("%s\n",__DATE__);	//Apr  7 2016

    return 0;
}
*******************








			
				/*环境变量*/




	2 环境变量的概念和使用
	2.1 基本概念
	    
	    环境变量一般指在操作系统中用来指定操作系统运行环境的一些参数信息,也就是用于存放和系统/软件环境相关信息的特殊变量;
	
	Path/PATH 本质上就是一种环境变量,可以存放可执行文件的路径信息,而一旦放入可执行文件的路径信息之后,就可以直接通过可执行文件的名称来启动该程序,而不再需要增加路径信息;


	2.2 配置方法
	    (1) Windows Xp系统的配置方法：
		 我的电脑 => 右击,选择属性 => 高级 => 环境变量 => 系统变量 
		 => 找到Path点击编辑 => 在Path变量值的最后增加分号,再增加新路径 
		 其中分号是不同路径之间的分隔符，切记不要删除Path变量原来的内容；
		
	    (2) Linux系统中的配置方法：
		  打开任意一个终端执行以下指令：
			1. export PATH=$PATH:.
	          $PATH  -表示获取PATH变量原来的变量值的内容
	             .   -表示当前目录,也就是a.out的路径信息
	     	执行上述指令之后就可以省略路径信息直接通过a.out来执行该文件。

		上面配置方法只对当前终端有效,为了使得环境变量的配置对后续打开的
		终端都有效,则按照一下步骤操作:
			1. vi ~/.bashrc 文件，在文件的最后增加指令:
			2. export PATH=$PATH:.
			3. 在vi中 source ~/.bashrc使得配置文件立即生效。		
	/*	~ 	-表示主目录
		.xxx 	-表示隐藏文件		*/
		



	2.3 编程相关的常用环境变量
	    CPATH/C_INCLUDE_PATH	主要用于存放c语言头文件的路径信息
	    CPLUS_INCLUDE_PATH		主要用于存放c++语言头文件的路径信息
	    LIBRARY_PATH		主要用于存放库文件的路径信息,解决编译链接时找不到库文件的问题，	
	    LD_LIBRARY_PATH		主要用于存放共享库文件的路径信息,解决运行时找不到库文件的问题



//	【练习】

		创建目录add，在目录add中编写一下三个文件：
	add.h	-声明一个计算两个int类型参数和并返回的函数,函数名为add_int
	add.c	-定义上述函数；
	main.c	-调用add_int函数，参数直接手动指定即可，不同输入，并将计算结果打印出来。



	2.4 头文件的查找方式

	    (1) #include<> 
		-表示从系统默认的路径中查找该文件
		-当前系统中默认的路径是:/usr/include
		-使用命令whereis stdio.h来查找该头文件的位置

	    (2) #include"" 
		-表示优先从当前工作目录中进行查找,查找不到时也会去系统
		  默认的路径中进行查找
	
	    (3) 配置环境变量CPATH/C_INCLUDE_PATH
		export CPATH=$CPATH:..(头文件所在的路径信息)	
	
    /*BEST*/(4) 通过编译选项来指定头文件的路径信息
		gcc/cc   xxx.c -I 头文件的路径
		//e.g.  gcc/cc *.c -I ..



	NOTICE：
		方式(1)(2)的缺点在于:一旦头文件的路径发生了改变,
		则必须修改源代码才能解决该问题;

		方式(3)的缺点在于:当多个项目被创建时，
		配置环境变量可能会引发冲突问题
		
		方式(4)及不需要修改源代码,也不会引起多个项目之间的冲突,
		因此推荐使用该方法。		
			
 


************************
	作业：
		(1)编程打印常见的预定义宏;
		(2)(扩展)使用标C中文件操作函数实现学生信息管理系统;
			增删改查操作必须在文件内部操作

		删 将后面人员的信息向前移动覆盖,最后一个人的信息使用
		truncate 处理


	明日预报:
		(1)库文件的概念和使用
		(2)C语言中的错误处理






/**************************************************************************/
*									   *		
*				day_03					   *	
*									   *
/**************************************************************************/



	一、库文件
	二、C语言中的错误处理


				/*库文件*/

	1. 库文件的概念和使用

	    在大型项目中,如果每个功能函数都放在独立的.o文件中,
	  则项目的管理是灾难性的问题,因此需要采用库文件来解决该问题;    
	    一般来说,可以按照功能模块将若干个.o文件打包成一个或者多个库文件,
	  编写者只需要提供库文件和头文件即可;

	库文件主要分为两大类:静态库文件(.a) 和 共享库文件(.so)

	1.1 静态库的基本概念和特性
	    (1)基本概念
		静态库本质上就是由若干个.o文件打包生成的.a文件;

		链接静态库的本质就是将被调用的代码指令复制到调用模块中,
		体现在最终的可执行文件中;

	    (2)基本特性

		a.静态库占用空间比较大,库中的代码一旦修改则必须重新链接;
		b.使用静态库的代码在运行可执行文件时可以脱离静态库,
		  并且执行的效率比较高;
		





/*printf 的函数声明在stdio.h里面
	它的定义源代码在哪?    

使用命令 ldd a.out 查看		
	linux-gate.so.1 =>  (0xb7706000)
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb754b000)
	/lib/ld-linux.so.2 (0xb7707000)

	由上可知printf函数的定义被打包在上面.so的共享库中了~~~
	运行自动链接共享库 生成a.out
*/

使用cc -static 01static.c -o b.out 强制链接静态库生成可执行文件b.out
0使用ls -l *.out 对比a.out和b.out的文件大小
-rwxrwxr-x 1 tarena tarena   7202  4月  8 09:59 a.out
-rwxrwxr-x 1 tarena tarena 743664  4月  8 10:06 b.out
	
	显然静态库生成的可执行文件b.out 占用内存空间更大！

	NOTE：gcc/cc -static xxx.c 表示强制要求链接静态库
	      ldd a.out 表示查看a.out所链接的共享库信息




	1.2 静态库的生成和调用步骤
		
	    (1)生成步骤
		a.编写源代码文件xxx.c,如: vi add.c
		b.只编译不链接生成目标文件xxx.o,如:
			cc -c add.c
		c.生成静态库文件
		  ar -r/*插入，若存在则更新*/ lib库名.a 目标文件
 	   //e.g. ar -r libadd.a add.o

	NOTE:
		其中libadd.a 叫做//静态库文件名
		其中去掉lib和.a之后剩下的add叫做//库名		
		

	    (2)调用步骤
		a.编写测试源代码文件xxx.c,如：vi main.c
		b.只编译不链接生成目标文件xxx.o,如：
			cc -c main.c
		c.链接静态库文件,链接的方式有以下三种：
		  1)直接链接
			cc 目标文件 静态库文件名
		//e.g.  cc main.c libadd.a

		  2)使用编译选项进行链接
			cc 目标文件 -l 库名 -L 库文件所在的路径
		//e.g.  cc main.o -l add -L .

		  3)配置环境变量LIBRARY_PATH
			export LIBRARY_PATH=$LIBRARY_PATH:.
		//e.g.  export LIBRARY_PATH=$LIBRARY_PATH:.
		//	cc main.o -l add


	练习:
		用上面三种方法生成静态库文件



	1.3 共享库文件的基本概念和特征
	    (1) 基本概念
		共享库本质就是由若干个目标文件(.o)打包生成的.so文件
		
		链接共享库和静态库最大的不同就是,链接共享库时并不需要将
	    被调用的代码指令复制到调用模块中,而仅仅是将被调用的代码指令在
	    共享库中的相对地址嵌入到调用模块中;	

	    (2)基本特性
		a.共享库占用空间比较小,即使修改了库中的代码,
	    只要接口保持不变,则不需要重新链接;
		b.使用共享库的代码在运行是需要以来共享库,执行效率相对比较低;
		
		目前主流的商业开发中大多数采用共享库;

	1.4 共享库的生成和调用步骤
		
	    (1)生成步骤
		a.编写源代码文件xxx.c,如：vi add.c
		b.只编译不链接生成目标文件xxx.o,如:
			cc -c -fpic/*生成位置无关码 小模式*/ add.c
		
		c.生成共享库文件
			cc -shared 目标文件 -o lib库名.so
		//e.g.  cc -shared add.o  -o libadd.so	



/*
ls -l libadd.so
-rwxrwxr-x 1 tarena tarena 6754  4月  8 11:58 libadd.so

-表示文件
r读权限
w写权限
x运行权限

ls -l libadd.a
-rw-rw-r-- 1 tarena tarena 2042  4月  8 14:04 libadd.a

*/
	
	    (2)调用步骤

		a.编写测试源代码文件xxx.c,如：vi main.c
		b.只编译不链接生成目标文件xxx.o,如：
			cc -c main.c
		c.链接共享库文件,链接的方式有以下三种：
		  1)直接链接
			cc 目标文件 共享库文件名
		//e.g.  cc main.c libadd.so
0
		  2)使用编译选项进行链接
			cc 目标文件 -l 库名 -L 库文件所在的路径
		//e.g.  cc main.o -l add -L .

		  3)配置环境变量LIBRARY_PATH
			export LIBRARY_PATH=$LIBRARY_PATH:.
		//e.g.  export LIBRARY_PATH=$LIBRARY_PATH:.
		//	cc main.o -l add


	NOTE：
		1)在使用共享库文件时,需要配置环境变量LD_LIBRARY_PATH来解决运行时
	    找不到库文件的问题,具体的配置方法如下:
	//	export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
	
		2)当共享库文件和静态库文件同时在一个目录下，并且库名相同时，
	    采用上述第二种或者第三种链接方式进行链接时,编译器会有限选择共享库
	    进行链接,如果希望链接静态库则使用-static 选项进行要求;

		/* gcc/cc -static xxx.c 表示强制要求链接静态库 */
		



	1.5 共享库的动态加载
		#include <dlfcn.h>
		Link with -ldl.
	    (1) dlopen函数

		void *dlopen(const char *filename, int flag);
	
		第一个参数: 字符串形式的共享库文件名
		第二个参数: 具体的操作标志,加载方式
		    RTLD_LAZY  	-延迟加载
		    RTLD_NOW	-立即加载
		返回值:成功返回一个句柄(地址)信息,失败返回 NULL;            

	    函数功能:
		主要用于将参数filename指定的共享库文件加载到内存中;


	    (2) dlsym 函数

		void *dlsym(void *handle, const char *symbol);

		第一个参数:具体的句柄信息,也就是dlopen函数的返回值
		第二个参数:字符串形式的符号名,这里指函数名

		返回值:成功返回函数的地址,失败返回 NULL;

		函数功能:
		    主要用于查找handle指向共享库中名字为symbol的函数在内存中的
		    地址信息;

		
	    (3) dlclose 函数

		 int dlclose(void *handle);

		函数功能:
		    主要用于关闭/写在参数指定的共享库,参数为dlopen函数的返回值,
		  成功返回0，失败返回非0；
	
	    (4) dlerror 函数
		
		char *dlerror(void);

		函数功能:
		    主要用于获取调用dlopen()/dlsym()/dlclose()函数之后产生的错误
		信息并返回,如果上述函数没有产生错误,则返回 NULL;



***************************
	作业:
	     自定义两个函数,分别打印空心菱形和实心菱形，放在同一个.c文件中,
	将该文件分别打包成静态库文件和共享库文件使用main.c文件进行调用,
	最后使用动态加载方式进行加载
       *                     *
      * *                   ***
     *   *                 *****
      * *                   ***
       *                     *




      12345                 12345
1       *                     *		1
2      * *                   ***	2
3     *   *                 *****	3
4      * *                   ***	4	
5       *                     *		5






/**************************************************************************/
*									   *		
*				day_04					   *	
*									   *
/**************************************************************************/


	一、C语言中的错误处理
	二、环境标的概念和使用
	三、内存管理技术


	
			/*C语言中的错误处理*/
			
	1. C语言中的错误处理:			
   	    如:
		int main(){
		    if(...){
			return -1; //表示程序出错结束
		    }
		    return 0;  //表示程序正常结束
		}				
		
	1.1 C语言中的错误表现形式(错了么？)
	    一般来说,C语言中都是通过函数的返回值来表示该函数调用是否出错,
  	  而返回值的一般表现形式如下:
		(1) 对于返回值类型是/*int类型*/的函数,并且函数的计算结果
	  	不可能是负数时,一般使用返回 -1 表示出错,其他数据表示正常结束。

		(2) 对于返回值是/*int类型*/的函数,但是函数的计算结果可能是负数时，
		使用指针作为函数的形参类型,将函数的计算结果带出去,而函数的返回值
		专门用于表示是否出错,习惯上使用 0 表示正常结束,使用 -1 表示出错;

		(3) 对于返回值类型是/*指针*/的函数来说,一般使用返回 NULL 表示函数出错
		其他数据表示正常结束;

		(4) 对于不考虑是否出错的函数来说,返回值类型用 void 即可;



	[练习]
		按照上述4个规则,编写以下4个功能函数,
	    a.生成1~10 之间随机数并返回,如果随机数是5则返回错误;
	    b.比较两个int类型参数的大小并返回最大值,如果相等则返回错误;
	    c.判断传入的字符串是否为"error" 如果是则返回错误,否则返回"ok"
	    d.打印传入的字符串即可;


	1.2 错误编号(为什么错了？)

	    判断函数是否调用失败,根据函数的返回值进行判断;
	    当函数一旦调用失败时,希望知道失败的原因则查看errno的值，
	    errno本质就是一个int类型的全局变量,当/*库函数调用出错时*/,
	    会自动设置errno的值来表示错误的原因;
		#include <errno.h> -实现了对errno外部变量的声明,并且包含了一些
		其他头文件,里面拥有errno的取值范围等信息。

/*
		   /etc/passwd -主要包含了账户的管理信息
		   /etc/shadow -主要包含了账户的密码及管理信息
*/

		tarena: x : 1000   :  1000   : tarena,,,:/home/tarena:/bin/bash
    	        用户名:密码:用户编号:用户组编号:注释信息:用户主目录  :shell的类型

	
		 


	1.3 错误信息(对错误编号的翻译)
	    (1)strerror
		#include <string.h>
		char *strerror(int errnum);

	    函数功能:
`		主要用于将参数指定的错误编号进行翻译,将翻译得到的字符串
		通过返回值返回。


	    (2)perror函数(/*重中之重*/)
		#include <stdio.h>
	        void perror(const char *s);
			    /* 理论可以传任何字符串参数,习惯传函数名~ */	


	    函数功能:
		主要用于打印具体的错误信息,参数指向的字符串会原样打印,紧跟着
		冒号、空格、错误信息以及自动换行;


	    (3)printf函数(了解、不常用)
		printf("%m");



	NOTE: 
	    不能直接使用errno的数值来作为判断函数是否出错的依据,因为errno会保留
	之前的错误编号,也会随时发生改变,因此判断函数是否出错还是需要依据函数的
	返回值,而只有明确函数已经出错的情况下,可以依据error来获取错误的原因;

	







				/*环境表*/

	2. 环境表的概念和使用
	2.1 基本概念
	    环境表本质就是环境变量的集合,每个进程内部都拥有一张独立的环境表信息，
	  用于记录专属于该进程的环境信息;
	    环境表就是一个以空指针作为结尾的字符指针数组,其中每个指针都指向
	  一个格式为"变量名=变量值"的字符串,该指针数组的首地址保存在全局变量  		  char** environ中,因此通过访问全局变量environ可以遍历整个环境表信息;
		
	练习:
		找到SHELL的环境变量



**********************
//遍历环境表
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main(){
    //声明外部的全局变量
    extern char** environ;
    //指定零食变量代替environ进行遍历
    char** ppv = environ;
    while(*ppv != NULL){
        //打印字符串内容
        printf("%s\n",*ppv);
        //指向下一个字符串
        ppv++;
    }   
    
    printf("------------------------------\n");
    /*练习:找到SHELL的环境变量，将环境变量SHELL的变量值取出来放到自定义数组buf中,打印buf中的内容
    */
    ppv = environ;
    char buf[10] = {}; 
    while(NULL != *ppv){
        if(!strncmp("SHELL",*ppv,5)){
            strcpy(buf,*ppv+6);
            break;//跳出循环
        }   
        ppv++;
    }   
    printf("%s\n",buf);
    return 0;
}

***********************




	2.2 基本操作的相关函数
	    (1)getenv函数		
 		 #include <stdlib.h>
		 char *getenv(const char *name);

	    函数功能:
		主要用于根据参数指定的环境变量名来查找整个环境表,查找成功时
	    返回该变量名所对应的变量值,查找失败时返回 NULL;


	    (2)setenv函数
 		 #include <stdlib.h>
		 int setenv(const char *name,const char *value, int overwrite);


		第一个参数:字符串形式的环境变量名
		第二个参数:字符串形式的环境变量值
		地三个参数:是否修改的标志
			    非0 -修改
			    0   -不修改
		返回值: 成功返回 0，失败返回 -1 ，并且设置errno来指示错误原因。
		函数功能:
		    主要用于修改/增加环境变量;





	    (3)unsetenv函数
		#include<stdio.h>
		int unsetenv(const char* name);

	    函数功能:
		主要用于从环境表中删除参数指定的环境变量,如果该环境变量不存在,
		则函数调用是成功的，环境没有发生改变;



	    (4)putenv函数
		#include <stdlib.h>

       		int putenv(char *string);
	    
	    返回值:成功返回0 ，失败返回非0；
	    函数功能:
		主要用于增加/修改参数指定的环境变量,参数的格式为:
	    name=value， 当该变量不存在时则增加,否则则修改；



	    (5)clearenv函数
		#include <stdlib.h>

		int clearenv(void);

		
	    函数功能:
		主要用于清空环境表中所有的环境变量对,并且让全局变量environ也置为
		空指针,成功返回0,失败返回非0；



	2.3 main函数的原型(了解)
	    
	    int main(int argc,char* argv[],char* envp[])

	  解析：
	    argc 	-命令行参数的个数;
	    argv	-记录每个命令行参数的首地址;
	    envp	-记录环境表的首地址;
	  注意:
	     由于历史等原因,main函数中的第三个参数不一定被系统所支持,
	    因此建议使用全局变量environ来访问环境表信息;










/**************************************************************************/
*															   		      *
*	   							day_05		   							  *
*										   								  *
/**************************************************************************/




	一、内存管理技术


	
			/*内存管理技术*/

	1. 内存管理技术
	1.1 程序和进程的概念
	    程序 - 主要指存放在/*磁盘/硬盘*/上的可执行文件;
	    进程 - 运行在/*内存*/中的程序;
	    
	    同一个程序可以同时对应多个进程;

	1.2 进程中的内存区域划分

		int num;   //全局变量  默认初始值为0	BSS段
		int main(){
		    int num; //局部变量  随即初始值	栈区
		    return 0;
		}

	    (1)代码区(Text)
		-该区域主要用于存放具体的功能代码,/*函数指针*/指向该区域;

	    (2)只读常量区(Text)
		-该区域主要用于存放/*常量字符串*/,/*const修饰的并且已经初始化的全局变量
		/已经初始化的静态局部变量*/,以及/*字面值*/;

	    (3)全局区/数据区(Data)
		-该区域主要用于存放没有const修饰的已经初始化的全局变量
		和静态局部变量;

	    (4)BSS段(Data)
		-该区域主要用于存放没有const修饰也没有初始化的全局变量和
		静态局部变量
		-该函数会在main函数执行之前自动清零

	    (5)堆区(Heap)
		-该区域主要用于由函数malloc()/calloc()/realloc()/free()函数
		操作的内存区域;
		-该区域有程序员手动声请和手动释放;

	    (6)栈区(Stack)
		-该区域主要用于存放/*非静态的局部变量(包括函数的形参)*/;
		-该区域有操作系统自动管理;



		综上所述:
		    进程中的内存区域按照地址从小到大一次排列的结果是:代码区，
		只读常量区,全局区/数据区，BSS段，堆区，栈区；
		    一般来说，其中堆区的内存地址按照从小到大依次进行分配,
		  栈区的内存地址按照从大到小依次分配,以避免区域的重叠；





*****************************
    int i1 = 10; 	//全局区
    int i2 = 10;	//全局区
    int i3; 		//BSS段
    const int i4 = 40; //只读常量区

void fa(int i5){     	 //栈区
    int i6 = 60; 	//栈区
    static int i7 = 70; //全局区
    const int i8 = 80; //栈区
    //p1,p2指向堆区 p1,p2本身在栈去
    int* p1 = (int*)malloc(sizeof(int));
    int* p2 = (int*)malloc(sizeof(int));
    //str指向只读常量区 str本身在栈区
    char* str = "hello";
    //str指向栈区 str本身在栈区
    char strs[]= "hello";
}

int main(){
    printf("-------代码区------------\n");
    printf("代码区:fa = %p\n",fa);
    fa(10);
    return 0;
}

**********************************




	1.3 常量字符串不同存放形式的比较(重点)

	    对于记录常量字符串的/*字符指针*/来说,指针指向的内容不可以改变,
		但指针指向的可以改变；
	    对于记录常量字符串的/*字符数组*/来说，指针指向的内容可以改变,
		但指针指向的不可以改变；

	    对于一块指向/*动态内存的指针*/来说,指针指向的内容和
	    指针指向都可以发生改变。





		
				/*虚拟内存*/

	1.4 虚拟内存管理技术(尽量理解)
	    一般来说,在linux系统中采用虚拟内存管理技术来进行内存空间的管理,
	即:每个进程都可以拥有0~4G-1 的内存地址空间(虚拟的,并不是真实存在的),由操作
	系统负责建立虚拟地址到真实物理内存/文件的映射,因此，不同进程中的地址空间
	看起来是一样的,但是对应的真实无力内存/文件是不一样的。


	其中0~3G-1 的地址空间 叫做用户空间
	   3G~4G-1 地地址空间 叫做内核空间
	用户程序一般都运行在用户空间中,不能直接访问内核空间,不过内核提供了一些
	函数用于访问内核空间。

	  内存地址的基本单位是字节,而内存映射的基本单位是内存页，目前主流的操作
	系统中一个内存页的大小是4Kb(4096个字节)

	    1Kb = 1024 byte(字节)
	    1byte = 8 bit(二进制位)


	1.5 段错误的由来

	    (1)试图去操作没有操作权限的内存空间时可能会引起段错误;
		如:试图修改只读常量区的数据时会引起段错误.

	    (2)试图使用没有经过映射的虚拟地址时可能会引起段错误;
		如:指定任意地址去访问里面的内容时会引起段错误。



	1.6 使用malloc函数申请动态内存
	
	    (1)使用malloc函数申请动态内存时的注意事项.
		使用malloc函数申请动态内存时,除了申请参数指定的动态内存空间之外
	    还可能申请额外的12个字节(一般原则)用于保存该动态内存块的管理信息,
	    如:大小，是否空闲等信息; 
	
	  	因此,使用malloc函数申请的动态内存时，切记不要进行越界访问,
		因为越界访问可能会破坏内存快的管理信息,从而导致段错误的结果;

	    
	    (2)使用malloc函数申请动态内存时的一般性原则

		一般来说,当使用malloc函数申请比较小快的动态内存时,操作系统一般会
	    一次性映射33个内存页的地址空间,从而提高效率；


		#include<unistd.h>
		#include<sys/types.h>
		printf("getpid = %d\n",getpid());//获得当前进程号

		/*  cat /proc/进程号/maps  */   
			 -表示查看指定进程的内存映射情况;


	查看结果是6列:地址范围、权限信息、偏移量、设备编号、i节点编号、
		     进程名称以及路径信息；

		重点关注;heap即可






	1.7 使用free函数释放动态内存的一般原则

	    一般来说,使用free函数释放多少则从映射的总量中减去多少,
	当所有的动态内存全部释放完毕后,操作系统依然会保留33个内存页,用以提高效率；





	【练习】
		使用C语言中的错误表现形式编写以下两个功能函数:
		a.实现计算参数指定的文件的大小,并通过返回值返回,
		  如果参数指定的文件打开失败,则返回错误;
		    ftell()	fseek()
		b.实现比较两个参数字符串的大小,并返回最大值,如果相等则返回错误
			string_compare()
                                                                                                                                                                                                                                                                                                                    





/**************************************************************************/
*									   *		
*				day_06					   *	
*									   *
/**************************************************************************/




	一、内存管理技术
	二、文件的管理



						/*内存管理技术*/


	1. 内存管理技术
	1.1 常用的内存管理函数
	    
	    (1)getpagesize函数
		
		#include <unistd.h>
		int getpagesize(void);

	    函数功能:
		主要用于获取当前系统中一个内存页的大小并返回;



	    (2)sbrk函数
		#include <unistd.h>
		void *sbrk(intptr_t increment);


	    函数功能:
		主要用于根据参数的数值来调整动态内存的大小,具体方式如下:
	     	当increment > 0 时,表示申请动态内存;
		当increment = 0 时,表示获取当前动态内存的末尾地址;
		当increment < 0 时,表示释放动态内存,

	    函数调用成功时会返回调整之前的末尾地址,失败返回 (void*) -1


	注意:
	    a.虽然sbrk函数技能申请动态内存有能释放动态内存,
	      但是申请内存的操作更加方便一些;

	    b.一般来说,使用sbrk函数申请比较小块的动态内存时,操作系统一次性映射
	1个内存页大小的地址空间,当sbrk函数申请的动态内存超过1个内存页是,则操作系统
	会再次映射1个内存页,当sbrk函数释放所有动态内存时,操作系统不会保留映射的
	地址空间,
	
	因此和malloc()函数相比,更加节省内存空间,但是效率没有malloc()
	和free()函数高;




	    (3)brk函数
		#include <unistd.h>
		int brk(void *addr);

	    函数功能:
		主要用于将动态内存的末尾地址调整到参数指定的位置,方法如下:
		
		当addr > 动态内存原来的末尾地址时,表示申请动态内存;
		当addr = 动态内存原来的末尾地址时,表示动态内存不变;
		当addr < 动态内存原来的末尾地址时,表示释放动态内存;



	注意:
		虽然brk函数既能申请内存有能释放内存,但是是否那个内存更加方便,
	    因此一般情况下使用sbrk函数和brk函数搭配使用：
	/*	sbrk函数专门用于申请内存,brk函数专门用于释放内存;    */
		




	练习:
		使用sbrk和brk
	 首先申请一个int类型大小的存储空间,存放数据66,再申请一个double类型大小
	的存储空间存放3.14,再申请10个字节大小的字符串空间,存放数据"hello"
	最后打印上述数据内容，并释放全部动态内存。




	    (4)mmap函数
		#include <sys/mman.h>
		void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
		
		第一个参数:用于指定映射的起始地址,给 NULL 由系统内核指定
		第二个参数:用于指定映射的大小
		第三个参数:用于指定映射的操作权限信息
			PROT_EXEC	-可执行
			PROT_READ	-可读
			PROT_WRITE	-可写
			PROT_NONE	-不可访问
			
		第四个参数:用于指定映射的标志位
			MAP_SHEARED	-共享的,写入映射区的数据直接反映到文件中
			MAP_PRIVATE	-私有的,写入~	~     ~不会反映到文件中
			MAP_ANONYMOUS	-表示映射到物理内存,此时忽略第五,六参数

		第五个参数:文件描述符,暂时给0即可;
		第六个参数:文件中的偏移量,暂时给0即可;
		
		返回值:成功返回被映射区域的首地址,
			失败返回MAP_FAILED(即(void*)-1)

	    函数功能:
		主要用于建立文件/设备到虚拟地址之间的映射;



	    (5)munmap函数
		#include <sys/mman.h>
		int munmap(void *addr, size_t length);
		
		第一个参数:要接解除射区域的首地址;
		第二个参数:要解除映射区域的大小;


	    函数功能:
		主要用于解除参数指定的映射;




	1.2 内存管理函数之间的层次关系
	   ^	
	   |
	标准C语言 => 使用malloc函数申请内存,使用free函数释放内存
	   |
	POSIX标准 => 使用sbrk函数申请内存,使用brk函数释放内存
 	   |
	操作系统  => 使用mmap函数建立映射,使用munmap函数解除映射	
	   |
	... ...
	  底层



						/*文件管理*/

	2. 文件管理	
	2.1 基本概念
	    在linux系统中,几乎可以把所有的一切都看作文件,包括目录、输入输出设备等
		/dev/null	-空设备文件
	    如:
		echo	回显命令		
		1)echo hello
		=> 输出hello字符串
	
		2)echo hello > a.txt
		=> 将输出的字符串hello写入到文件a.txt中
		cat a.txt 可以查看a.txt内容

		3)echo hello > /dev/null  /*用法一*/
		=> 将输出的字符串hello写入到文件/dev/null中,表示丢弃;

		4)cat /dev/null > a.txt  /*用法二*/
		=> 表示清空文件a.txt中的内容

		
	2.2 基本操作的相关函数(/*重点*/)
	
	    标C中文件操作函数:
			fopen()/fclose()/fread()/fwrite()/fseek();
		
		UC中的文件操作函数:
			open()/colse()/read()/write()/lseek() -- /*long seek*/;


		(1)open函数  
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

       int open(const char *pathname, int flags);  //文件存在时用
       int open(const char *pathname, int flags, mode_t mode/*权限*/);

       int creat(const char *pathname, mode_t mode);//不存在时创建,存在时清空

		第一个参数：字符串形式的路径名,也就是路径和文件名
		第二个参数：具体的操作标志
				必须包括以下访问权限中的一个：
				O_RDONLY --	只读
				O_WRONLY -- 只写
				O_RDWR	 -- 可读可写
			除此之外,还可以 按位或 以下的标志:
				O_APPEND	-表示以追加的方式打开文件
				O_CREAT -表示文件不存在则创建,存在则打开
				O_EXCL	-与上面O_CREAT搭配使用,若不存在则创建,存在则创建失败
				O_TRUNC	-若文件存在则清空文件中的内容

		第三个参数：文件的权限信息,当创建新文件时,该参数可以用于指定新文件的权限
					信息,如：0664 => rw-rw-r--;//0表示八进制
					当打开打开一个已经存在的文件时，该参数可以忽略,不需要提供；

		返回值：成功返回新的文件描述符,失败返回-1；
		函数功能：
			主要用于打开/创建一个文件；


		注意：
       		creat() is equivalent to open() with flags equal to
       		O_CREAT|O_WRONLY|O_TRUNC.

		

//	扩展：
		使用ls -l a.txt 命令的执行结果如下：
		-rw-rw-r-- 1 tarena tarena 0  4月 13 15:19 a.txt
		其中
		-      rw-     rw-      r--       
	普通文件  属主权限 属组权限 其他用户权限	
	    1 		tarena 	 tarena 	0  		4月 13 15:19 	a.txt
		硬链接数 属主名称 属组名称 文件大小 最后一次修改时间  文件名称
	
	其中常见的文件类型有:
		-	表示普通规则文件
		d	表示目录文件
		... ...

	其中文件的权限信息有:
		r 	-可读	 4 
		w	-可写	 2
		x	-可执行	 1
		-	-无此权限 0



		(2)close函数 
       #include <unistd.h>
       int close(int fd);

		  函数功能：
			主要用于关闭参数指定的文件描述符,以至于该描述符不再关联任何一个文件,
		  该描述符可以被再次使用;



		(3)read函数 
       #include <unistd.h>
       ssize_t read(int fd, void *buf, size_t count);
		
		第一个参数：文件描述符,open函数的返回值;(从哪里读)
		第二个参数：缓冲区的首地址(存放到哪里)
		第三个参数：期望读取的字节数；

		返回值：成功返回实际读取到的字节数,0表示读取到了文件末尾 失败返回-1；

		函数功能：
			主要用于从指定的文件中读取数据到指定的缓冲区中；
	
		(4)write函数
       #include <unistd.h>
       ssize_t write(int fd, const void *buf, size_t count);

		第一个参数：文件描述符,open函数的返回值;(写入到哪里)
		第二个参数：缓冲区的首地址(写入的数据从哪里来)
		第三个参数：期望写入的字节数；		
		
		返回值：成功返回实际写入的数据大小,返回0表示啥也没有写入,失败返回-1；

		函数功能：
			主要用于将指定的数据内容写入到指定的文件中；



		练习：
			vi 07read.c
				编程读取文件c.txt中的内容并打印出来




	作业：
		a. vi 09write_emp.c 文件 要求定义一个员工类型的结构体变量并且进行初始化,将该员工信息写入到文件emp.dat中，其中员工的信息主要有：员工的编号。员工的姓名，员工的薪水；
		b. vi 10read_emp.c 文件，要求读取emp.dat中员工信息，并打印出来；

		c.查询fcntl函数；





/**************************************************************************/
*									   *		
*				day_07					   *	
*									   *
/**************************************************************************/






				/*文件的管理*/

	1. 文件管理	
	1.1 基本操作的相关函数
	    (1)lseek函数
			
       #include <sys/types.h>
       #include <unistd.h>

	   off_t lseek(int fd, off_t offset, int whence);

		第一个参数：文件描述符，open函数的返回值(调整那个文件)
		第二个参数：偏移量(调整多少字节);
					> 0		-向文件末尾方向偏移
					= 0		-表示不偏移
					< 0		-向文件开头方向偏移
			

		第三个参数：起始位置(从什么地方开始偏移)

			SEEK_SET	-文件开始位置
						-向后偏移合理,向前偏移不合理(极端情况不考虑)
			SEEK_CUR	-文件当前位置
			SEEK_END	-文件末尾位置
						-向前向后偏移都合理(特殊情况不考虑)
						

		返回值：
			成功返回当前位置距离文件开头位置的偏移量，
			失败返回(off_t)-1；
			
		函数功能：
			主要用于调整指定文件中的读写位置;


		注意：
			当把文件的读写位置调整到SEEK_END后面的位置再写入数据时,数据也是
		  可以写入的，只是中间有一块区域空闲,该现象叫做文件的空洞现象,该区域
		  会被计算到文件的大小中,但是没有有效数据,获取内容时得到的是'\0' ;


		扩展：
			如何获取一个文件的大小信息？？？
			a.使用fseek函数调整文件读写位置到末尾,使用ftell函数返回；
			b.使用lseek函数调整文件读写位置到末尾,返回值就是文件大小。



	1.2 标C和UC文件操作函数的比较

		


		练习：
			分别使用标C和UC的文件操作函数编写以下代码：

		a. vi 04fwrite.c, 将[1~10^6]之间的每一个整数写入到文件num.dat中； a.out
		b. vi 05write.c,将[1~10^6]之间的每一个整数写入到文件num2.dat中； b.out


		由程序的结果可知;标C的文件操作函数执行效率高于UC的文件操作函数,
		因为标C的文件操作函数内部提供了输入输出缓冲区,当数据积累到一定数量之后
		才去访问内核,才会将数据写入到文件中。
	
//time a.out
打开/创建文件成功
写入数据成功
成功关闭

real	0m0.058s  /*关注*/
user	0m0.044s
sys	0m0.012s

//time b.out
打开/创建文件成功
成功写入数据
成功关闭文件

real	0m1.584s	/*.*/
user	0m0.052s
sys	0m1.528s
day07$



		可以通过自定义缓冲区的方式来提高效率,但并不是缓冲区越大效率越高;





	1.3 文件描述符的工作原理(尽量理解)

		文件描述符本质上就是一个整数,可以代表一个打开的文件,但是文件的管理信息并不
	  是存放在文件描述符中,而是存放在/*文件表*/等数据结构中,使用open函数打开
	  文件时, 操作系统会将文件的相关信息加载到文件表等数据结构中,但是处于安全
	  和效率等因素的考虑,文件表等数据结构不适合直接操作,而是给文件表等结构指定
	  一个编号,使用编号来操作文件,该编号就是文件描述符；

	  	在每个进程的内部都有一张文件描述符总表，当有新的文件描述符需求时，
	会从文件描述符从表中查找最小的未被使用的文件描述符返回，文件描述符虽然是int
	类型，但是本质上是非负整数，也就是从0开始，其中0 1 2 已经被系统占用,分别代表
	标准输入，标准输出以及标准错误，因此一般从3开始使用，文件描述符的最大值可以
	到OPEN_MAX(当前教学环境是1024)

	    使用close函数关闭文件时,本质上就是将文件描述符和文件表等数据结构的对应关系
	从文件描述符总表中移除,不一定会删除文件表等数据结构,只有当文件表没有和任何
	其它文件描述符对应时(也就是一个文件表可以同时对应多个文件描述符)，才会删除
	文件表等数据结构,close函数也不会改变文件描述符本身的整数值,只是让该文件描述符
	无法代表一个文件而已；




	1.4 dup/dup2函数
       #include <unistd.h>

       int dup(int oldfd);
 		
		
		函数功能：
			主要用于实现对参数oldfd的复制,从文件描述符总表中查找最小的未被使用
			的文件描述符作为oldfd的副本,成功返回新的文件描述符,失败返回-1；

       int dup2(int oldfd, int newfd);
		
		函数功能：
			主要用于实现oldfd到newfd的复制,如果文件描述符newfd已经被其他文件占用
		  则先关闭在复制,成功返回新的文件描述符,失败返回-1；



		注意：
			复制文件描述符的本质就是复制文件描述符所对应的文件表地址信息，使得多个
		  文件描述符可以对应同一个文件,因此无论使用那个文件描述符都可以访问文件；

		

	作业：
		a. vi 09write_emp.c 文件 要求定义一个员工类型的结构体变量并且进行初始化,将该员工信息写入到文件emp.dat中，其中员工的信息主要有：员工的编号。员工的姓名，员工的薪水；
		b. vi 10read_emp.c 文件，要求读取emp.dat中员工信息，并打印出来；

		c.查询fcntl函数；

	





/**************************************************************************/
*															    		  *	
*								day_08					   				  *	
*									   									  *
/**************************************************************************/




	1. 文件管理
	1.1 fcntl函数

       #include <unistd.h>
       #include <fcntl.h>

       int fcntl(int fd, int cmd, ... /* arg */ );


		第一个参数：文件描述符,open函数的返回值
		第二个参数；具体的操作命令
				F_DUPFD	-查找最小的 >= arg 的描述符作为fd的副本，与dup2不同的地方
						 在于：若arg已经被其他文件占用,则不会关闭而是查找>arg
						 的描述符进行复制；

				F_GETFD/F_SETFD	-获取/设置文件描述符的标志；
				
				F_GETFL/F_SETFL	-获取/设置文件的状态标志；

				F_SETLK/F_SETLKW/F_GETLK -实现加锁和解锁等功能；

		第三个参数：可边长参数，是否需要取决与cmd
			如果实现文件锁的功能，则需要一个指向以下结构体的指针:

           struct flock {
               ...
               short l_type;    /* Type of lock: F_RDLCK,
                                   F_WRLCK, F_UNLCK(解锁) */
               short l_whence;  /* How to interpret l_start:
                                   SEEK_SET, SEEK_CUR, SEEK_END */
               off_t l_start;   /* Starting offset for lock */
               off_t l_len;     /* Number of bytes to lock(加锁的长度) */
               pid_t l_pid;     /* PID of process blocking our lock(锁的进程号)
                                   (F_GETLK only) */
               ...
           };
		

		返回值：成功返回值取决与操作符:

	       F_DUPFD  The new descriptor.

	       F_GETFD  Value of file descriptor flags.

	       F_GETFL  Value of file status flags.

 	      All other commands
                Zero.
    	  On error, -1 is returned, and errno is set appropriately.


		函数功能：
			主要用于操作文件描述符，具体操作方式如下：
		
			a.复制文件描述符(了解)   File descriptor
			b.操作文件描述符的标志(了解)  File descriptor flags
			c.操作文件的状态标志(了解)  File status flags
			d.实现建议锁/文件锁的功能(重点)




	1.2 使用fcntl函数实现文件锁的功能
		(1)文件锁的由来
			当多个进程在同一时刻向同一个文件中的同一快区域写入不同数据时,可能会
	  	  造成文件数据的交错和混乱问题,理论上多个进程同时读文件可以同时进行,但是
		  只要有一个进程执行写操作，那么多个进程就不该同时进行，为了实现该效果，
		  需要借助文件锁机制。

			文件锁本质上就是读写锁，一把读锁和一把写锁,其中读锁是共享锁,允许其他
		  进程加读锁但不允许加写锁；而写锁是互斥锁,不允许其他进程加读锁和写锁；


		(2)使用F_SETLK作为函数第二个实参的用法:

			当锁的类型是F_RDLCK/F_WRLCK 实现加锁功能
			当锁的类型是F_UNLCK时  实现解锁的功能
			无论实现加锁还是解锁,具体的锁信息由第三个参数指定；


	【练习】
	vi 03lockB.c 文件 要求使用fcntl函数对文件a.txt中第三个字节起的前15个字节加
	写锁,判断是否加锁成功并打印结果；



	由03lockA.c 和 04test.c 程序结果可知;
		当文件被加完写锁时,依然是可以写入数据到文件中,由此可见,文件锁并不能真正
	锁定对文件的读写操作，只能锁定其他的锁,也就是导致第二次加锁失败(两个读锁除外).
			= > 君子协定


	/*解决方案：*/
		一般来说，在指向读写操作之前尝试加读写锁,根据能否进行加读写锁来决定
	  能否进行读写操作；



	释放锁的方式：
			a.将锁的类型改为F_UNLCK,重新使用fcntl函数进行设置即可;
			b.使用close函数关闭文件描述符时,与该描述符有关的文件锁全部释放;
			c.进程结束是会自动是否那个所有与该进程相关的文件锁;




		(3) 使用F_SETLKW作为函数的第二个实参时的用法

		  该参数的用法与F_SETLK相似,所不同的是当文件中已经存在一把冲突的锁时,
		并不会返回加锁失败,而是一直等待直到文件上的冲突锁被释放为止；


		(4)使用F_GETLK作为函数第二个实参是的用法

			如果第三个参数描述的锁信息可以加到文件上,则fcntl函数不会去加锁，
		  而是将锁的类型改为 F_UNLCK ，其他成员保持不变。
			如果第三个参数描述的锁信息不可以加到文件上,则fcntl函数会获取文件上
		  已经存在的锁信息,并用这些覆盖第三个参数原来描述的锁信息,也就是获取文件上
		  已经存在的锁信息。


		
	
	1.3 access函数

       #include <unistd.h>

       int access(const char *pathname, int mode);

		第一个参数：字符串形式的文件路径名
		第二个参数：具体的操作模式
			F_OK	-判断文件是否存在(/*重点*/)
			R_OK	-判断文件是否可读
			W_OK	-判断文件是否可写
			X_OK	-判断文件是否可执行


		函数功能：
			主要用于判断文件的存在性以及是否拥有相应的权限;


	1.4 stat/fstat函数(/*重点*/)

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *path, struct stat *buf);
       int fstat(int fd, struct stat *buf);

		第一个参数：字符串形式的文件路径名/文件描述符
		第二个参数：结构体指针，准备结构体变量去地址作为实参

			结构体类型如下：
           struct stat {

               mode_t    st_mode;    /* protection(文件类型和权限) */

               off_t     st_size;    /* total size, in bytes(文件大小)*/

               time_t    st_mtime;   /* time of last modification
												(最后一次修改时间) */
				... ...
           };



		函数功能：
			主要用于获取指定文件的状态信息，通过第二个参数带出来；




		获取文件大小的三种方法:
			a.fseek函数
			b.lseek函数
			c.stat函数



		扩展：

			#include<time.h>
1
 	      char *ctime(const time_t *timep);

		=> 主要用于将参数指定的整数时间转换为字符串类型时间并返回；
	


       struct tm *localtime(const time_t *timep);

		=> 主要用于将参数指定的整数时间转换为结构体指针类型的时间,
			其中结构体的类型如下:
							  
           struct tm {
               int tm_sec;         /* seconds */
               int tm_min;         /* minutes */
               int tm_hour;        /* hours */
               int tm_mday;        /* day of the month */
               int tm_mon;         /* month + 1 */
               int tm_year;        /* year + 1900 */

           };

				
	

		作业:
			自定义函数generator_id，实现每次执行程序时都可以不断地打印一个自动
		增长的整数值；








/**************************************************************************/
*															    		  *	
*								day_09					   				  *	
*									   									  *
/**************************************************************************/






	1. 文件的关系
	1.1 chmod/fchmo函数
       #include <sys/stat.h>

       int chmod(const char *path, mode_t mode);
       int fchmod(int fd, mode_t mode);


	第一个参数：字符串形式的文件路径名/文件描述符
	第二个参数：具体的新权限,如：0664


	函数功能：
		主要用于修改指定的文件到指定的权限；


	1.2 truncate/ftruncate函数(/*重点*/)

       #include <unistd.h>
       #include <sys/types.h>

       int truncate(const char *path, off_t length);
       int ftruncate(int fd, off_t length);

	
	第一个参数：字符串形式的文件路径/文件描述符
	第二个参数：具体的新长度

	函数功能：
		主要用于修改指定文件到指定的大小；
		

	注意：
		当文件变小时,后面多余数据丢失;当文件变大时,扩展出来的内容读取到的就是'\0'
	  而文件读写位置的偏移量不会改变；


	练习：
		使用echo hello > a.txt 的方式创建文件a.txt, vi 01chmod_truncate.c文件
	  使用stat函数获取文件a.txt的权限和大小信息并打印,然后使用chmod和truncate函数修改文件的权限和大小为：0600 和 100， 最后使用stat函数获取修改后的信息并打印；



	1.3 umask函数

       #include <sys/types.h>
       #include <sys/stat.h>

       mode_t umask(mode_t mask);



	函数功能：
		主要用于设置文件在创建时屏蔽的权限为：参数指定的权限值,返回之前的旧
	  的屏蔽权限；



	1.4 再见mmap和munmap函数
       #include <sys/mman.h>

       void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
       int munmap(void *addr, size_t length);

	
	
	  	  通过建立虚拟地址到文件的映射，
		  可以/*将对文件的操作转换为对内存地址的操作，*/
		只需要简单的赋值操作就可以将数据写入到文件中,因此又多了一种读写文件的方式;



	1.5 其他函数
		link()		-建立硬链接
		unlink()	-删除硬链接
		rename()	-重命名文件
		remove()	-删除文件
		...	...

	






	2. 目录管理
	2.1 常用的基本操作函数：
		
		(1)opendir函数
	    	#include <sys/types.h>
    	   	#include <dirent.h>

    	   	DIR *opendir(const char *name);
    	   	DIR *fdopendir(int fd);

		函数功能：
			主要用于打开参数指定的目录,成功返回有效的目录指针,失败返回 NULL;



		(2)readdir函数
       #include <dirent.h>

       struct dirent *readdir(DIR *dirp);



		函数功能：
			主要用于读取参数指定的目录内容,参数为opendir函数的返回值,
		  读取成功时返回一个有效的结构体指针,失败返回NULL;




           struct dirent {
				... ...

               unsigned char  d_type;      /* type of file; not supported
                                              by all file system types */
               char           d_name[256]; /* filename */
           };



		(3)closedir函数
       #include <sys/types.h>

       #include <dirent.h>

       int closedir(DIR *dirp);


		函数功能：
			主要用于关闭参数指定的目录,参数为opendir函数的返回值;






	/*
			类型为4 目录文件		目录为8 表示普通文件		
	*/





	2.2 其他函数

		mkdir() 	-创建目录
		rmdir()		-删除目录
		chdir()		-切换目录
		getcwd()	-获取当前工作目录所在的绝对路径信息
		... ...



	


	3. 进程的管理
	3.1 基本概念和基本命令

		程序		-存放在磁盘上的可执行文件;
		进程		-运行在内存中的程序;
		同一个程序可以同时对应多个进程;


		ps 		-表示查看当前终端启动的进程信息;

/*
		PID	 进程编号(重点)	 
		TTY	终端的次要装置号码
		TIME	消耗CPU的时间
		CMD		进程的名称(重点)
*/


		ps -aux	-表示查看所有包括其他使用者的进程信息；
		ps -aux | more  -表示分屏显示所有的进程信息;
/*
	USER	-用户名称
       
	PID 	-进程号

	%CPU 	-占用CPU的百分比

	%MEM    -占用内存的百分比

	VSZ   	-虚拟内存的大小
	
	RSS 	- 物理内存的大小

	TTY      -终端的次要装置号码

	STAT 	-进程的状态信息

	START	-进程的启动时间

   TIME		-消耗的CPU的时间
	
  COMMAND	-进程的名称
	
	其中进程的主要状态如下(了解)：
	
	S	休眠状态，为了减轻CPU的压力
	s	进程的领导者，下面拥有子进程
	Z   僵尸进程，已经结束但资源没有回收的进程
	R	正在运行的进程
	O	可以运行的进程
	T	挂起的进程
	<	优先级比较高的进程
	N	优先级比较低的进程

	... ...
*/



	ps -ef		-表示以全格式的方式显示进程信息
	ps -ef | more

/*
	UID 	-用户的id
    PID 		-进程编号 
	PPID 	-父进程的编号 
	C		-占用CPU的百分比 
	STIME	-启动时间 
	TTY     -终端的次要装置号码     
	TIME	-消耗的CPU的时间 
	CMD		-进程的名称
*/

		目前主流的操作系统都支持多进程,如果进程A启动了进程B,那么进程A就叫做进程B的
	父进程,进程B就叫做进程A的子进程。

		当前系统中进程0(系统内部的进程)负责启动进程1(init)和进程2 其它所有进程
	都是	直接/简介由进程2启动起来的，从而构成了逻辑结构中的树形结构。	


		进程号的数据类型虽然是int类型,但是本质上是从0开始,作为进程的唯一标识，
	操作系统采用延迟重用的策略进行进程号的管理,从而保证在任意时刻进程号都是唯一的。

	
	kill -9  进程号 	-表示杀死指定的进程



	3.2 各种ID的获取
		getpid()	-获取当前进程的编号
		getppid()	-获取当前进程父进程的编号
    	   #include <sys/types.h>
    	   #include <unistd.h>

    	   pid_t getpid(void);
	       pid_t getppid(void);

		返回值： pid_t 类型


		getuid()	-获取当前用户的编号
		getgid()	-获取当前用户所在用户组的编号

    	   #include <unistd.h>
    	   #include <sys/types.h>
	
    	   uid_t getuid(void);

		返回值： uid_t 类型

/*
	在底行命令中输入 /+查找内容 可以快速查找
*/
	注意:
		pid_t类型本质就是 int 类型；
		uid_t类型和gid_t 类型本质就是 unsigned int类型;

	3.3 进程的创建
		(1) fork 函数
		
       #include <unistd.h>

       pid_t fork(void);
		

	函数功能：
		主要用于以复制当前正在调用进程的方式来启动一个新进程,而其中新启动的进程
	  叫做子进程,原来的进程叫做父进程,函数调用成功时父进程返回子进程的进程号，
	  子进程返回0，函数调用失败时直接返回-1，没有子进程被创建;



	作业：
		编程实现打印目录中的所有内容,要求子目录中的内容也要打印，

	参考代码：
void print(char* path)
{
	// .. ..	
}
int main()
{
	print("../day02");
	return 0;
}








/**************************************************************************/
*															    		  *	
*								day_10					   				  *	
*									   									  *
/**************************************************************************/




		一、进程的管理
		二、信号的处理


	1. 进程的管理
	1.1 进程的创建
		(1) fork函数
	
		#include <unistd.h>

        pid_t fork(void);
		

	函数功能：
		主要用于以复制当前正在调用进程的方式来启动一个新进程,而其中新启动的进程
	  叫做子进程,原来的进程叫做副进程,函数调用成功时父进程返回/*子进程的进程号*/，
	  /*子进程返回 0*/，函数调用失败时直接返回-1，没有子进程被创建;
		

	注意：
		父子进程的执行次序由操作系统的调度算法决定；


		(2)父子进程的执行次序
	
			a.对于fork函数之前的代码,父进程执行一次;
			b.对于fork函数之后的代码,父子进程各自执行一次;
			c.fork函数的返回值由父子进程各自返回一次;




		(3)父子进程之间的关系
		a.父进程启动了子进程,父子进程同时启动,如果子进程先于父进程结束,则会给
	  父进程发送信号,由父进程负责回首子进程资源。
		b.如果父进程先于子进程结束,则子进程变成孤儿进程,子进程会变父进程(一般
	  重新设置init(1)为新的父进程),inti进程收养了孤儿进程，所以叫做孤儿院。
		c.如果子进程先于父进程结束,但是父进程由于各种原因没有接收到子进程发来的
	  信号,也就没有回收子进程的资源,但是子进程已经结束了,因此子进程变成了僵尸进程;





		(4)父子进程之间的复制关系
			使用fork函数创建子进程后,子进程会复制父进程中除了代码区之外的
		  其他内存区域,而代码区和父进程共享;
			
			使用fork函数创建子进程后,子进程会复制父进程中的文件描述符总表,
		  但不会复制文件表结构,使得父子进程中的文件描述符对应同一个文件表结构;
		



		(5)扩展
			a.如何创建3个进程一共4个进程?
	
				fork();
				fork();

				4个进程：1个父进程+2个子进程+1个孙子进程
				/* 调用 n此fork() 一共2^n 个进程 */

			b.如何创建2个进程一共3个进程？
			
				pid = fork();
				if(pid > 0){
					fork(); // 只让父进程再调用fork函数
				}
				3个进程: 1个父进程+2个子进程

			c.俗称"fork炸弹"
				while(1){
				 	fork();	
				}




	练习:
		使用open函数创建一个文件a.txt,使用fork函数创建子进程,分别使用父进程和
	子进程向文件a.txt中分别写入数据“hello”和“world”,最后关闭文件

		vi 04fd.c





	3.2 进程的终止
		(1)正常终止进程的方式
		   	a.执行了main函数中的return语句;
			b.调用exit()函数进行终止;
			c.调用_exit()和_Exit()函数进行终止;
			d.最后一个线程返回;
			e.最后一个线程调用了pthread_exit()函数;


		(2)非正常终止进程的方式
			a.采用信号终止进程的执行;
			b.最后一个线程被其他线程取消;



		(3)终止进程相关函数的解析
		//_exit() _Exit()
       #include <unistd.h>
       void _exit(int status);	=> UC函数

       #include <stdlib.h>
       void _Exit(int status);	=> 标C函数

		函数功能：
			主要用于终止当前正在调用的进程;关闭所有属于当前进程的打开的文件描述符;
		  让该进程的所有子进程变更父进程为init进程;给父进程发送SIGCHLD 信号
		  帮其进行善后处理;
			参数status的数值被返回给当前进程的父进程作为当前进程的退出状态信息,
		  如果父进程收集该状态信息,则需要调用wait系列函数进行收集;

			函数_Exit() 和 函数_exit() 之间是等价关系;
		


		//exit()
       #include <stdlib.h>
       void exit(int status);

		函数功能：
  			主要用于引起正常进程的终止,参数status & 0377 之后的结果返回给父进程
		  作为该进程的退出状态信息,父进程可以使用wait系列的函数进行获取;
			该函数会自动调用所有由atexit()和on_exit()函数注册过的函数,该用法主要
		  用于进行/*善后处理*/;

			EXIT_SUCCESS and EXIT_FAILURE 作为函数exit的实参可以表示正常结束和
		  非正常结束程序的含义,但本质上就是0 和 -1；



		//atexit()
       #include <stdlib.h>
       int atexit(void (*function)(void));

		函数功能：
			主要用于注册参数指定的函数,该注册的函数会在正常进程终止时被调用,而正常
		  进程终止的方式有：调用exit()函数 和 执行main函数中的return;
			成功返回0 失败返回非0；
		

		//on_exit()

       #include <stdlib.h>
       int on_exit(void (*function)(int , void *), void *arg);


	1.3 进程的等待
		(1)wait 函数
			
       #include <sys/types.h>
       #include <sys/wait.h>
       pid_t wait(int *status);


		函数功能：
			主要用于挂起当前正在执行的进程直到有一个子进程终止为止;
		    当参数status不为空时,则将获取到的退出状态信息存放到该参数指定的
		  int类型存储空间中,为了正确的解析退出状态信息需要借助以下的宏定义:
					
	       WIFEXITED(*status) 	-当子进程正常终止时返回真,而子进程正常终止
		  		的方式有:  调用exit()/_exit()/执行了return语句；
		


		   WEXITSTATUS(*status)	-返回子进程的退出状态信息;

				成功返回终止子进程的进程号,失败返回-1


		(1)waitpid 函数

       #include <sys/types.h>
       #include <sys/wait.h>
       pid_t wait(int *status);
       pid_t waitpid(pid_t pid, int *status, int options);

		第一个参数：进程的编号(等待哪一个进程)
					< -1 表示等待任意一个进程组ID为pid绝对值的子进程(了解)
					= -1 表示等待任意一个子进程(重点)
					=  0 表示等待任意一个进程组ID为当前正在调用进程ID的子进程
						(了解)	
					>  0 表示等待进程号为pid的子进程(重点)

		第二个参数：指针变量,用于获取子进程的退出状态信息
		第三个参数：等待的方式,默认给0即可,表示阻塞的效果
					WNOHANG	   - 如果没有子进程退出则立即返回,不会等待

		返回值：如果使用阻塞的方式(第三个参数是 0 ) 成功返回子进程的进程号
				如果使用非阻塞方式(第三个参数是WNOHANG) 成功返回0
				失败都返回 -1；

		函数功能：
			主要用于等待参数指定的进程,并获取退出状态信息;

/*
			  waitpid(-1, &status, 0)	等价  wait(&status)   
*/




	作业：
		使用fork函数创建子进程，在子进程中申请一个int类型大小的动态内存，提示用户
	  输入半径,根据用户的输入计算周长并打印,要求当子进程终止时自动释放动态内存,
	  父进程等待子进程结束,并获取退出状态信息,打印出来;






/**************************************************************************/
*															    		  *	
*								day_11					   				  *	
*									   									  *
/**************************************************************************/




	
				/*进程管理*/



	1. 进程管理
	1.1 进程管理的其他函数 
	
		(1)vfork函数
       #include <sys/types.h>
       #include <unistd.h>
       pid_t vfork(void);



		函数功能：
			主要用于创建当前正在调用进程的子进程,有关详细情况以及返回值和
		  错误信息参考fork函数即可;
			该函数创建子进程时不会复制父进程中的内存空间,而是直接占用,导致父进程
		  被挂起,直到子进程终止或者调用exec系列函数为止,而子进程终止的方式不可以
		  是：从当前函数返回(结果不可预测) 以及调用exit()函数(可能会调用注册函数)
		  而应该调用_exit()函数来终止;

				/*   vfork函数保证了子进程先执行		*/



		(2)exec系列函数

       #include <unistd.h>
       int execl(const char *path, const char *arg, ...);

		第一个参数：字符串形式的路径名
		第二个参数：字符串形式的参数,一般指定具体的执行方式
		第三个参数：可变长参数,最后使用 NULL 作为结尾标志


		返回值：只有出错时才有返回值,并且返回-1；
		
		函数功能：
			主要用于执行参数指定的文件,类似与跳转的功能函数；

/*
		注意：
			vfork函数本身没有太大的实际意义,一般与exec系列的函数搭配使用,
		该用法主要用于子进程需要执行与父进程完全不同的代码段的场合中;
			其中vfork函数专门用于创建子进程,exec系列函数专门用于执行全新的代码段
			
			fork函数虽然也可以与exec系列函数搭配使用,但是fork函数创建的子进程会
		复制父进程中的内存区域,因此会影响效率;

*/

			/*	vfork	*/


		(3)system函数
       #include <stdlib.h>
       int system(const char *command);

		函数功能：
			主要用于执行参数指定的shell命令,成功返回i命令的状态信息,失败返回-1






				/* 信号处理 */

	2. 中断的概念和分类
		中断就是指停止当前程序的执行转而执行其他程序或者处理意外情况的过程；

		中断分为两种： 硬件中断  和  软件中断；


	3. 信号的处理
	3.1 基本概念和特性
		(1)基本概念
			信号本质就是一种软件中断,它既可以作为两个进程间通信的一种方式,
		  也可以中断一个程序的执行,它更多地被用于处理意外情况;

				
		(2)基本特性
			a.信号是异步的,进程并不知道信号何时会到达;
			b.进程既可以处理信号,也可以发送信号;
			c.每个信号都有一个名字,使用SIG开头;
		

	3.2 基本命令和分类

		kill -l 表示现实当前系统所支持的所有信号

		在linux系统中支持的信号范围是1~64,不保证连续,
		其中1~31之间的信号叫做不可靠信号,不支持排队,信号可能会丢失,也叫非实时信号
		其中34~64之间的信号叫做可靠信号,支持排队,信号不会丢失,也叫实时信号;


		要求掌握的信号：
			SIGINT	2	采用 ctrl+c	来产生该信号,默认处理方式为终止进程
			SIGQUIT	3	采用 ctrl+\	来产生该信号,默认处理方式为终止进程
			SIGKILL	9	采用 kill -9  产生,	默认处理方式为终止进程



	3.3 信号的处理方式
		(1)默认处理, 绝大多数信号的默认处理方式都是终止进程;
		(2)忽略处理
		(3)自定义处理/捕获处理



//		signal函数

       #include <signal.h>

       typedef void (*sighandler_t)(int);
       sighandler_t signal(int signum, sighandler_t handler);


		函数原型解析如下：
		typedef void (*sighandler_t)(int);
	=>typedef void (*)(int)	sighandler_t;

		sighandler_t signal(int signum, sighandler_t handler);
	=>	/*返回值为函数指针*/				/*第二实参为函数指针*/	

	最正宗的形状：
	=>void (*signal(int signum,void(*handler)(int)))(int);

	=>signal是一个函数
	  具有两个参数：一个参数是int类型,另外一个是函数指针类型
	  返回值类型是函数指针类型；

	=>	第二个参数和返回值类型的解析：
		是一个指向参数为int类型,返回值为void类型的函数的指针;
	

	函数功能解析如下：
		第一个参数：信号值/信号的名称(表示对哪个信号处理)
		第二个参数：函数指针类型,用于指定处理方式(怎么处理)
			SIG_IGN	-忽略处理
			SIG_DFL	-默认处理
			自定义函数的地址	-自定义处理
		

		返回值；成功返回之前的处理方式
				失败返回SIG_ERR;
		函数功能：	
			主要用于设置指定信号的处理方式;



	练习：
		使用signal函数设置对信号2进行自定义处理,设置对信号3进行忽略处理,
	再使用fork函数创建子进程,打印子进程的进程号后,子进程进入无限循环,父进程直接结束
	另起一个终端使用kill命令发送信号2 3 9 给子进程,观察处理结果；

		kill -2 ...






	3.4 父子进程对信号的处理方式

		(1)对于fork函数创建的子进程来说,子进程完全照搬父进程中对信号的处理方式
			即：父进程默认/忽略/自定义,子进程也默认/忽略/自定义;


		(2)对于vfork()和execl()函数启动的子进程来说,
			父进程默认/忽略， 子进程也默认/忽略。
			父进程自定义时，子进程采用默认处理(子进程跳出去了 没有自定义函数)。




	3.5 发送信号的方式
		(1) 采用键盘发送信号(只能发送部分特殊的信号)
			ctrl + c	发送SIGINT	2
			... ...
		
		(2) 程序出错发送信号(只能发送部分特殊的信号)
			段错误 引起 信号SIGSEGV	11
			... ...

		(3) 使用kill命令发送信号(全部信号都可以发)
			kill -信号值	 进程号
			kill -9 3302

		(4) 采用系统函数发送信号(发送大部分信号)
			kill()/raise()/alarm()/sigqueue()



	3.6	发送信号的函数解析
		(1)kill函数	
    	   #include <sys/types.h>
    	   #include <signal.h>
	       int kill(pid_t pid, int sig);

		第一个参数：进程号(给谁发信号)
				>0 表示发送信号sig给进程号为pid的进程(单发/*重点*/)
				=0 表示发送信号sig给和当前正在调用进程在同一个进程组的每一个进程
					(群发  了解)
				=-1 表示发送信号sig给每一个当前进程拥有拥有发送信号权限的进程
					除了进程1(init)(群发，了解)
				<-1 表示发送信号sig给进程组ID为-pid的每一个进程(群发,了解)
				

		第二个参数：信号值/信号名称(发送什么杨的信号)
				=0 表示不会发送信号,只是检查指定的进程是否存在
				
	
		函数功能：
			主要用于给指定的进程发送指定的信号；


		(2)raise函数
       #include <signal.h>

       int raise(int sig);


		返回值：成功调用时返回0,失败返回非0；
		
		函数功能：
			主要用于给当前正在调用的进程/线程发送参数指定的信号,对于单线程的程序
		来说,等价于kill(getpid(),sig);
			


		(3)sleep函数
	       #include <unistd.h>
	       unsigned int sleep(unsigned int seconds);



		函数功能：
			主要用于使得当前正在调用的进程进入睡眠状态,当指定的描述睡够了则返回0
			当指定的描述没有睡够但一个不能忽略的信号到来了,则返回剩余没有来得及
			睡的秒数；


		(4)alarm函数
	
       #include <unistd.h>
       unsigned int alarm(unsigned int seconds);

		返回值：
				如果之前有闹钟则返回之前闹钟没有来得及响的剩余秒数,否则返回0；

		函数功能：
			主要用于经过参数指定的秒数后给当前正在调用的进程发送SIGALRM信号,
		  如果参数为0,则表示没有新的闹钟被设置,每次设置新闹钟时都会取消之前的闹钟
			





/**************************************************************************/
*															    		  *	
*								day_12					   				  *	
*									   									  *
/**************************************************************************/




		1. 信号的处理
		1.1 信号集的基本概念和基本操作
			(1)基本概念
				信号集本质就是由若干个信号组成的集合;

		思考：
			如何采用最节省内存的方式来设计信号集的数据类型？
			int arr[64]; => 4*64 =256 
			short arr[64]; => 2*64 =128
			char arr[64]	=>  1*64 =64
			从采用每一个二进制位代表一个信号	=>	64个二进制位 = 8 个字节

			... ... 0010 0111  => 信号 1、2、3、6

		结论：
			操作系统中提供的信号集是：sigset_t 类型,底层是一个超级大的整数,采用
		 每一个二进制位来代表该信号是否存在,其中0表示该信号不存在,1表示该信号存在;
			//   sizeof(sigset_t) = 128  (多出来120个字节是为了以后的可扩展性)

		sigset_t 的结构：

typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;	 /* 4   *  (1024 / ( 8 * 4 )) = 128   */

typedef __sigset_t sigset_t;

		/*	采用结构体+数组 可以自定义超级大的数字	*/




		(2)基本操作
			sigemptyset()	-主要用于清空信号集
			sigfillset()	-主要用于填满信号集
			sigaddset()		-增加信号到信号集中
			sigdelset()		-删除信号集中指定的信号
			sigismember()	-判断信号是否存在于信号集中

       #include <signal.h>

       int sigemptyset(sigset_t *set);

       int sigfillset(sigset_t *set);

       int sigaddset(sigset_t *set, int signum);

       int sigdelset(sigset_t *set, int signum);

       int sigismember(const sigset_t *set, int signum);
			返回值：
					1		-signum存在
  					0		-signum不存在
				   -1		-错误
		



	1.2 信号的屏蔽

			在某些特殊程序的执行过程中,是不能被信号打断的,
			此时需要使用信号的屏蔽技术来解决该问题;

		(1)	sigprocmask函数
       #include <signal.h>

       int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

			第一个参数：具体的屏蔽方式(怎么屏蔽)
						 SIG_BLOCK	-表示进程中已经屏蔽的信号集+参数set的信号集
					如：  (ABC+CDE => ABCDE)						
						 SIG_UNBLOCK	-表示进程中已经屏蔽的信号集-参数set信号集
						  (ABC-CDE=> AB)
						 SIG_SETMASK 	-表示进程中已经屏蔽的 被参数set信号集替代
							(ABC  CDE => CDE)
			第二个参数：信号集类型的指针,用于传递新的信号集
			第三个参数：信号集类型的指针;
					如果该参数不为空，则带处设置之前进程已经屏蔽的信号集
					如果该参数为空,则啥也不会带出;
		函数功能：
			主要用于提取/修改当前进程中的信号屏蔽集合;


		注意：
			信号屏蔽并不是信号的删除，只是相当于用一个隔板将所有屏蔽的信号阻挡起来
		  对于可靠信号来说,发送多少次则排队等待的就是多啥个信号;
		  对于不可靠信号来说，无论发送多少次,排队等待的信号只有1个；
		当信号屏蔽被解除时,相当于将阻挡的隔板移开,因此所有阻挡的信号都会被以此处理;
		/*信号从大到小处理*/



		(2)sigpending函数		// ???

   		   #include <signal.h>
    	   int sigpending(sigset_t *set);



		函数功能：
			只要用于获取信号屏蔽期间来过但没有来得及处理的信号,将所有获取到的信号
		  存放在参数指定的信号集set中,通过参数带出去;
	




		1.3 sigaction函数 => signal函数的增强版
       #include <signal.h>
       int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);

		
		第一个参数：信号值/信号名称(设置哪个信号的处理方式)
			可以指定任何有效的信号,但是不能指定 SIGKILL 和 SIGSTOP

		第二个参数：结构体指针,用于指定信号的最新处理方式
		
        struct sigaction {
          void     (*sa_handler)(int);//与下面的sa_sigaction 二者选其一
				
				=>函数指针类型,主要用于设置信号的处理方式
				=>取值可以是：SIG_DFL SIG_IGN 自定义函数地址
				=>与signal函数的第二个参数取值一样,类型一样
          void     (*sa_sigaction)(int, siginfo_t *, void *);
				
				=> 函数指针类型,主要用于设置信号的处理方式
				=> 取值可以是：SIG_DFL SIG_IGN 自定义函数地址
				=> 是否选用该成员设置信号的处理方式,取决于第四个成员
				
          sigset_t   sa_mask;
			    => 主要用于设置在执行信号处理函数期间需要屏蔽的信号集
				=> 自动屏蔽与出发信号处理函数相同的信号(除非flag中设置SA_NODEFER)
          int        sa_flags;
			  =>取值为 SA_SIGINFO  表示选择第二个函数指针作为信号的处理函数
			  =>       SA_NODEFER	 表示解除对触发信号处理函数信号的屏蔽 
			  =>		 SA_RESETHAND 表示一旦调用信号处理函数则回复默认处理方式
          void     (*sa_restorer)(void); 
			  => 过时/保留的成员,暂时不被使用
        };
	

		第三个参数：结构体指针,用于带处设置之前的信号处理方式
		
		函数功能：
			主要用于检查和修改指定信号的处理方式;



		其中结构体中第二个成员中的第二个参数类型如下：
			
           siginfo_t {
				... ...
               pid_t    si_pid;      /* Sending process ID */
               sigval_t si_value;    /* Signal value(伴随信号到来的附加数据)*/
				... ...
           }




		1.4 sigqueue函数
	       #include <signal.h>
    	   int sigqueue(pid_t pid, int sig, const union sigval value);

			第一个参数：进程的编号(给谁发信号)
			第二个参数：具体的信号值/信号名称(发送生么样的信号)
			第三个参数：伴随信号的附加数据
				
	           union sigval {
    	           int   sival_int;
    	           void *sival_ptr;
    	       };

		函数功能：
			主要用于想指定的进程发送指定的信号和附加数据：
		


		1.5 计时器(/*让贪吃蛇动起来*/)
			在linux系统中,为每个进程都维护三种计时器,分别为：真实计时器、
		虚拟计时器、以及实用计时器,一般采用真实计时器进行计时;

//			setitimer

       #include <sys/time.h>

       int getitimer(int which, struct itimerval *curr_value);
       int setitimer(int which, const struct itimerval *new_value,
                     struct itimerval *old_value);


		第一个参数：计时器的类型(选用哪一种计时器)
			ITIMER_REAL 	-真实计时器,统计进程执行的真实时间;
							-该计时器通过产生SIGALRM信号进行工作的;

			ITIMER_VIRTUA	-虚拟计时器,统计进程在用户态消耗的时间
							-该计时器通过产生SIGVTALRM信号进行工作的;

			ITIMER_VIRTUA 	-实用计时器,统计进程在用户态和内核态下共同消耗的时间
							-该计时器通过产生SIGPROF信号进行工作；

		第二个参数：结构体指针,用于设置计时器的新值。

           struct itimerval {
               struct timeval it_interval; /* next value(间隔时间) */
               struct timeval it_value;    /* current value(启动/开始时间) */
           };

           struct timeval {
               long tv_sec;                /* seconds */
               long tv_usec;               /* microseconds(1微秒) = 10^-6 */
           };


		第三个参数：结构体指针,用于带出计时器之前的旧值。

		函数功能：
			主要用于获取/设置计时器的参数信息；






	2. 进程见的通信技术
	2.1 基本概念
		两个进程之间的信息交互 叫做进程见的通信；

	2.2 常用的进程间通信技术
		(1)文件
		(2)信号
		(3)管道(了解)
		(4)共享内存
		(5)消息队列(重点)
		(6)信号量集
		(7)网络(重点)
		... ...
		其中(4)(5)(6)三种通信方式统称为 XSI IPC通信方式
		(X/open System Interface Inter-Process Communication)




	作业：
		使用计时器技术让控制台版的贪吃蛇动起来；




/**************************************************************************/
*															    		  *	
*								day_13					   				  *	
*									   									  *
/**************************************************************************/



			
		
		
	
						/*进程间的通信*/

	1. 使用管道实现进程间的通信
	1.1 基本概念
		管道本质上就是文件,只是一种比较特殊的文件

		管道分为两种：有名管道 和 无名管道
		
		有名管道		-可以用于任意两个进程间的通信；
		无名管道		-只能用于父子进程之间的通信；

	1.2 使用有名管道实现进程间的通信
	
		使用 mkfifo命令/函数来创建有名管道

			如：
				touch a.txt  => 创建普通文件a.txt

				ls -l a.txt	 => 查看文件的详细信息,文件的类型是 - ,表示普通文件

				echo hello > a.txt

				cat a.txt   显示hello

				/*------------------------------------------*/

				mkfifo a.pipe  创建管道文件
		 
				ls -l a.pipe  文件类型为p 表示管道文件,并且拥有 迷の黑色阴影

				echo hello > a.pipe  写入是阻塞的,写不进去 
				
				另起终端执行	cat a.pipe		 读取到内容hello 上个终端阻塞解除


//			mkfifo函数
       #include <sys/types.h>
       #include <sys/stat.h>

       int mkfifo(const char *pathname, mode_t mode);


			第一个参数：字符串形式的路径名
			第二个参数：具体的权限信息,如 0664

		函数功能：
			主要用于创建一个指定的有名管道文件；






		注意：
			管道的特殊性就在于仅仅作为进程间通信的媒介,但是管道本身并不会
		  存放任何数据；

	

	1.3 使用无名管道实现进程间的通信


       #include <unistd.h>
       int pipe(int pipefd[2]);



		函数功能；
			主要用于创建无名管道,提供一个单向的数据通道实现进程间的通信，
		  通过参数带出两个文件描述符,其中pipefd[0]代表管道的读端
		  pipefd[1]代表管道的写端



	2. 使用共享内存实现进程间的通信
	2.1 基本概念
		共享内存本质就是一块由系统内核维护的内存空间,而该内存空间可以共享在
	  两个进程之间，两个进程通过读写该内存区域从而实现通信;

	2.2 通信的模型
		(1)获取key值,			ftok函数
		(2)创建/获取共享内存,	shmget函数
		(3)挂接共享内存			shmat函数
		(4)使用共享内存
		(5)脱接共享内存			shmdt函数
		(6)如果不再使用,则删除,	shmctl函数


	2.3 相关函数的解析
		
		(1) ftok函数

       #include <sys/types.h>
       #include <sys/ipc.h>
       key_t ftok(const char *pathname, int proj_id);


		第一个参数：字符串形式的路径名,要求文件存在并且可以访问。
		第二个参数：项目的编号,要求非0,只取低8位二进制位

		返回值：成功返回生成的key_t值,失败返回-1；

		函数功能：
			主要用于根据参数的指定来生成一个key值,便于后续函数使用.


		注意：
			使用相同的路径名和相同的项目编号时,最终生成的key值也相同；



		(2)shmget函数	(/*- allocates a shared memory segment */)
       #include <sys/ipc.h>
       #include <sys/shm.h>
       int shmget(key_t key, size_t size, int shmflg);
		
		第一个参数；key值，ftok函数的返回值
		第二个参数；具体的共享内存大小
			0	-获取已经存在的共享内存
		第三个参数：具体的操作标志
			IPC_CREAT	-如果不存在则创建,存在则打开
			IPC_EXCL	-与IPC_CREAT搭配使用，如果存在则创建失败
				0		-获取已经存在的共享内存

		返回值：成功返回共享内存的ID，失败返回-1；
		
		函数功能：
			主要用于创建/获取一个指定的共享内存；

		注意：
			当使用该函数创建新的共享内存时,需要在第三个参数中指定该共享内存的权限
		  信息,如：0664,指定的方式为按位或运算;

	
		(3)shmat函数
		
       #include <sys/types.h>
       #include <sys/shm.h>

       void *shmat(int shmid, const void *shmaddr, int shmflg);
       
		第一个参数：共享内存的ID,shmget函数的返回值
		第二个参数：具体的挂接地址,给 NULL 则由系统选择位置
		第三个参数：挂接的标志,默认给0即可

		返回值：成功返回挂接的起始地址，失败返回(void*)-1;


		函数功能：
			主要用于将shmid指向的共享内存挂接到当前进程的地址空间中

		(4)shmdt函数
       #include <sys/types.h>
       #include <sys/shm.h>	
       int shmdt(const void *shmaddr);
	
		函数功能：
			主要用于脱接参数指定的共享内存,参数为shmat函数的返回值。



		(5)shmctl函数

       #include <sys/ipc.h>:
       #include <sys/shm.h>
       int shmctl(int shmid, int cmd, struct shmid_ds *buf);

		第一个参数：共享内存的ID，shmget函数的返回值；
		第二个参数：具体的操作命令
			IPC_RMID	-删除共享内存,此时第三个参数给NULL即可
		地三个参数：结构体指针(NULL)

		函数功能：
			主要用于对指定的共享内存段执行指定的操作；


		/*		ipcs -m	可以查看共享内存数量	
				ipcrm -m shmid 可以删除指定共享内存				

		*/




	2.4 常用的基本命令
		ipcs -m		表示查看当前系统中存在的共享内存段；
		ipcrm -m shmid  	表示删除指定的共享内存； 





	3. 使用消息队列实现进程间的通信(/*重点*/)
	3.1 基本概念
		将通信的数据打包成消息,使用两个不同的进程分别发送消息到消息队列中 和 接收
	  消息队列中的消息,从而实现通信；


	3.2 基本模型
		(1)获取key值,		使用ftok函数;
		(2)创建/获取消息队列		msgget
		(3)发送/接收消息 		msgsnd/msgrcv 
		(4)如果不在使用,则删除	msgctl

	3.3 相关函数的解析
		
		(1)msgget函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgget(key_t key, int msgflg);

		第一个参数：key值,ftok函数的返回值
		第二个参数：具体的操作标志
			IPC_CREAT		-如果不存在则创建,存在则打开
			IPC_EXCL		-与IPC_CREAT搭配使用,如果存在则创建失败
				0			-获取已经存在的消息队列

		返回值： 成功返回消息队列的ID，失败返回-1

		函数功能：
			主要用于创建/获取消息队列；

		注意：
			当创建新的消息队列时,需要在第二个参数中指定权限信息，
			如0664，指定的方式为按位或运算;




		(2)msgsnd函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);


		第一个参数：消息队列的ID,msgget函数的返回值
		第二个参数：消息的起始地址,该指针指向的消息格式如下：

           struct msgbuf {
               long mtype;       /* message type, must be > 0 */
               char mtext[1];    /* message data(可选其他数据类型) */
           };

		第三个参数：消息的大小
			//该参数的大小仅仅包括消息内容的大小,不包括消息类型的大小
		第四个参数：发送的标志,默认给 0，表示发送不出去时阻塞
			//IPC_NOWAIT   -表示发送不出去时不会产生阻塞
		函数功能：
			主要用于想指定的消息队列中发送指定的消息；



		(3)msgrcv函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
						int msgflg);
		
		第一个参数：消息队列的ID,msgget函数的返回值
		第二个参数：存放消息的缓冲区首地址
		第三个参数：期望接受的消息大小
		第四个参数：期望接受的消息类型
		/*
				 0 	-表示始终读取消息队列中的第一个消息
				>0	-表示始终读取消息对垒中第一个类型为msgtyp的消息
				<0 	-表示读取消息队列中第一个类型 <= msgtyp绝对值的消息
					  其中最小类型的消息优先读取;
		*/				

		第五个参数：具体的接收标志,默认给 0 即可

		返回值：成功返回实际读取的数据大小,失败返回-1；
	
		函数功能：
			主要用于从指定的消息队列中接收消息,并放在指定的缓冲区中；
		

		(4)msgctl函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgctl(int msqid, int cmd, struct msqid_ds *buf);
		

		第一个参数：消息队列的ID，shmget函数的返回值；
		第二个参数：具体的操作命令
			IPC_RMID	-删除消息队列,此时第三个参数给 NULL 即可
		地三个参数：结构体指针(NULL)

		函数功能：
			主要用于对指定的消息队列执行指定的操作；
/*
			ipcs -q		查看存在的消息队列
			ipcrm -q qid 删除指定的消息队列
*/


/**************************************************************************/
*															    		  *	
*								day_14					   				  *	
*									   									  *
/**************************************************************************/


		
	
	1. 使用信号量集实现进程间的通信
	1.1 基本概念
	  (1) 什么是信号量？？？
		信号量本质就是一种计数器,主要用于控制同时访问同一种共享资源的进程/线程个数;
	
	  (2) 什么是信号量集？？？
		信号量集本质就是信号量的集合,主要用于控制多种共享资源分别同时被访问的
	  进程/线程个数。



	1.2 信号量的工作方式
		(1)初始化信号量为最大值
		(2)如果有进程申请到了一个共享资源,则信号量的数值减1;
		(3)当信号量的数值为0时,申请共i轩昂资源的进程进入阻塞状态;
		(4)如果有进程释放了一个共享资源,则信号量的数值加1；
		(5)当信号量的数值 >0 时,等待申请共享资源的进程可以继续抢占共享资源,抢不到
		  共享资源的进程继续阻塞；
	



	1.3 使用信号量集实现进程间通信的模型
		(1)获取key值,		ftok
		(2)创建/获取信号量集 semget
		(3)初始化			semctl
		(4)操作信号量集控制进程/线程个数 semop
		(5)如过不再使用则删除 semctl


	1.4 相关函数的解析
		(1)semget函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>
       int semget(key_t key, int nsems, int semflg);

		第一个参数：key值,ftok函数的返回值
		第二个参数：信号量集的大小,也就是信号量的个数
			0 	-获取已经存在的信号量集
		地三个参数：具体的操作标志
			IPC_CREAT	-如果不存在则创建,存在则打开 	
			IPC_EXCL	-与IPC_CREAT搭配使用，若存在则创建失败
			0			-获取已经存在的信号量集

		返回值：成功返回信号量集的ID,失败返回-1；
		
		函数功能：
			主要用于创建/获取信号量集；

		注意：
			当创建新的信号量集时,需要指定权限信息,如：0664,
		  指定的方式为按位或在第三个参数中；


		(2)semctl函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>
       int semctl(int semid, int semnum, int cmd, ...);


		第一个参数：信号量集的ID,semget函数的返回值;
		第二个参数：信号量集的下标,从0开始
		第三个参数：具体的操作命令
/*
			IPC_RMID 	-删除整个信号量集,忽略sumnum,不需要第四个参数；
			SETVAL	-使用第四个参数的值来初始化下标为semnum的信号量
*/
		第四个参数：可边长参数,是否需要取决于cmd

		函数功能：
			主要用于对之i的那个的信号量集执行指定的操作；



		(3)semop函数
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/sem.h>
       int semop(int semid, struct sembuf *sops, unsigned nsops);

		第一个参数：信号量集的ID,semget函数的返回值
		第二个参数：结构体指针,可以指向结构体变量,也可以指向数组
			struct sembuf{
	           unsigned short sem_num;  /* semaphore number(下标) */
	           short          sem_op;   /* semaphore operation(正增负减0不变)*/
	           short          sem_flg;  /* operation flags(默认给0) */				
			}

		第三个参数：当结构体指针指向数组时,该参数表示数组元素个数；

		函数功能：
			主要用于操作指定的信号量;
/*
		ipcs	-s		表示查看西哦他那个中已经存在的信号量集
		ipcrm -s semid	 表示删除指定的信号量集
		ipcs	-a 表示查看系统中所有ipc结构,包括共享内存,消息队列,信号量集；

*/




	2. 综合小项目
	2.1 项目的名称
		银行账户管理系统(模拟ATM)

	2.2 项目的功能
 		开户、销户、存款、取款、查询、转帐、

	2.3 项目的架构
		采用C/S架构进行设计(Client客户端/Server服务器)
		
	  	客户端： 提供界面让用户选择具体的业务,将用户选择的业务编号发送给服务器
				 进行处理,等待服务器的处理结果并现实给客户;
				 
		服务器：根据客户端传来的业务编号,通过访问数据库的方式进行处理,并将最终的
				处理结果发送给客户端即可；

	2.4 项目的设计和分析
		(1)如何实现客户端和服务器之间的通信呢？？？
			采用两个消息队列实现进程间的通信;
				消息队列一：	客户端 => 服务器
				消息队列二： 服务器 => 客户端
		
		(2)如何区分不同的业务编号呢？？？
			采用消息的类型来区分不同的业务编号,需要8中类型：
				6 种业务编号 + 成功 + 失败               

		(3)如何设计账户和消息的数据类型呢？？？
			账户信息：帐号、账户名称、账户密码、余额；
			采用结构体类型来设计账户和消息的数据类型；
			使用账户信息的结构体变量作为消息的数据内容；

		(4)以开户为例 分析项目的执行流程

			客户端：
				a.绘制字符界面,供用户选择具体的业务编号; 
					=> printf函数打印
				b.根据用户的选择,进入不同的业务分支进行处理
					=> 使用scanf 接收输入，使用switch-case结构进入不同的分支；
				c.提示用户输入开户的信息(不需要输账号信息)
					=> 使用结构体变量来保存用户的输入
				d.打包用户输入的信息到消息的结构体变量中,发送给服务器
					=> 设置消息的类型为1,代表开户业务
					=> 使用smgsnd函数将消息发送到消息队列一中
				e.接收消息队列二中的消息,并显示处理结果；
					=> 使用msgrcv函数接收消息
					=> 如果消息的类型为7,则表示处理成功
					=> 如果消息的类型为8,则表示处理失败

			服务器：
				a.创建两个消息队列,作为服务器的初始化工作
					=> 使用ftok函数生成key值,msgget函数创建；
				b.接收客户端发来的消息,根据业务编号进行处理;
					=> 使用msgrcv函数接收消息队列一中的消息
					=> 判断消息类型是否为1,若是 则表示开户业务
				c.自动生成一个帐号补充完整客户账户信息;
					=> 调用generator_id函数自动生成帐号
				d.保存账户信息到文件中,并判断是否保存成功：
					=> 每个账户信息都保存在一个独立的文件中
					=> 采用帐号作为文件名来确保唯一性,使用sprintf函数

				e.根据处理结果修改消息的类型,并发送给客户端
					=> 如果处理成功,则修改消息的类型为7
						       失败                 8
					=> 使用msgsnd函数将消息发送到消息队列二中
				f.要求服务器不断的运行,知道按下ctrl+c才能关闭服务器;
					=> 使用无限循环保证服务器不停的工作
					=> 使用signal函数对信号SIGINT(2)进行自定义处理
					=> 通过信号处理机制来删除两个消息队列,使用msgctl函数
				


	2.5 项目要求
		(1)要求采用多函数多文件的防护死编码,并支持Ｍakefile文件
		(2)要求实现开户功能即可,有余力的同学实现所有功能；


	2.6 项目的提示
		vi bank.h	-编写结构体的定义等公共代码
		vi client.c	-编写客户端的功能代码,打印界面的函数等
		vi server.c -编写服务器的功能代码,创建消息队列的函数等
		vi dao.c	-编写自动生成帐号的函数代码等
		... ...			




/**************************************************************************/
*															    		  *	
*								day_15					   				  *	
*									   									  *
/**************************************************************************/




		
	1. 网络相关的基本常识
	
		目前主流的网络通讯软件主要有：QQ、微信、飞信、	

	
	1.1 七层网络协议模型和常用的网路协议
		(1)七层网络协议模型
			一般来说,ISO将数据的传递从逻辑上划分为一下七层：

			应用层：将具体的数据内容传递给应用程序,如：QQ
			表示层：将数据内容按照统一的格式进行打包和封装;
			会话层：控制对话合适开始，合适终止等；
			传输层：进行错误检查和重新排序等；
			网络层：选择具体的网络协议进行再次打包和发送
			数据链路层：将具体的数据包转换为高低电平信号
			物理层：主要指具体的交换机等物理设备


		(2)常用的网络协议
			a.TCP协议   -传输控制协议,是一种面向链接的协议,类似打电话;
			b.UDP协议	-用户数据报协议,是一种非面向链接的协议,类似写信;
			c.IP协议		-互联网协议,是上述两种协议的底层协议；



	1.2 IP地址和子网掩码(重点)
		(1)IP地址 	-本质就是互联网中的唯一地址标识；
			  	是由32位二进制组成的整数(ipv4),也有128位二进制组成的整数(ipv6)

/*			查看IP地址：
				Window系统中：在dos窗口中使用 ipconfig 命令
				Linux系统中： 在终端中使用    ifconfig命令
								(如果不好使则使用/sbin/ifconfig命令即可)
				
*/

		日常生活中采用点分十进制表示法来描述IP地址,不同的整数之间采用小数点分隔。

		如：
			0x01020304	=>  1.2.3.4

		为了便于IP地址的管理,将IP地址分为两部分：网络地址+主机地址,根据网络地址
	和主机地址位数不同分为以下4类：

			A类：0 + 7 位网络地址 +24 位主机地址	
			B类：10 + 14 位网络地址 + 16 位主机地址
			C类：110 + 21 位网络地址 + 8 位主机地址	
			D类：1110 + 28 位多播地址 	

		

		(2)子网掩码
			主要用来划分IP地址中的网络地址和主机地址,也可以用于判断两个IP地址
		  是否在同一个局域网中,具体的划分方法为：
		
				IP地址  &  子网掩吗  =  网络地址;
				
			如：IP地址 172.30.100.64
			  子网掩码 255.255.255.0
					  ---------------
					   172.30.100	-网络地址



	1.3 端口号和字节序
		(1)端口号
				IP地址		-定位到具体的某一台主机/设备上；
				端口号		-定位到主机/设备上的某一个进程；

		  		网络编程中需要提供两个信息：	IP地址 + 端口号

				端口号本质上就是unsigned short类型,范围是：0 ~ 65535
					其中0 ~ 1024 之间的端口号被系统占用,建议从1025开始使用；

		(2)字节序
				小端系统：主要指将低位数据保存在低位内存地址的系统

				大端系统：将低位数据保存在高位内存地址的系统；
		
				如：0x12345678
					小端系统按照内存地址从小到大： 0x78 0x56 0x34 0x12
					大端系统按照内存地址从小到大： 0x12 0x34 0x56 0x78


			一般性原则：
				一般来说,将所有发送到网络中的多字节整数先转换为网络字节序再发送,
			  而将所有从网络中接受过来的多字节整数,先转换为主机字节序再解析,其中
			  网络字节序本质就是大端系统痛的字节序；
			/*多字节整数不不扩：char float double */

		  

	2. 基于socket的一对一通信模型
	2.1 基本概念
			socket 本意为"插座" ，在这里指用于同性的逻辑载体；
		
	2.2 通信模型

			服务器：
					(1)创建socket,使用socket函数;
					(2)准备通信地址,使用结构体类型;
					(3)绑定socket和通信地址,使用bind函数;
					(4)进行通信,使用read/write函数
					(5)关闭socket,使用close函数；

			客户端：
					(1)创建socket,使用socket函数
					(2)准备通信地址,使用服务器的地址
					(3)链接socket和通信地址, 使用connect
					(4)进行通信,使用read/write函数
					(5)关闭socket，使用close函数


	2.3 相关函数的解析
		(1)socket函数
	       #include <sys/types.h>          /* See NOTES */
	       #include <sys/socket.h>
	
	       int socket(int domain, int type, int protocol);
			
				第一个参数：域/协议族,决定了本地通信还是网络通信
/*
		       AF_UNIX / AF_LOCAL   Local communication (同一主机内通信)
		       AF_INET             IPv4 Internet protocols(不同主机之间)
		       AF_INET6            IPv6 Internet protocols(暂时用不上)
*/			
				第二个参数：通信的类型
/*			
       SOCK_STREAM     -提供有序的,可靠的,双向的,面向连接的字节的字节流通信方式
						基于TCP协议的通信方式
       SOCK_DGRAM      -提供的不可靠的,非面向连接的数据报通信方式
						基于UDP协议的通信方式
*/
				第三个参数：特殊的协议,默认给0
					
			
			返回值：成功返回i新的socket描述符,失败返回-1

			函数功能：
				主要用于创建可以实现通信的交流点,也就是socket通信载体；

		(2)通信地址的数据类型
			a. struct sockaddr类型
           struct sockaddr {
               sa_family_t sa_family;
               char        sa_data[14];
           }

			-该结构体类型主要用于函数的形参类型,基本不会定义变量使用


			b. struct sockaddr_un类型//本地
     		  #include <sys/un.h>

			struct sockaddr_un{
              sa_family_t  sun_family; // Address family.
              char         sun_path[]; // Socket pathname.
			}
			-该结构主要用于实现本地通信的通信模型中；


			c.struct sockaddr_in类型 //网络
   		   	 #include <netinet/in.h>
			struct sockaddr_in{
              sa_family_t     sin_family;  // AF_INET.
              in_port_t       sin_port;     //Port number.
              struct in_addr  sin_addr;     //IP address.
			}
			其中 
				struct in_addr{
				   in_addr_t  s_addr;//整数类型的ip地址
				}
				-该结构体主要用于实现不同主机之间的网络通信模型中;


		(3)bind函数
	       #include <sys/types.h>          /* See NOTES */
	       #include <sys/socket.h>

	       int bind(int sockfd, const struct sockaddr *addr,
	                socklen_t addrlen);

			第一个参数：socket描述符,socket函数的返回值;
			第二个参数：结构体指针,可能需要做类型转换
			第三个参数：通信地址的大小,使用sizeof计算即可

			函数功能：
				主要用于绑定socket和具体的通信地址;



		(4)connect
    	   #include <sys/types.h>          /* See NOTES */
    	   #include <sys/socket.h>

    	   int connect(int sockfd, const struct sockaddr *addr,
	                   socklen_t addrlen);


			函数功能：
				主要用于链接socket和指定的通信地址,参数和返回值参考bind函数。


		(5)字节序的转换函数
       #include <arpa/inet.h>
       uint32_t htonl(uint32_t hostlong); 
			=>32 位二进制 主机字节序 转 网络字节序
       uint16_t htons(uint16_t hostshort);
			=>16 位二进制 主机字节序 转 网络字节序
       uint32_t ntohl(uint32_t netlong);
			=>32 位二进制 网络字节序 转 主机字节序
       uint16_t ntohs(uint16_t netshort);
			=>16 位二进制 网络字节序 转 主机字节序


		(6)IP地址的转换函数
       #include <sys/socket.h>
       #include <netinet/in.h>
       #include <arpa/inet.h>

       in_addr_t inet_addr(const char *cp);
			IP地址 字符串类型 => 整数类型

       char *inet_ntoa(struct in_addr in);
			IP地址 整数类型 => 字符串类型








/**************************************************************************/
*															    		  *	
*								day_16					   				  *	
*									   									  *
/**************************************************************************/




					
	1. 基于TCP协议的通信模型(/*重点*/)
	1.1 通信模型
			
		服务器：
				(1)创建socket,使用socket函数；
				(2)准备通信地址,使用结构体类型;
				(3)绑定socket和通信地址,使用bind函数;
				(4)监听,使用listen函数;
				(5)响应客户端的连接请求, accept
				(6)进行通信,使用send/recv函数：
				(7)关闭socket,使用close函数;

		客户端：
				(1)创建socket,使用socket函数；
				(2)准备通信地址,使用服务器的地址;
				(3)连接socket和通信地址,使用connect函数;
				(4)进行通信,使用send/recv函数：
				(5)关闭socket,使用close函数;

	1.2 相关函数的解析
		(1)listen函数
	       #include <sys/types.h>          /* See NOTES */
	       #include <sys/socket.h>

	       int listen(int sockfd, int backlog);

			第一个参数：socket描述符,socket函数的返回值
			第二个参数：用于指定悬而未决的连接队列的最大长度
						(已经发送连接请求,但是没有来得及响应的最大数量)
		
			函数功能：
				主要用于监听指定socket上的连接请求,当调用该函数后,该函数会将
			  sockfd所指向的socket标记为被动socket，所谓的被动socket就是专门
		  	  用于使用accept函数接收即将到俩的连接请求,也就是不能用来通信了。


		(2)accept函数
    	   #include <sys/types.h>          /* See NOTES */
    	   #include <sys/socket.h>

	       int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

			第一个参数：socket描述符，socket函数的返回值
			第二个参数：结构体指针,用于带出接受的客户端通信地址
			第三个参数：指针类型,用于带出通信地址的大小
			
			返回值：成功返回用于通信的socket描述符,失败返回-1

			函数功能：
				主要用于提取listen函数标记的socket中,悬而未决队列中第一个连接请求
			  创建一个新的socket用于和接受的客户端进行通信,该socket并不会处于
		  	  监听的状态;
	

		(3)send函数
	       #include <sys/types.h>
	       #include <sys/socket.h>
	
	       ssize_t send(int sockfd, const void *buf, size_t len, int flags);

		第一个参数：socket描述符,accept函数的返回值
		第二个参数：具体的缓冲区首地址(存放的是即将发送的数据内容)
		第三个参数：即将发送的数据大小
		第四个参数：发送的标志,默认给 0 即可

		返回值：成功返回实际发送的数据大小,失败返回-1

		函数功能：
			主要用于将指定的消息发送到指定的socket上;

		(4)recv函数
	       #include <sys/types.h>
	       #include <sys/socket.h>
	
	       ssize_t recv(int sockfd, void *buf, size_t len, int flags);
		第一个参数：socket描述符,accept函数的返回值
		第二个参数：缓冲区的首地址,用于存放接收到的消息
		第三个参数：期望接收的数据大小
		第四个参数：具体的接收方式,默认给 0 

		返回值：成功返回实际接收的数据大小,失败返回-1;
				当对方关闭时,该函数的返回值为 0;

		函数功能：
			主要用于从指定的socket上接收指定的消息；


	练习：
		使用基于tcp协议的通信模型实现一对多的通信：
	  a.要求服务器可以不断地响应客户端的连接请求
			=> 使用无限循环
	  b.要求服务器可以同时和多个客户端通信
			=> 使用fork函数创建子进程来实现和客户端的通信
	  c.要求服务器可以和每个客户端都可以不断的通信
			=> 无限循环
	  d.当客户端发来"bye"时,表示客户端已下线
			=> 使用strcmp函数比较,终止对应的子进程
	  e.要求服务器不停的工作,知道用户按下ctrl+c；
			=> 使用signal函数实现对SIGINT的自定义处理





	2. TCP协议和UDP协议的比较
	2.1 TCP协议的概念和特性(Transfer Control Protocol)
		TCP 	-传输控制协议,是一种面向连接的协议,类似打电话
			-建立连接 => 进行通信 => 断开连接
			-在通信的整个过程中全程保持连接。
			-该协议保证了数据传递的可靠性和有序性.
			-实现了流量的控制,避免发送方发送过多数据导致接收方缓冲区溢出;	
			-属于全双工的字节流通信方式;	

		  	-服务器压力比较大,资源消耗比较高,执行效率比较低


	2.2 UDP协议的概念和特性
		UDP		-用户数据包协议,非面向连接的协议,类似写信
			-在通信的整个过程中不需要保持连接
			-不保证数据传递的可靠心和有序性
			-没有实现流量的控制
			-属于全双工的数据报通信方式;
			-服务器压力比较小,资源消耗比较低,执行效率比较高.
			


	3. 基于UDP协议的通信模型(/*重点*/)
	3.1 通信模型
		服务器：
				(1)创建socket,使用socket函数
				(2)准备通信地址，使用结构体类型;
				(3)绑定socket和通信地址,使用bind
				(4)进行通信,使用send/recv/sendto/recvfrom函数
				(5)关闭socket，使用close函数

		客户端：
				(1)创建socket,使用socket函数
				(2)准备通信地址，使用服务器地址;
				(3)进行通信,使用send/recv/sendto/recvfrom函数
				(4)关闭socket，使用close函数
	
	3.2 相关函数的解析
		(1)sendto函数
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);


		
		函数功能：
			主要用于将指定的消息发送到指定的目标地址上,其中前四个参数以及返回值
		  和send函数完全一致,第五个参数用于指定收件人的通信地址信息,第六个参数
		  用于指定通信地址的大小;


		(2)recvfrom函数
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,/*0*/
                        struct sockaddr *src_addr, socklen_t *addrlen);


		函数功能：
			主要用于接收发来的消息,并保存消息发送方的通信地址,其中前四个参数以及
		  返回值和recv函数完全一致,第五个参数用于保存消息发送方的通信地址,第六个
		  参数用于保存通信地址的大小.


		

		作业：
			使用UDP协议的同性模型编写一个时间服务器,也就是只要服务器受到客户端发来的消息，则将本机系统时间发送给客户端;






/**************************************************************************/
*															    		  *	
*								day_17					   				  *	
*									   									  *
/**************************************************************************/




	1. 多线程的基本概念和基本操作
	1.1 基本概念
		目前主流的操作系统都支持多进程，而每一个进程的内部又可以支持多线程,也就是说
	  线程是隶属于进程内部的程序流,同一个进程中的多个线程并行处理;

		进程是重量级的，每个进程都需要独立的内存空间，因此新建进程对于资源的消耗
	  比较大；而线程是轻量级的，新建线程会共享所在进程的内存资源，但是每个线程
	  都拥有一块独立的栈区；

	1.2 线程的创建
		(1)pthread_create函数
       #include <pthread.h>

       int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);


		第一个参数：用于存放新线程的编号；
		第二个参数：用于指定线程的属性，给 NULL 表示采用默认属性；
		第三个参数：函数指针类型，用于指定新线程的处理函数；
		第四个参数：指针类型,用于给第三个参数指向的函数传递实参；

		返回值：成功返回0，失败返回具体的错误编号；//strerror 将参数指定的错误编号进行翻译

		函数功能：
			主要用于在当前正在调用的进程中启动一个新线程；

      // Compile and link with -pthread.

		(2)线程之间的关系
		  执行main函数的起始线程 叫做 主线程；
		  使用pthread_create函数创建出来的新线程 叫做 子线程
		  当子线程创建成功后,两个线程各自独立运行，子线程执行对应的线程处理函数
		，主线程继续向下执行，两个线程之间的执行先后次序有操作系统调度算法决定；
			
		  两个线程之间相互独立，又相互影响，当主线程结束时，会导致整个进程结束；
		  当整个进程结束时，又会导致所有线程结束；

			typedef unsigned long int pthread_t;

	//printf("主线程中：tid = %lu,主线程自己的ID = %lu\n",tid,pthread_self());

	1.3 线程编号的获取和比较
		(1)pthread_self函数
       #include <pthread.h>

       pthread_t pthread_self(void);

		函数功能：
			主要用于获取当前正在调用线程的编号,并通过返回值返回；
      // Compile and link with -pthread.


		(2)pthread_equal函数
       #include <pthread.h>

       int pthread_equal(pthread_t t1, pthread_t t2);

	   //  Compile and link with -pthread.

		函数功能：
			主要用于比较两个参数指定的线程ID是否相等,如果相等则返回非0，否则返回0


	练习：
		使用pthread_create函数创建一个子线程，在子线程的线程处理函数中根据参数传入
	  的半径计算周长和面积并打印出来,而其中存放半径的内存空间有main函数中调用sbrk
	  函数申请，并由用户手动输入；



	1.4 线程的等待和分离
		(1)pthread_join函数
		
       #include <pthread.h>

       int pthread_join(pthread_t thread, void **retval);
		
		第一个参数：具体的线程ID
		第二个参数：用于获取线程的推出状态信息
		

		函数功能：
			主要用于等待参数thread指定的线程终止，如果参数thread指向的线程终止了，
		  则该函数立即返回，当然要求该线程必须是可汇合的/可等待的；
			如果第二个参数不为空,则该函数会将目标线程的推出状态信息拷贝到*retval
		  指向的位置中，也就是以及指针的内容；
		

       	// Compile and link with -pthread.		


	练习：
		使用pthread_create函数创建子线程,在线程处理函数中计算1~100之间的和并放到
	  变量sum中,返回sum变量的地址,在主线程中调用pthread_join函数等待子线程结束，
	  并获取退出状态信息,打印出来
		vi 04join.c


		(2)pthread_detach函数
       #include <pthread.h>

       int pthread_detach(pthread_t thread);

		函数功能：
			主要用于将参数指定的线程设置为分离状态的线程,当一个分离状态的线程
		  终止时,它的资源会被自动释放给系统,不需要其它线程来汇合/帮助,即分离状态
		  的线程无法被pthread_join函数所等待/汇合；

      // Compile and link with -pthread.

	

	1.5 线程的终止和取消
		(1)pthread_exit函数
       #include <pthread.h>

       void pthread_exit(void *retval);

		函数功能：
			主要用于终止当前正在调用的线程，并通过参数返回当前线程的退出状态
	信息,可以使用同一个进程中的其他线程调用pthread_join函数来获取该退出状态信息；

      // Compile and link with -pthread.


	练习：
		vi 05exit.c 启动子线程，子线程的线程处理函数中负责打印1-20之间的整数，每隔1秒打印一次,当i的值为10时，终止当前线程，并返回i的数值，主线程负责等待并获取推出状态信息，最后打印出来；
	


		(2)pthread_cancel函数
       #include <pthread.h>

       int pthread_cancel(pthread_t thread);

		函数功能：
			主要用于给参数指定的线程发送取消的请求，默认情况下是可以被取消的，
		  是否被取消以及何时被取消可以通过以下两个函数进行设置；
      	
		 int pthread_setcancelstate(int state, int *oldstate);
			第一个参数：用于指定最新的状态 
				PTHREAD_CANCEL_ENABLE 	-可以被取消(默认)
			    PTHREAD_CANCEL_DISABLE	-不可以被取消

			第二个参数：用于带出设置之前的状态信息,给 NULL 表示不带出

       	 int pthread_setcanceltype(int type, int *oldtype);
			第一个参数：用于指定线程的新类型
				PTHREAD_CANCEL_DEFERRED			-延迟取消(默认)
				PTHREAD_CANCEL_ASYNCHRONOUS		-立即取消
			第二个参数：用于带出旧类型，不想带出给 NULL 即可;
						

		//  Compile and link with -pthread.





	2. 线程的同步问题
	2.1 基本概念
		多线程共享所在进程的资源，当多个线程同时访问同一种共享资源时，需要相互协调
	  以避免造成数据的不一致和不完整问题，而线程之间的协调和通信叫做线程的同步问题


	2.2 使用互斥量实现线程的同步
		(1)定义互斥量
			pthread_mutex_t mutex;
		(2)初始化互斥量
			pthread_mutex_init(&mutex,NULL);
		(3)使用互斥量进行加锁
			pthread_mutex_lock(&mutex);
		(4)访问共享资源
		(5)使用互斥量进行解锁
			pthread_mutex_unlock(&mutex);
		(6)如果不再使用，则删除互斥量
			pthread_mutex_destroy(&mutex);



	2.3 使用信号里实现线程的同步
		信号量	-本质就是一个计数器,用于控制同时访问一种共享资源的进程/线程个数；

		当信号量的初始值为1时，效果等同于互斥量

		#include<semaphore.h>
		(1)定义信号量
			sem_t sem;
		(2)初始化信号量
			sem_init(&sem,0,信号量的初始值);
		(3)获取信号量,也就是信号量数值-1
			sme_wait(&sem);
		(4)访问共享资源
		(5)释放信号量,也就是信号量数值+1
			sem_post(&sem);
		(6)如果不再使用，则删除信号量
			sem_destroy(&sem);



	作业：
		(1)编程实现基于tcp协议通信模型的简易聊天室
			(服务器每次收到的消息转发给其他所有在线的客户端)day16 02tcpA.c
			=> 参考课堂上讲过的一对多通信模型案例
			=> 要求采用多线程技术替换多进程技术
			=> 要求客户端启动时输入一个昵称；
			=> 要求客户端收发消息功能各自独立执行；(2个线程 一个收一个发)
			
		(2)在上述案例的基础上实现文件的传输
		(3)采用多线程和网络编程重构银行账户管理系统










