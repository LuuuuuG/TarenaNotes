/**************************************************************************/
*									   *		
*				day_05					   *	
*									   *
/**************************************************************************/




	一、内存管理技术


	
			/*内存管理技术*/

	1. 内存管理技术
	1.1 程序和进程的概念
	    程序 - 主要指存放在/*磁盘/硬盘*/上的可执行文件;
	    进程 - 运行在/*内存*/中的程序;
	    
	    同一个程序可以同时对应多个进程;

	1.2 进程中的内存区域划分

		int num;   //全局变量  默认初始值为0	BSS段
		int main(){
		    int num; //局部变量  随即初始值	栈区
		    return 0;
		}

	    (1)代码区(Text)
		-该区域主要用于存放具体的功能代码,函数指针指向该区域;

	    (2)只读常量区(Text)
		-该区域主要用于存放常量字符串,const修饰的并且已经初始化的全局变量
		/静态局部变量,以及字面值;

	    (3)全局区/数据区(Data)
		-该区域主要用于存放没有const修饰的已经初始化的全局变量
		和静态局部变量;

	    (4)BSS段(Data)
		-该区域主要用于存放没有const修饰也没有初始化的全局变量和
		静态局部变量
		-该函数会在main函数执行之前自动清零

	    (5)堆区(Heap)
		-该区域主要用于由函数malloc()/calloc()/realloc()/free()函数
		操作的内存区域;
		-该区域有程序员手动声请和手动释放;

	    (6)栈区(Stack)
		-该区域主要用于存放非静态的局部变量(包括函数的形参);
		-该区域有操作系统自动管理;



		综上所述:
		    进程中的内存区域按照地址从小到大一次排列的结果是:代码区，
		只读常量区,全局区/数据区，BSS段，堆区，栈区；
		    一般来说，其中堆区的内存地址按照从小到大依次进行分配,
		  栈区的内存地址按照从大到小依次分配,以避免区域的重叠；





*****************************
    int i1 = 10; 	//全局区
    int i2 = 10;	//全局区
    int i3; 		//BSS段
    const int i4 = 40; //只读常量区

void fa(int i5){     	 //栈区
    int i6 = 60; 	//栈区
    static int i7 = 70; //全局区
    const int i8 = 80; //栈区
    //p1,p2指向堆区 p1,p2本身在栈去
    int* p1 = (int*)malloc(sizeof(int));
    int* p2 = (int*)malloc(sizeof(int));
    //str指向只读常量区 str本身在栈区
    char* str = "hello";
    //str指向栈区 str本身在栈区
    char strs[]= "hello";
}

int main(){
    printf("-------代码区------------\n");
    printf("代码区:fa = %p\n",fa);
    fa(10);
    return 0;
}

**********************************




	1.3 常量字符串不同存放形式的比较(重点)

	    对于记录常量字符串的/*字符指针*/来说,指针指向的内容不可以改变,
		但指针指向的可以改变；
	    对于记录常量字符串的/*字符数组*/来说，指针指向的内容可以改变,
		但指针指向的不可以改变；

	    对于一块指向/*动态内存的指针*/来说,指针指向的内容和
	    指针指向都可以发生改变。





		
				/*虚拟内存*/

	1.4 虚拟内存管理技术(尽量理解)
	    一般来说,在linux系统中采用虚拟内存管理技术来进行内存空间的管理,
	即:每个进程都可以拥有0~4G-1 的内存地址空间(虚拟的,并不是真实存在的),由操作
	系统负责建立虚拟地址到真实物理内存/文件的映射,因此，不同进程中的地址空间
	看起来是一样的,但是对应的真实无力内存/文件是不一样的。


	其中0~3G-1 的地址空间 叫做用户空间
	   3G~4G-1 地地址空间 叫做内核空间
	用户程序一般都运行在用户空间中,不能直接访问内核空间,不过内核提供了一些
	函数用于访问内核空间。

	  内存地址的基本单位是字节,而内存映射的基本单位是内存页，目前主流的操作
	系统中一个内存页的大小是4Kb(4096个字节)

	    1Kb = 1024 byte(字节)
	    1byte = 8 bit(二进制位)


	1.5 段错误的由来

	    (1)试图去操作没有操作权限的内存空间时可能会引起段错误;
		如:试图修改只读常量区的数据时会引起段错误.

	    (2)试图使用没有经过映射的虚拟地址时可能会引起段错误;
		如:指定任意地址去访问里面的内容时会引起段错误。



	1.6 使用malloc函数申请动态内存
	
	    (1)使用malloc函数申请动态内存时的注意事项.
		使用malloc函数申请动态内存时,除了申请参数指定的动态内存空间之外
	    还可能申请额外的12个字节(一般原则)用于保存该动态内存块的管理信息,
	    如:大小，是否空闲等信息; 
	
	  	因此,使用malloc函数申请的动态内存时，切记不要进行越界访问,
		因为越界访问可能会破坏内存快的管理信息,从而导致段错误的结果;

	    
	    (2)使用malloc函数申请动态内存时的一般性原则

		一般来说,当使用malloc函数申请比较小快的动态内存时,操作系统一般会
	    一次性映射33个内存页的地址空间,从而提高效率；


		#include<unistd.h>
		#include<sys/types.h>
		printf("getpid = %d\n",getpid());//获得当前进程号

		/*  cat /proc/进程号/maps  */   
			 -表示查看指定进程的内存映射情况;


	查看结果是6列:地址范围、权限信息、偏移量、设备编号、i节点编号、
		     进程名称以及路径信息；

		重点关注;heap即可






	1.7 使用free函数释放动态内存的一般原则

	    一般来说,使用free函数释放多少则从映射的总量中减去多少,
	当所有的动态内存全部释放完毕后,操作系统依然会保留33个内存页,用以提高效率；





	【练习】
		使用C语言中的错误表现形式编写以下两个功能函数:
		a.实现计算参数指定的文件的大小,并通过返回值返回,
		  如果参数指定的文件打开失败,则返回错误;
		    ftell()	fseek()
		b.实现比较两个参数字符串的大小,并返回最大值,如果相等则返回错误
			string_compare()
                                                                                                                                                                                                                                                                                                                    






