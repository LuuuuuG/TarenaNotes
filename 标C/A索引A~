/**************************************************************************/
*									   *		
*				day_06					   *	
*									   *
/**************************************************************************/	

	一、随机数
	二、控制语句
	三、while 循环
	四、do...while 循环
	五、printf函数		
	六、数组




			/*一、随机数*/

	不可与之的数字叫做//随机数，
	Rand标准函数需要包含stdlib.h头文件。

	Srand 标准函数设置随机数种子
	它可以把一个整数当作种子使用
	为了使用这个标准函数需要包含stdlib.h头文件

	为了使用这个标准函数需要包含time.h 头文件

  1 //随机数rand
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 int main(){
  5     int num = 0;
  6     printf("num = %d\n",rand());
  7     printf("num = %d\n",rand());
  8     printf("num = %d\n",rand());
  9     return 0;
 10 }



  1 //srand
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <time.h>
  5 int main(){
  6     int num = 0;
  7     srand(time(0));//设置随即的算法种子
  8     printf("num = %d\n",rand());
  9     printf("num = %d\n",rand());
 10     printf("num = %d\n",rand());
 11     
 12     return 0;
 13 } 

**********************************************

【练习】
编写猜数游戏，计算机里产生一个1到100之间的随机数，
然后让用户猜，每次猜完都要给出提示
直到猜对程序为止。

【Gang】
  1 /*
  2 编写猜数游戏，计算机里产生一个1到100之间的随机数，
  3 然后让用户猜，每次猜完都要给出提示
  4 直到猜对程序为止。
  5 */
  6 #include <stdio.h>
  7 #include <stdlib.h>
  8 #include <time.h>
  9 
 10 int main(){
 11     int num = 0,guess = 0;
 12     srand(time(0));
 13     num = rand() %100 + 1;
 14     for (;;){
 15     printf("Input a number:");
 16     scanf("%d",&guess);
 17         if(guess > num){
 18             printf("Bigger!\n");
 19         }
 20         else if(guess < num){
 21             printf("Smaller!\n");
 22         }
 23         else{
 24             printf("congratulation!\n");
 25             break;
 26         }
 27     }
 28     return 0;
 29 }  




**********************************************

			/*二、控制语句*/

	1、分支和循环可以让程序和从的语句不再从上到下顺序执行。


 	2、goto 语句可以把任何一条语句指定为下一条语句,一般不要使用goto语句。

	
	//多重循环
	1、循环里面还可以包含其他循环。
	2、如果一个问题可以划分为多个小问题，每个小问题可以采用类似的循环解决，
		这种问题可以采用多重循环解决。

  1 //多重循环演示
  2 
  3 #include <stdio.h>
  4     int main(){
  5     int i = 0,j = 0;
  6     for (i = 1;i <= 5;i++){
  7         for(j = 5;j >= i;j--){
  8             printf("%d",j);
  9         }
 10         printf("\n");
 11     }
 12     return 0;
 13 }
	
	
	


**************************************
【练习】

	有一种货币包含三种面值，分别是1元，2元和5元。
	编写程序把这种货币里所有10元的可能性找到并打印在屏幕上。



【Gang】

  1 /*有一种货币包含三种面值，分别是1元，2元和5元。
  2     编写程序把这种货币里所有10元的可能性找到并打印在屏幕上。
  3     */
  4 
  5 #include <stdio.h>
  6 
  7 int main(){
  8     int i = 0,j = 0,k = 0;
  9     for (i = 0;i <= 10;i++){
 10         for(j = 0;j <= 5;j++){
 11             for(k = 0;k <= 2;k++){
 12                 if((i + 2*j +5*k) == 10){
 13                     printf("一元%d张 两元%d张 五元%d张",i,j,k);
 14                 }
 15             }
 16         }
 17         printf("\n");
 18     }
 19     return 0;
 20 }


//Mr.Yang

  1 #include <stdio.h>
  2 
  3 int main(){
  4     int i = 0,j = 0;
  5     for (i = 0;i <= 5;i++){   //i表示两元
  6         for(j = 0;j <= 2;j++){ //j表示五元
  7                 if(2*i +5*j <= 10){
  8                     printf("一元%d张 两元%d张 五元%d张\n",10 - 2*i - 5*j,i,j    );                  
  9                 }
 10             }   
 11         }   
 12     return 0;
 13 } 



*****************************************************************************


		/*三、while 循环	（先判断，后执行） */
	1、while 和 for 循环可以互相转换。
	2、编写程序时，不能计算出要执行的次数时，可以考虑采用while循环。
	3、while 格式：
		while (逻辑表达式){
			语句
		}
	4、只要逻辑表达式为真，就会反复执行大括号里面的语句。
	5、如果逻辑表达式永远为真，这个逻辑表达式就是一个死循环。
	6、while 里面也可以使用 break 和 continue 语句
	7、while 循环交替执行逻辑表达式和大括号里面的语句，第一步做逻辑表达式的判断。
	8、如果第一步判断逻辑表达式结果为假，则循环立即结束，不执行大括号里面的语句。


  1 //first while 
  2 #include <stdio.h>
  3 int main(){
  4     int i = 1;
  5     while(i <=5){
  6         printf("%d\n",i);
  7         i++;
  8     }
  9     return 0;
 10 }


//while 循环实现猜数游戏
  1 //Game: guess number
  2 
  3 #include <stdio.h>
  4 #include <stdlib.h>
  5 
  6 
  7 /*int main(){
  8     int num = 0,guess = 0;
  9     srand(time(0));
 10     num = rand() % 100 + 1;
 11     printf("Input a number:");

 12     scanf("%d",&guess);
 13 
 14     while (guess < num){			//Gang
 15         printf("Smaller\n");
 16         printf("Input a number:");
 17         scanf("%d",&guess);
 18     }
 19 
 20     while (guess > num){
 21         printf("bigger\n");
 22         printf("Input a number:");
 23         scanf("%d",&guess);
 24     }
 25     
 26     while (guess == num){
 27         printf("congratulation!\n");
 28     }
 29     return 0;
 30 }*/
 31 
 32 int main(){
 33     int num = 0,guess = 0;
 34     srand(time(0));  //随机生成一个数字
 35     num = rand() % 100 + 1;
 36     while(guess != num){
 37         printf("Input a number:");
 38         scanf("%d",&guess);
 39 
 40         if (guess < num){
 41             printf("Smaller\n");
 42         }
 43         else if (guess > num){
 44             printf("Bigger\n");
 45         }
 46         else{
 47             printf("Congratulation\n");
 48         }
 49     }
 50 
 51     return 0;
 52 }


*****************************************************************************

		/*四、do ... while循环	（先执行，后判断）*/
	1、可以把 do ... while 格式看作是while循环的变体。
	2、小括号后面必须用分号结束。
	3、也交替执行大括号里面的语句和逻辑表达式，先执行括号里面的语句。
	4、do ... while 至少执行大括号里面的语句一次。
	


	//scanf 函数

	1、从键盘得到数字的时候，数字会首先进入输入缓冲区，然后再进入变量的存储区。
	2、先进入缓冲区的数字必须首先被处理。
	3、如果用户输入的格式和程序要求的格式不一致，就可能导致程序永远无法获得数字了。
	4、可以使用如下两条语句，丢掉用户某一次输入的所有内容：

		scanf("%*[^\n]");
		scanf("%*c");	


  1 //scanf
  2 
  3 #include <stdio.h>
  4 int main(){
  5     int num = 0,num1 = 0;
  6     printf("input a number:");
  7     scanf("%d",&num);
  8     scanf("%*[^\n]");   // 丢掉前面第一次
  9     scanf("%*c");       //输入的内容！！！
 10     printf("num is %d\n",num);
 11     printf("input a number:");
 12     scanf("%d",&num1);
 13     printf("num is %d\n",num1);
 14     return 0;
 15 }


*****************************************************************************

			/*五、printf 函数	*/

	1、printf现实数字的时候，数字首先进入输出缓冲区，然后彩绘现实在屏幕上。
	2、只在四种情况下输出缓冲区里的内容会显示在屏幕上：
		a.输出缓冲区里有'\n'字符。 
		b.程序结束。                                                //待验证！
		c.输出缓冲区被充满的时候。
		d.在程序中使用fflush(stdout)把前面放在输出缓冲区里的内容显示在屏幕上。
	5、scanf中含有fflush(stdout)函数。
		


*****************************************************************************

			/*六、数组*/

	1、数组可以用来代表内存中一组连续的同类型存储区。
	2、数组一旦存在则里面包含的存储区个数不可以改变。	
 	3、数组通常不会作为整体使用，一次通常只使用其中某个存储区。
	4、数组里每个存储区有一个编号，这个编号叫做数组的下标。
	5、第一个存储区的下标是 0 ，向后依次递增。
	6、下标范围从 0 到存储区个数减一为止，不可以使用超过范围的下标。
	7、数组名称加下标可以用来表示数组里的某个存储区。
	8、可以在for循环里让循环变量依次代表数组中每个存储区的下标，
		然后在循环中处理循环变量代表的存储区。
	9、数组初始化的时候：
		a.应该把所有初始化数据包含在一对大括号里，不同数据之间用逗号分开。
		b.如果初始化数据个数比存储区个数多，就把后面的初始化数据丢掉。
		c.如果初始化数据个数比存储区个数少，就把后面存储区初始化为 0 
		d.如果初始化数据个数跟存储区个数相等，就可以省略数组声明中的存储区个数~
			【e.g.】   int arr[] = {1,2,3,4,5}

















******************************************************************************

预习：
	变长数组、多维数组


作业：
	编写程序从键盘得到多个整数（数量不超过5个，反序打印，然后打印求和结果）

【Gang】
  1 //编写程序从键盘得到多个整数（数量不超过5个，反序打印，然后打印求和结果）
  2 #include <stdio.h>
  3 int main(){
  4     int a,b,c,d,e;
  5     int i = 0;
  6     int sum = 0;
  7     printf("Input five numbers:");
  8     scanf("%d%d%d%d%d",&a,&b,&c,&d,&e);
  9     int arr[5] = {a,b,c,d,e};
 10     for(i = 4;i >= 0;i--){
 11         printf("%d ",arr[i]);
 12         sum = sum + arr[i];
 13     }
 14         printf("sum = %d\n",sum);
 15     
 16     return 0;
 17 }

//Mr.Yang
 21 int main(){
 22     int arr[5] = {0},qty = 0,num = 0,pos = 4;
 23     int sum = 0;
 24     printf("Input counts of numbers:");
 25     scanf("%d",&qty);
 26     for (num = 1;num <= qty;num++){
 27         printf("Input a number:");
 28         scanf("%d",&arr[pos]);
 29         pos--;
 30     }   
 31     printf("\n");
 32     for(num = pos + 1;num <= 4;num++){
 33         printf("%d",arr[num]);
 34         sum += arr[num];
 35     }
 36 
 37     printf("Sun = %d\n",sum);
 38     return 0;
 39 }


/**************************************************************************/
*									   *		
*				day_07					   *	
*									   *
/**************************************************************************/	

	  生成彩票
	  验证身份证
	一、变长数组
	二、多维数组
	
	
	
	
【练习】
  1 /*彩票1.0
  2 编写程序产生一张彩票，彩票里包含7个1~36之间的随机数（数字可以重复）
  3  首先得到一张彩票，然后把彩票里的数字打印在屏幕上。
  4 */
  5 #include<stdio.h>
  6 #include<stdlib.h>
  7 #include<time.h>
  8 
  9 int main(){
 10     srand(time(0));
 11     int arr[] = {0};
 12     int i = 0,j = 0;
 13     for(i = 1;i <=7;i++){
 14         arr[i] = rand() % 36 +1;
 15         printf("%d ",arr[i]);
 16     }
 17 	return 0；
 18 }

/*		\有重复数字/				*/





/*		/无重复数字\				*/


 #include<stdio.h>
  6 #include<stdlib.h>
  7 #include<time.h>
  8 
  9 int main(){
 10     srand(time(0));
 11     int arr[7] = {0};
 12     int tmp = 0,num = 0;
 13     int i = 0,cnt = 0;
 14 /*  for(i = 1;i <=7;i++){				             <重点复习>
 15         arr[i] = rand() % 36 +1;
 16     }
 17 */
 18     do{
 19         tmp = rand() % 36 +1;
 20         for(num = 0;num <= cnt - 1;num++){
 21             if(arr[num] == tmp){    //生成数字跟前面数字已有一样
 22                 break;              //结束循环
 23             }
 24         }
 25         if (num == cnt){            //循环如果正常结束
 26             arr[cnt] = tmp;         //说明生成数字可以使用~
 27             cnt++;
 28         }
 29     }while(cnt <7);
 30     for(i = 0;i < 7;i++){
 31         printf("%d ",arr[i]);
 32     }
 33     printf("\n");
 34 
 35     return 0;
 36 }











【练习】
  1 /*
  2 身份证前17个号码和下面17个数字对应相乘
  3 (7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2)
  4 
  5 把所有乘积求和，用求和结果除11取余，用余数到下面11个数字里挑选
  6 (1,0,x,9,8,7,6,5,4,3,2)
  7 挑选的结果就是第18位的数字
  8 
  9 */
 10 #include<stdio.h>
 11 
 12 int main(){
 13     int arr[17] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
 14     int i = 0,num = 0,sum = 0,last_num = 0;
 15     for(i = 0;i < 17;i++){
 16         printf("输入你身份证的第%d位：",i);
 17         scanf("%d",&num);
 18         sum = sum + arr[i] * num;
 19     }
 20 
 21         last_num = sum % 11;
 22     int arr2[11] = {1,0,999,9,8,7,6,5,4,3,2};
 23         if( arr2[last_num] == 2){
 24             printf("最后一位是x\n");
 25         }
 26         else{
 27             printf("最后一位是%d\n",arr2[last_num]);   
 28         }
 29         
 30     return 0;
 31 }

//Mr.Yang

4 int main(){
 35     int card[17] = {0},arr[17] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
 36     char arr1[11] = {'1','0','x','9','8','7','6','5','4','3','2'};
 37     int num = 0,sum = 0;
 38     for (num = 0;num <= 16;num++){
 39          printf("输入你身份证的第%d位：",num+1);
 40          scanf("%d",&card[num]);
 41     }
 42     for (num = 0;num <= 16;num++){
 43         sum += card[num] * arr[num];
 44     }
 45         printf("最后一位是%c\n",arr1[sum % 11]);
 46 
 47     return 0;
 48 }
        

【练习】       //                                               <   重点复习  >

  1 /*
  2 编写程序 从键盘得到一个非负整数
  3 ，统计出它里面包含的所有数出现的次数
  4 */

//Mr.Yang
 48 int main(){
 49     int arr[10] = {0},num = 0;
 50     printf("请输入一个数字：");
 51     scanf("%d",&num);
 52     do{
 53         arr[num %10]++;
 54         num /= 10;      //丢掉最右边的数
 55     }while(num);
 56 
 57     for(num = 0;num <= 9;num++){
 58         if(arr[num]){
 59             printf("数字%d出现的次数是%d\n",num,arr[num]);
 60         }
 61     }
 62     return 0;
 63 }



*******************************************************


			/*一、变长数组*/
	1、数组名称不可以代表存储区。
	2、数组名称代表的是数组里第一个存储区的地址。
	3、可以对数组名称做sizeof计算，计算结果是数组里所有存储区的总大小
	4、c99规范里允许使用边长数组，声明边长数组时可以使用变量表示数组里
		包含的存储区个数。
	5、如果多次运行这个程序则这个数组里包含的存储区个数可能变化。
		每次程序运行过程中数组里包含的存储区个数不会改变。
	6、变长数组/*不可以初始化。*/



//  数组地址演示
  1 #include<stdio.h>
  2 
  3 int main(){
  4     int arr[5] = {0};
  5     printf("arr is %p\n&arr[0] is %p\n",arr,&arr[0]);
	printf("sizeof(arr)is %d\n",sizeof(arr));

  6     return 0;
  7 }
********************
运行结果：
arr is 0xbf82a6fc
&arr[0] is 0xbf82a6fc
sizeof(arr)is 20



//变长数组演示
  1 #include<stdio.h>
  2 
  3 int main(){
  4     int size = 0;
  5     printf("请输入存储区个数：");
  6     scanf("%d",&size);
  7     int arr[size];  //变长数组声明。
  8     printf("sizeof(arr) is %d\n",sizeof(arr));
  9     return 0;
 10 }


【练习】
编写程序产生一张彩票，彩票里的数字个数由用户指定。






********************************************************



			/*二、多维数组*/
	1、多维数组除了可以表示存储区以外，还可以表示存储区的分组情况。
	2、二维数组是最常见的多维数组，它只能表示存储区的一次存储情况。
	3、声明二维数组时需要提供两个整数，
		前一个表示分组个数，后一个表示分组里的存储区个数。
	4、使用二维数组时也需要提供两个下标，
		a.组下标	表示分组	范围从0开始到分组个数减一为止。
		b.组内下标	表示分组内的存储区	范围从0开始到存储区个数减一为止。

	5、可以采用双重循环依次处理二维数组里的每个存储区。
	6、可以把二维数组当作一维数组进行初始化。
		int arr[3][2] = {1,2,3,4,5,6};
	7、也可以把初始化数据进行分组，每组初始化数据用来初始化一组存储区。
		int arr[3][2] = {{1,2},{3,4},{5,6}};
	8、如果可以根据初始化数据计算出分组个数就可以省略数组声明里的分组个数。
		int arr[][2] = {1,2,3,4,5};
		int arr[][2] = {{1},{3,4},{5,6}};
	9、二维数组名称只能代表其中第一个存储区的地址。
	10、数组名称也不可以被赋值。
	11、二维数组名称也可以做sizeof计算，结果是二维数组里所有存储区的总大小。
	12、二维数组名称在使用的时候也可以只提供一个下标，这个下标作为组下标使用。
		这个写法代表下标对应组里第一个存储区的地址。
			arr[1] 的 %p 与 arr[1][0] %p 相同


************************************************************************


//数组演示
  1 #include<stdio.h>
  2 int main(){
  3     int arr[3][2];  //二维数组声明
  4     int row = 0,col = 0;
  5     int num = 1;
  6     for(row = 0;row <= 2;row++){
  7         for(col = 0;col <= 1;col++){
  8             arr[row][col] = num;
  9             num++;
 10             printf("arr[%d][%d] = %d      ",row,col,arr[row][col]);
 11         }
 12         printf("\n");
 13     }
 14     return 0;
 15 }
*********************************
运行结果：
arr[0][0] = 1      arr[0][1] = 2      
arr[1][0] = 3      arr[1][1] = 4      
arr[2][0] = 5      arr[2][1] = 6 


//二维数组演示
  1 #include<stdio.h>
  2 int main(){
  3     int arr[3][2] = {0};
  4     printf("arr is %p\n&arr[0][0]is %p\n",arr,&arr[0][0]);
  5     printf("sizeof(arr) is %d\n",sizeof(arr));
  6     printf("arr[1] is %p\n&arr[1][0]is %p\n",arr[1],&arr[1][0]);
  7     printf("sizeof(arr[1]) is %d\n",sizeof(arr[1]));
  8     return 0;
  9 }
~      
***************************************
运行结果：
arr is 0xbfde1898
&arr[0][0]is 0xbfde1898
sizeof(arr) is 24
arr[1] is 0xbfde18a0
&arr[1][0]is 0xbfde18a0
sizeof(arr[1]) is 8


*****************************************************************



编写程序 二维数组 5 * 5 
填入 
10000
02000
00300
00040
00005
把以上数字填充到二维数组中然后此格式打印


【Gang】
  1 #include <stdio.h>
  2 int main(){
  3     int arr[5][5];
  4     int i = 0,j = 0;
  5     for(i = 0;i < 5;i++){
  6         for(j = 0;j < 5;j++){
  7             if(i == j){
  8                 arr[i][j] = j + 1;
  9                 printf("%d",arr[i][j]);
 10             }
 11             else{
 12                 arr[i][j] = 0;
 13                 printf("%d",arr[i][j]);
 14             }
 15         }	`
 16         printf("\n");
 17     }
 18 
 19     return 0;
 20 }


//Mr.Yang

 24 int main(){
 25 
 26     int arr[5][5] = {0};
 27     int i = 0,j = 0;
 28     for(i = 0;i < 5;i++){
 29         for(j = 0;j < 5;j++){
 30             if(i == j){
 31                 arr[i][j] = j + 1;
 32             }
 33         }
 34     }
 35     for(i = 0;i < 5;i++){
 36         for(j = 0;j < 5;j++){
 37             printf("%d",arr[i][j]);
 38             }
 39             printf("\n");
 40         }
 41 
 42     return 0;
 43 }











****************************************************************
预习：
	1、函数










/**************************************************************************/
*									   *		
*				day_08					   *	
*									   *
/**************************************************************************/

	扫雷游戏
	一、函数




二维数组练习：
	1、 扫地雷游戏
		10*10 地图随机放10个地雷
		地雷用	X 表示
		空位置  O  表示

【Gang】              // 待调试！！！
  1 #include<stdio.h>
  2 #include<stdlib.h>
  3 #include<time.h>
  4 int main(){
  5     srand(time(0));
  6     int map[10][10] = {0};
  7     int i = 0,j = 0,m = 0,n = 0;
  8     int boom[i][j];
  9     int num = 0;
 10      for (;num < 10;){
 11             m = rand() % 10;
 12             n = rand() % 10;
 13         if(map[m][n] != -1){
 14             map[m][n] = -1;
 15             num++;
 16         }
 17         }
 18 
 19      for (i = 0;i < 10;i++){
 20         for(j = 0;j < 10;j++){
 21             if(map [i][j]){
 22                 printf("X");
 23             }
 24             else{
 25                 printf("o");
 26             }
 27 
 28         }
 29         printf("\n");
 30      }
 31 
 32 
 33     return 0;
 34 }




//Mr.Yang
  1 #include <stdio.h>
  2 #include <stdlib.h>
  3 #include <time.h>
 31 int main(){
 32     int map[10][10] = {0};    //初始化  此时地图上全是空位置0
 33     int row = 0,col = 0;
 34     int cnt = 0;    //用来计算地雷的个数
 35     srand(time(0));
 36     do{
 37         row = rand() % 10;
 38         col = rand() % 10;
 39         if(map[row][col] !=-1){     //用 -1 表示地雷的位置
 40             map[row][col] = -1;     //地图上不是-1的地方变成-1
 41             cnt++;			
 42         }
 43     }while(cnt < 10);
 44     for(row = 0;row < 10;row++){
 45         for(col = 0;col < 10;col++){
 46             if(!map[row][col]){
 47                 printf("O");
 48             }
 49             else{
 50                 printf("X");
 51             }
 52         }
 53         printf("\n");
 54     }
 55 
 56     return 0;
 57 }





		2. 扫雷进阶 （带上雷旁边的数字）  //方法一

		3、扫雷进阶 (从空白位置找到雷的位置) //方法二


#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main() {
	int map[10][10] = {0}, row = 0, col = 0, cnt = 0, num = 0, newrow = 0, newcol = 0;
	int delta[8][2] = {{-1, -1},{-1, 0}, {-1, 1},
	         {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
	srand(time(0));
	do {		//随机在地图上生成地雷
		row = rand() % 10;
		col = rand() % 10;
		if (map[row][col] != -1) { // -1表示地雷的位置
			map[row][col] = -1; // 只在没有地雷的位置随机生成地雷
			cnt++;
		}
	} while (cnt < 10);

	//地图上用数字记录格子旁边有多少个地雷

	//方法一：先找地雷，在地雷旁边计数。
	/*for (row = 0;row <= 9;row++) {
		for (col = 0;col <= 9;col++) {
			if (map[row][col] != -1) {
				continue;
			}
            		for (num = 0;num <= 7;num++) {
				newrow = row + delta[num][0];
				newcol = col + delta[num][1];
				if (newrow < 0 || newrow > 9) {
					continue;
				}
				if (newcol < 0 || newcol > 9) {
					continue;
				}
				if (map[newrow][newcol] == -1) {
					continue;
				}
				map[newrow][newcol]++;
			}
		}
	}*/

	//方法二：先找空白地图，然后在地雷旁边计数。
	for (row = 0;row <= 9;row++) {			//处理不是地雷的区域
		for (col = 0;col <= 9;col++) {
			if (map[row][col] == -1) {  //跳过是地雷的区域
				continue;
			}
			for (num = 0;num <= 7;num++) {
				newrow = row + delta[num][0];
				newcol = col + delta[num][1];
				if (newrow < 0 || newrow > 9) {
					continue;
				}
				if (newcol < 0 || newcol > 9) {
					continue;
				}
				if (map[newrow][newcol] == -1) {
					map[row][col]++;
				}
			}
		}
	}

	//绘制地图
	for (row = 0;row <= 9;row++) {
		for (col = 0;col <= 9;col++) {
			if (!map[row][col]) {
				printf("O ");	//地图上空位置用O表示
			}
			else if (map[row][col] > 0) {
				printf("%d ", map[row][col]);
			//用数字显示地图上格子边上有地雷数量
			}
			else {
				printf("X ");//X表示地雷
			}
		}
		printf("\n");
	}
	return 0;
}





**********************************************************

			/*一、函数*/

	1、C语言中采用分组方式管理语句，每个语句分组叫做一个函数。
	2、多函数程序执行模式：
	  【1】整个程序的执行时间被划分成几段，不同时间段被分配给不同函数使用。
	  【2】所有时间段不能互相重叠并且是连续的。
	  【3】如果函数A在工作过程中把一段时间分配给函数B，则函数B在完成所有工作之后必须把后面的时间再还给函数A。
		【时间划分】
		b			***

		a		    ***	   ***

		main		****	      ***
	
	3、如果函数A在工作过程中把一段时间分配给函数B，则他们之间存在函数调用关系。
	   在这个关系中函数A叫做调用函数，函数B叫做被调用函数。
	4、函数调用关系有时间范围，只要被调用函数已经开始工作但还没有结束，
	   则函数调用关系存在。
	5、函数调用语句可以在程序执行过程中产生函数调用关系
	

*************	
  1 //函数演示
  2 #include<stdio.h>
  3 
  4 void print(void){
  5     printf("1\n");
  6 }
  7 int main(){
  8     print();
  9     return 0;
 10 }
********************	
	
	6、变量不可以跨函数使用。不同函数内部的变量可以重名。
	7、一个函数如果多次运行他内部的变量，每次对应的存储区都可能不同。

*********************
  1 //函数演示
  2 #include<stdio.h>
  3 
  4 void print(void){
  5     int num = 0;
  6     printf("1\n");
  7 }
  8 void func(void){
  9     int num;
 10     printf("num is %d\n",num);
 11     num = 10;
 12 }
 13 void func1(void){   //排除偶然两次调用func函数的因素
 14     int num = 10;
 15     int num1 = 11;
 16     int num2 = num + num1;
 17 
 18 }
 19 int main(){
 20     int num = 0;
 21 //  print();    
 22     func();
 23     func1();
 24     func();
 25     return 0;
 26 }
*********************
运行结果：
num is 134513857   //随机产生
num is 21	   //理应随机产生

*************************

	8、volatile关键字可以用来声明变量，如果变量对应的存储区可能被多个程序同时使用就应该在声明变量的时候使用这个关键字。
	9、函数调用过程中通常伴随着两个函数之间的数字传递。
	  数字传递存在两个完全相反的方向，
	  调用函数 到 被调用函数
	  被调用函数 到 调用函数
	10、不论那个方向的数据传递都需要使用被调用函数提供的存储区。
	11、被调用函数——>调用函数 只能传递一个数据(被调用函数的返回值)
							| 使用return 数值;
							V
						只能在函数结束时传递，
						被调用函数提供存储区。
						(存储区类型: 类型名 函数名)
	12、调用函数可以把函数调用语句当作数字使用，这个数字就是函数的返回值。
//函数返回值演示
  1 #include<stdio.h>
  2 int read(void){ //被调用函数
  3     int num = 0;
  4     printf("plz input a number:");
  5     scanf("%d",&num);
  6     return num;
  7 }   
  8 int main(){
  9     int num = read();    //调用read函数
 10     printf("num is %d\n",num);
 11     return 0;
 12 } 
********************
运行结果：
plz input a number:5
num is 5



【练习】
 /* 编写函数，解决鸡兔同笼问题，这个函数负责解决有多少个头和脚，
	然后把兔子的数量传递。*/

   #include <stdio.h>	
 20 int rabbit(void){
 21     int heads = 0,legs = 0,num = 0;
 22     printf("plz input the number of heads:");
 23     scanf("%d",&heads);
 24     printf("plz input the number of leds:");
 25     scanf("%d",&legs);
 26     for(num = 0;num <= heads;num++){  //计算兔子的数量
 27         if(4 * num + 2 * (heads - num) == legs){
 28             return num;
 29         }
 30     }
 31 }
 32 int main(){
 33     int num = rabbit();
 34     printf("There are %d rabbit\n",num);
 35     return 0;
 36 }

	
	13、如果函数提供存储区用来记录返回值但没有使用return关键字指定返回值的数值
		那么调用函数从这个存储区里获得的就是随机数。
	14、这个存储区不能用来和长期存放数字，调用函数获得返回值后，
		要么立刻使用 要么转存到其他存储区。
	15、函数名称前写void表示函数不提供存储区存放返回值。
		如果函数前面什么都没有，C99规范中不允许此情况
		C89规范中表示函数提供一个整数类型存储区存放返回值。
	16、函数不可以采用数组存放返回值。


【练习】
	从键盘得到两个整数，计算他们的最大公约数，并把结果传递给调用函数
		a	b
	不断作 b % a 得到的两个数与上面一组两个数最大公约数相 				
		48  	68
		20	48
		8	20	
		4	8
		0	4

【Gang】
  1 //用函数求最大公约数
  2 #include <stdio.h>
  3 int max_com(void){
  4     int a = 0,b = 0; // a > b
  5     int tmp = 0;
  6     printf("plz input two numbers:");
  7     scanf("%d%d",&a,&b);
  8     while(b % a){
  9         tmp = a;
 10         a = b % a;
 11         b = tmp;
 12     }
 13     return a;
 14 }
 15 
 16 int main(){
 17     int num = max_com();
 18     printf("max common number is %d\n",num);
 19     return 0;
 20 }




*****************************************
预习：
	1、函数
	2、递归
	3、作用域，全局变量和局部变量。






/**************************************************************************/
*									   *		
*				day_09					   *	
*									   *
/**************************************************************************/

		
	一、函数
	二、变长参数
	三、递归函数
	四、变量和作用域
	五、静态变量
	

	

			/*一、函数*/
			
	函数格式：
		返回值类型 函数名(形参){
	
		}

	
	1、为了从调用函数向被调用函数传递数据，
	也需要被调用函数提供一组存储区，这些存储区的类型和个数任意。
	2、可以在函数名称后的小括号里写一组变量声明语句，
	  用这些变量代表这些存储区。
	3、这些变量叫做函数的/*形式参数*/，小括号里的内容叫做函数的形式参数列表。
	4、每个形式参数的类型名称都不可以省略。不同形式参数声明用逗号分开。
	5、调用函数应该在函数调用语句的小括号里为每个形式参数提供一个对应的数字，
		这些数字叫做/*实际参数*/。
	6、能当作数字使用的内容都可以作为实际参数使用。
	7、如果函数不提供形式参数就应该在函数名称后面写 void 
	8、如果函数名称后面的小括号内容是空的就表示函数可以提供哦功能任意多个任意类型的形式参数。
	


**************
//形式参数演示
  1 #include<stdio.h>
  2 void print(int num,int num1/*形参*/){ //每个形参的类型不能省略
  3     printf("%d %d\n",num,num1);
  4 }
  5 int main(){
  6     print(4,6 + 7/*实参*/);
  7     return 0;
  8 }

***************



/*【练习】
	鸡兔同笼问题，头和脚的数量从调用函数里面解决。
*/
【Gang】
#include<stdio.h>
void print(int heads,int legs){
    int rabbits = 0;
    for(rabbits = 0;rabbits <= heads;rabbits++){
        if(rabbits * 2 + (heads - rabbits) * 4 == legs){
            printf("There are %d rabbits\n",rabbits);
        }   
    }   
}

int main(){
    print(40,120);
    return 0;
}


【改】
#include<stdio.h>
int print(int heads,int legs){
    int rabbits = 0;
    for(rabbits = 0;rabbits <= heads;rabbits++){
        if(rabbits * 4 + (heads - rabbits) * 2 == legs){
            return rabbits;
        }   
    }   
}

int main(){
    int heads = 0,legs = 0,num;
    printf("plz input numbers of heads and legs:");
    scanf("%d%d",&heads,&legs);
    num = print(heads,legs);
    printf("There are %d rabbits and %d checken\n",num,heads - num);
    return 0;
}


**************************

	1、数组可以作为形式参数使用，它仅仅是把形式参数写成数据的样子，
	       真正的形式参数并不是数组而是一个可以当作数组使用的变量。
	2、数组形式参数里包含的存储区都不是被调用函数提供的。
	3、数组形式参数可以让被调用函数使用其他函数提供的存储区(跨函数使用存储区)


//数组形式参数演示
#include<stdio.h>
void print(int arr[5]){
    int num = 0;
    for (num = 0;num <= 4;num++){
        printf("%d ",arr[num]);
    }   
    printf("\n");
}
void clear(int arr[5]){//将数组内容清零
    int num = 0;
    for (num = 0;num <= 4;num++){
        arr[num] = 0;
    }   
}

int main(){
    int arr[] = {1,2,3,4,5};//数组作为形参
    print(arr);
    clear(arr);
    print(arr);
    return 0;
}

************************

	4、使用数组形参可以实现双向数据传递，这种参数叫做输入输出参数。
	5、声明数组形参的时候可以省略其中包含的存储区个数。
	    如果省略，则需要提供另外一个整数类型形参表示数组里的存储区个数。


#include<stdio.h>
void print(int arr[],int size){ //声明一个size变量表示存储区个数
    int num = 0;
    for (num = 0;num <= size - 1;num++){
        printf("%d ",arr[num]);
    }   
    printf("\n");
}
void clear(int arr[],int size){//将数组内容清零
    int num = 0;
    for (num = 0;num <= size -1;num++){
        arr[num] = 0;
    }   
}

int main(){
    int arr[] = {1,2,3,4,5};//提供形参
    print(arr,5);
    clear(arr,5);
    print(arr,5);
    return 0;
}

***********************

【练习】
编写函数把一个数组里所有存储区的内容变成相反数，
在主函数数里把修改后的数组内容打印在屏幕上。
#include<stdio.h>
void print(int arr[5]){
	int num = 0;
	for(num = 0;num <= 4;num++){
		printf("%2d ",arr[num]);
	}
	printf("\n");
}

void negnum(int arr[5]){
	int num = 0;
	for(num = 0;num <= 4;num++){
		arr[num] =0 - arr[num];
	}
}

int main(){
	int arr[] = {1,2,3,4,5};
	print(arr);
	negnum(arr);
	print(arr);
	return 0;
}






			/*二、变长参数*/

	1、C语言中函数形参的数量不确定。
	2、变长参数不能事先命名，只能在被调用函数里通过特殊的方式得到它们。
	3、函数调用语句如果写在被调用函数语句前面，编译器会猜测函数格式
		这个猜测结果叫做函数的隐式声明。
	4、函数隐式声明中包含一个整数类型存储区用来存放返回值，还包含任意多个不确定类型的形参。
	5、隐式声明中的形参只能是int类型或double类型。
	6、如果函数隐式声明格式和真实格式不一致，在编译阶段就会出错。

		函数格式：
		返回值类型 函数名(形参)/*花括号前为函数声明*/ {

		}//花括号里的为函数体
	7、可以把函数声明单独写成一条语句，这个时候可以省略形参名称。
	8；函数的显示声明：
		把函数声明单独写在文件开头。 
	9、显示声明可以避免隐式声明。
	10、除了主函数以外的所有函数都应该显示声明。	
	


		/*exit标准函数*/可以立刻结束程序的执行
	1、为了使用这个标准函数需要包含stdlib.h头文件。
	2、这个函数需要一个证书作为实际参数，这个参数的作用和主函数的返回值一样。
		

*******************
//exit标准函数演示
  1 #include<stdio.h>
  2 #include<stdlib.h>
  3 void func(void){
  4     printf("2\n");
  5 //  return ; //立刻结束函数的执行
  6     exit(0); //结束程序
  7     printf("3\n");
  8 }
  9 
 10 int main(){
 11     printf("1\n");
 12     func();
 13     printf("4\n");
 14     return 0;
 15 }
******************


【练习】
	编写函数产生一张彩票，在主函数里把彩票内容打印在屏幕上
	彩票里包含7个1~36之间的随机数

【Gang】
//彩票2.0
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
void ticket(int arr[7]){
    srand(time(0));
    int num = 0;
    for(num = 0;num <= 6;num++){
        arr[num] = rand() % 36 + 1;
    }
    for(num = 0;num <= 6;num++){
        printf("%d ",arr[num]);
    }
}

int main(){
    int arr[7] = {0};
    ticket(arr);
    printf("\n");
    return 0;
}




//Mr.Yang

void ticket(int arr[],int size){
    int num = 0;
    for(num = 0;num <= size - 1;num++){
        arr[num] = rand() % 36 + 1;
    }   

}

int main(){
    srand(time(0));
    int arr[7] = {0},num = 0;
    ticket(arr,7);
    for (num = 0;num <= 6;num++){
        printf("%d ",arr[num]);
    }   
    printf("\n");
    return 0;
}


********************************************

			/*三、递归函数*/
	1、C语言中函数可以调用自己，这种函数叫做递归函数。
	2、如果一个问题可以分解成几个小问题，
	    其中至少有一个小问题和原来的问题本质上一样，
	     只是稍微简单了一点，这种问题就可以采用递归函数解决。

	3、编写递归函数步骤：
		a.编写语句描述问题的分解方式(假设递归函数已经完成)
		b.在函数开头编写分支处理不可分解的情况(这个分支必须能让函数结束)
		(不需要明白程序执行过程！)
		
//递归函数演示
#include<stdio.h>
void print(int num){
    if (num == 1){ 
        printf("1 ");
        return ;
    }   
    print(num - 1); //假设递归函数已经完成，打印从1开始到num - 1
    printf("%d ",num);//打印num
}

int main(){
    int num = 0;
    printf("plz intput a number:");
    scanf("%d",&num);
    print(num);
    printf("\n");
    return 0;
}



******************
	
	4、能用递归解决的问题也能用循环解决。
		采用递归函数解决问题的思路叫做递归
		采用循环解决问题的思路叫做//递推		


【练习】
编写递归函数，计算从1开始到某个整数之间
  所有整数的和。

/*编写递归函数，计算从1开始到某个整数之间
  所有整数的和。
  */
#include<stdio.h>
int sum(int num){
    if(num == 1){ 
        return 1;    //num为1的情况
    }   
    
     return sum(num - 1) + num;//num不为1的情况 
}

int main(){
    int num = 0;
    printf("plz input a number:");
    scanf("%d",&num);
    printf("sum = %d\n",sum(num));
    return 0;
  }


**********************



			/*四、变量和作用域*/
	1、可以使用某个变量的所有语句叫做这个变量的作用域。
	2、声明在函数内部的变量叫做//局部变量，
	    它的作用域只包含声明它的函数内部的所有语句。
	3、声明在所有函数外边的变量叫做//全局变量，
	    它的作用域包含程序中的所有语句。
	
	4、没有初始化的/*全局变量*/会自动被初始化为 0 。
		      /*局部变量*/ 随机	
	5、局部变量可以和全局变量重名，使用这个变量名时，
		计算机会优先选择局部变量。

	

****************

//变量演示
#include<stdio.h>
 int num;       //全局变量
void func(void){
//  int num;    //局部变量
    printf("num = %d\n",num);
}
int main(){
    int num = 10; 
    func();     //结果num = 0 (使用全局便来那个)
    printf("num = %d\n",num);//结果num = 10(优先使用局部变量)
    return 0;
}
  
***********
	6、如果全局变量和局部变量都能满足程序要求就应该选择局部变量。
	7、变量的使用受作用域限制，而存储区不受(可以跨函数使用存储区)
	8、存储区的使用受到生命周期的限制。存储区只能在这个时间范围内使用。
	9、全局变量的生命周期是整个程序执行的时间范围，
		局部变量的生命周期是包含它的函数某一次执行的时间范围。
	
	10、如果一个函数多次执行，每次执行时它里面的局部变量对应的存储区都可能不同






			/*五、静态变量*/

	1、 static 关键字可以用来声明/*静态变量*/，静态变量的生命周期和作用域和普通变量不同。
	2、所有静态变量的生命周期都是整个程序的执行时间。
	3、静态变量存储区任何时候都可以使用。
	4、没有初始化的静态变量会自动被初始化为 0 (类似与全局变量) 
	5、静态变量只在程序开始执行的时候做一次初始化。
	6、可以跨函数使用静态局部变量的存储区。
	7、静态全局变量的作用域只包含声明他的文件内部的所有语句。



练习：
  1 1 2 3 5 8 13 21 ...
  0 1 2 3 4 5  6  7 ...
	
【Gang】
#include <stdio.h>
int fei(int num){
    if(num <= 1){ 
        return 1;
    }   
    return fei(num - 1) + fei(num - 2); 
}

int main(){
    int num = 0;
    printf("plz input the code:");
    scanf("%d",&num);
    printf("the number is %d\n",fei(num));
    return 0;
}



**********************************
作业：
	使用数组改写斐波那契数列。
	  多用几种方法。(最多3种)

/*
用数组改写斐波那契数列。
用三种不同的方法
    思路：延长数组生命周期，加快程序运行。
*/
#include <stdio.h>
/*方法一  将数组放在主函数内
int fei(int arr[],int num){
    int i = 0;
    for(i = 0;i <= num;i++){
        if(i <= 1){
            arr[i] = 1;
        }
        else{
            arr[i] = arr[i - 1] + arr[i - 2]; 
        }
    }
        return arr[num];
}

int main(){
    int num = 0;
    printf("plz input the code:");
    scanf("%d",&num);
    int arr[num];
    printf("the number is %d\n",fei(arr,num));
    return 0;
}*/


//Mr.Yang
int arr[50];    //法2 将数组改为全局变量
                //全局数组不需要初始化
int fei(int num){
//   static int arr[50] = {0}; //法3 延长数组生命周期
    if(num <= 1){
        return 1;
    }
    if(!arr[num - 2]){
        arr[num - 2] = fei(num - 2);
    }
    if(!arr[num - 1]){
        arr[num - 1] = fei(num - 1);
    }
     return fei(num - 1) + fei(num - 2);
}

int main(){
    int num = 0;
    printf("plz input the code:");
    scanf("%d",&num);
    printf("the number is %d\n",fei(num));
    return 0;
}





***************************

预习：
	指针





/**************************************************************************/
*									   *		
*				day_10					   *	
*									   *
/**************************************************************************/

	一、指针变量
	二、字符串
	三、字符串字面值





			/*一、指针变量*/  /*pointer*/
	1、只有记录有效地址的指针才能使用。
	2、有效指针变量前加*可以表示捆绑的存储区。
	3、指针变量也分类型，不同类型的指针适合与不同类型的存储区捆绑。
	4、可以在一条语句里声明多个同类项指针，每个指针变量名称前单独加‘*’
	5、没有捆绑的指针分为两类：
		1、空指针里记录固定地址(空地址，用NULL表示，数值为0)
		2、除了空指针以外的没有捆绑的指针都叫野指针。
	6、程序中禁止出现野指针。
	7、所有指针必须初始化。指针变量初始化过程中‘*’不参与赋值。

************
//指针演示
#include <stdio.h>
int main(){
    int num = 0;
    int *p_num = &num,*p_num1 = NULL;   //所有指针必须初始化，避免野指针！
    *p_num = 10;         // *用来找到num的存储区
    printf("num is %d\n",num);
    return 0;
}
*****************

【练习】
 	从键盘得到三个整数，从大到小输出


//从键盘得到三个整数，从大到小输出
#include<stdio.h>

int main(){
    int num1 = 0,num2 = 0,num3 = 0,tmp = 0;
    int *p_num1 = &num1,*p_num2 = &num2,*p_num3 = &num3,*p_tmp = &tmp; 
    //声明三个指针变量分别和三个数字捆绑。
    printf("plz input three numbers:");
    scanf("%d%d%d",p_num1,p_num2,p_num3);
    if(*p_num1 < *p_num2){
        *p_tmp = *p_num1;
        *p_num1 = *p_num2;   //赋值语句如果不加‘*’
        *p_num2 = *p_tmp;    //则指针和数字之间的捆绑关系就变了。
    }   
    if(*p_num1 < *p_num3){
        *p_tmp = *p_num1;
        *p_num1 = *p_num3;
        *p_num3 = *p_tmp;
    }   
    if(*p_num2 < *p_num3){
        *p_tmp = *p_num2;
        *p_num2 = *p_num3;
        *p_num3 = *p_tmp;
    }   
    printf("Numbers from bigger to smaller: %d %d %d\n",*p_num1,*p_num2,*p_num3);
    return 0;
}

*************************************


	8、指针变量和普通变量之间的捆绑关系可以随着程序的执行不断变化。
	9、可以把指针看作普通变量的某种身份，
		可以使用指针实现针对身份编程。
	10、用一个指针和数组里第一个存储区捆绑，
	    就可以通过这个指针找到数组里每个存储区，
	    此时可以认为指针间接捆绑了数组里的所有存储区。
	11、地址数据可以参与如下计算：
		a.地址 + 整数
		b.地址 - 整数
		c.地址 - 地址
	
	12、地址加减整数n实际加减的是n个捆绑存储区的大小



***************	
//地址数据演示
#include<stdio.h>

int main(){
    int arr[5] = {1,2,3,4,5};
    printf("arr is %p\narr + 2 is %p\n",arr,arr + 2); 
    return 0;

}
*************
arr is 0xbf8589fc
arr + 2 is 0xbf858a04

结果相差 8 个字节
***********


	13、地址减地址的结果是一个整数，这个结果表示两个地址之间捆绑存储区的个数。
		printf("&arr[2] - arr is %d\n",&arr[2] - arr);
	


****************

//指针和数组的关系
#include<stdio.h>

int main(){
    int arr[5] = {1,2,3,4,5};
    int *p_num = arr ; //用数组名称对指针初始化。
    int num = 0;
    for(num = 0;num <= 4;num++){
        printf("%d ",arr[num]);   // ok
        printf("%d ",*(arr + num));  //bad
        printf("%d ",p_num[num]);  // not good
        printf("%d ",*(p_num + num));  //best
    }   
    printf("\n");
    return 0;
}

****************************

	14、所有跨函数使用存储区都是通过指针实现的。
	15、数组做形参的时候真正的形参是一个指针变量。

【练习】
用指针做形参将数组的内容打印在屏幕上
【Gang】
//用指针做形参将数组的内容打印在屏幕上

#include<stdio.h>
void print(int *p_num){
    int num = 0;
    for (num = 0;num <= 4;num++){

    printf("%d ",*(p_num + num));
    }   
}

int main(){
    int num = 0;
    int arr[5] = {1,2,3,4,5};
    int *p_num = arr;
    print(p_num);
    printf("\n");
    return 0;
}


*******************
【练习】

编写程序 把调用函数中两个变量内容交换

#include<stdio.h>
void swap(int *p_num1,int*p_num2){
    int tmp = *p_num1;
    *p_num1 = *p_num2;
    *p_num2 = tmp;

}

int main(){
    int num1 = 3,num2 = 7;
    swap(&num1,&num2);
    printf("num1 = %d num2 = %d\n",num1,num2);
    return 0;
}


	16、指针存储区可以用来存放函数的返回值。
		这样可以让调用函数使用被调用函数提供的存储区。
	17、不可以把非静态局部变量的地址作为返回值(生命周期太短！)


//指针返回值演示
#include<stdio.h>
int *read(void){
    static int num;   //静态局部变量不可以初始化。。
    printf("plz input a number:");
    scanf("%d",&num);
    return &num;

}

int main(){
    int *p_num = read();
    printf("%d\n",*p_num);
    return 0;
}




	const 关键字可以用来声明变量，多数情况下用来声明指针。

	1、声明指针变量的时候可以把 const 关键字写在/*类型名称*/前，
		表示不可以通过指针对捆绑存储区进行赋值，但可以对指针本身的存储区进行赋值。

******************
//const关键字演示
#include<stdio.h>

int main(){ 
    int num = 0;
    const int *p_num = &num;
//  *p_num = 10; 不能通过指针对捆绑存储区赋值；
    p_num = NULL;   //可以对指针本身的存储区赋值
    return 0;
}
	
*************************

	2、指针形参要尽量采用上面的方式加const关键字。
	3、可以在声明指针变量的时候把 const 关键字写在/*指针变量名称*/前，
	   可以通过这种指针对捆绑存储区做赋值，但是不可以对指针本身做赋值。


***********************
//const关键字演示
#include<stdio.h>
int main(){ 
    int num = 0;
    const int *p_num = &num;
//  *p_num = 10;    //不能通过指针对捆绑存储区赋值；
    p_num = NULL;   //可以对指针本身的存储区赋值
    
    int const p_num1 = &num;
    *p_num1 = 10;   //可以对对指针捆绑存储区做赋值
//  p_num1 = NULL;  //不能对指针本身做赋值。
    return 0;
}
********************
	
	4、可以在声明指针变量时使用 void 作为类型名称，称为/*无类型指针*/。
	5、这种指针可以和任意类型存储区捆绑。不能通过这种指针做的捆绑存储区的类型。
	6、这种指针不可以直接在前面加*来使用。
	7、这种指针必须首先强制类型转换成有类型指针，然后才能在前面加*表示捆绑存储区。

***************	
//无类型指针演示
#include<stdio.h>
int main(){
    char ch = 'a';
    int num = 20; 
    float fnum = 5.4f;
    void *p_v = NULL;
    p_v = &ch;
    printf("%c\n",*(char *)p_v);  //强制类型转换
    p_v = &num;
    printf("%d\n",*(int *)p_v);
    p_v = &fnum;
    printf("%g\n",*(float *)p_v);
    return 0;
}
*******************
运行结果：
a
20
5.4
*******************

	8、无类型指针通常作为形参使用，可以通过它把任意类型的存储区传递给被调用函数。
	
************************************************************************



			/*二、字符串*/
	
	1、C语言里所有文字信息必须存储在一组连续的字符类型存储区里。
	2、所有文字信息必须以‘\0’作为结尾，这个字符的ASCII码就是数字 0 。
		  符合以上特征的内容叫做/*字符串*/。
	3、字符串里‘\0’字符前面的部分是有效字符。
	4、所有字符串一定可以采用字符类型指针表示。








			/*三、字符串字面值*/
	1、用两个双引号中间的一组字符表示，例如："abc","^&%" ...
	2、编译器在编译的时候会自动在字符串字面值后面加上'\0'字符。
	3、编译器编译时会吧字符串字面值替换成第一个字符所在存储区的地址。
	4、字符串面值的内容在程序执行过程中不可以改变。


*************
//字符串演示
#include <stdio.h>

int main(){
    printf("%p\n","abc");      // 字符a的地址
    printf("%p\n","abc" + 3);  // \0 地地址
    printf("%d\n",*("abc" + 3)); // 寻址 结果为0
//  *"abc" = 'x';       // 将a换为x 出现错误！
    return 0;
}

*************

	5、程序中多个内容一样的字符串字面值在程序执行的时候其实是同一个。
	6、并列写在一起的多个字符串面值会被编译器合并成一个。
	7、字符数组也可以用来表示字符串。只有包含'\0'字符的字符数组才可以代表字符串。
	8、可以采用字符字面值对字符数组进行初始化，
 	   这个时候字符串字面值里的'\0'字符也会被初始化到字符数组里。

	9、字符数组里的字符串内容可以修改。

	10、可以用 %s 作为占位符把字符串里的所有字符显示在屏幕上。

*****************

int main(){
    char str[] = "xyz";
    printf("sizeof(str) is %d\n",sizeof(str));
    str[0] = 'a';
    printf("%s\n",str);
    return 0;
}
***************




作业：
	编写函数把一个数组里的所有存储区内容前后颠倒。
		如数组里原有内容是 1 2 3 4 5 
		颠倒后的内容为 5 4 3 2 1 
	要求用返回值表示处理后的数组，用指针编写程序。


【Gang】
int reverse(int *p_num){
    int num = 0;
    int arr[5] = {0}; 
    for (num = 0;num <= 4;num++){
         arr[4 - num] = *(p_num + num);
    }   
    for(num = 0;num <= 4;num++){
        printf("%d ",arr[num]);
    }   
}
int main(){
    int arr[] = {1,2,3,4,5};
    reverse(arr);
    printf("\n");

    return 0;
}

//Mr.Yang

// task of pointers
#include<stdio.h>
int *reverse(int *p_num,int size){
    int tmp = 0;
    int *p_start = p_num;           //数组第一个存储区
    int *p_end = p_num + size - 1;  //数组最后一个存储区

    while (p_start < p_end){    
        tmp = *p_start;             //交换头尾指针内容
        *p_start = *p_end;
        *p_end = tmp;
        p_start++;
        p_end--;
    }   
    return p_num;
}

int main(){
    int num = 0;
    int arr[] = {1,2,3,4,5};
    int *p_num = reverse(arr,5);
    for(num = 0;num <= 4;num++){
        printf("%d ",*(p_num + num));
    }   
    printf("\n");
    return 0;
}





/**************************************************************************/
*									   *		
*				day_11					   *	
*									   *
/**************************************************************************/

	
	一、字符串函数
	二、指针数组
	三、主函数参数
	


			/*一、字符串函数*/
	1、C语言中不可以使用操作符操作字符串，应该使用一组标准函数。
	2、为了使用这些标准函数，需要包含/* string.h 头文件 */。

	3、strlen	统计字符串里有效字符的个数(\0 前面的字符)。
			和sizeof关键字不同。

	4、strcat	合并两个字符串。有可能修改不属于数组的存储区，
			这会造成严重后果。

	   strncat	功能和strcat类似，但是可以避免修改不属于数组的存储区。
					
	5、strcmp	用来比较两个字符串的大小。	
				返回值是1表示前一个字符串大，
				返回值是-1表示后一个字符串大，
				返回值是0表示一样大。

	   strncmp	比较两个字符串的前n个字符。

	6、strcpy	把字符串复制到字符数组里。
			这个函数也可能修改不属于数组的存储区，这可能导致严重错误。


	   strncpy	可以只拷贝字符串里的前n个字符。
	
	7、memset	可以把字符数组里前n个存储区都设置成同一个字符。

	8、strstr	在一个大字符串里查找某个小字符串的位置。
			如果没有找到则返回NULL
	


****************

//字符串函数演示
#include<stdio.h>
#include<string.h>
int main(){
    char str[10] = "xyz";
    int len = strlen(str);      //strlen 统计有效字符个数
    printf("lenth is %d\n",len);
    printf("sizeof(str) is %d\n",sizeof(str));//sizeof统计数组所有字符个数

    printf("%s\n",strcat(str,"abc"));   //前一个参数必须是字符串数组。
    printf("%s\n",str);         //效果与上相同。

    printf("比较结果是%d\n",strcmp("abc","abd"));

    printf("%s\n",strcpy(str,"123456")); //字符串复制到字符数组里
    printf("%s\n",str);     //效果同上 ，与用字符串初始化数组效果相同。

    memset(str,'h',10);     //设置数组为10个 h
    printf("%s\n",str);

    printf("%s\n",strstr("abcdefghijklmn","def"));  //效果从def一直打印到末尾

    return 0;

}

**********************
运行结果：
lenth is 3
sizeof(str) is 10
xyzabc
xyzabc
比较结果是-1
123456
123456
hhhhhhhhhh
defghijklmn

**********************



	其他字符串相关函数(不需要string.h头文件)

	1、sprintf		按格式把多个数字打印到字符数组里形成字符串。

	2、sscanf		按格式从字符串里得到多个数字并记录到存储区里。


***************
#include<stdio.h>

int main(){
    char str[20] = {0};
    printf("%d %g %c\n",34,5.4f,'u');
    
    sprintf(str,"%d %g %c\n",34,5.4f,'u');  //将三个数字形成字符串打印到数组里
    printf("%s\n",str);     //两行效果同上面一行

    int num = 0;
    float fnum = 0.0f;
    char ch = 0;
    sscanf("5.4 p 67","%g %c %d",&fnum,&ch,&num);
    printf("%c %d %g\n",ch,num,fnum);

    return 0;
}

*********************
运行结果：
34 5.4 u
34 5.4 u

p 67 5.4
*********************


	
	以下俩函数可以把字符串里的数字转换成数字类型。
	为了使用它们，需要包含stdlib.h头文件。

	atoi		可以把字符串里的整数转换成整数类型。

	atof		可以把字符串里的浮点数转换成双精度浮点类型	

*****************
#include<stdio.h>
#include<stdlib.h>

int main(){
    int num = atoi("34adsgsd");
    printf("num is %d\n",num);
    
    double dnum = atof("23.67dsgj");
    printf("dnum is %lg\n",dnum);
    return 0;
}
******************
运行结果：
num is 34
dnum is 23.67
******************




【练习】

编写程序从键盘的到5个考试成绩，把他们按照如下格式拼凑成一个字符串

	67，98，34，76，93

【Gang】

#include<stdio.h>

int main(){
    char str[5] = {0};
    int a,b,c,d,e;
    printf("plz input five scores:");
    scanf("%d%d%d%d%d",&a,&b,&c,&d,&e);
    sprintf(str,"%d,%d,%d,%d,%d",a,b,c,d,e);
    printf("%s\n",str);

    return 0;
}


//Mr.Yang
#include<stdio.h>
#include<string.h>
int main(){
    char tmp[10] = {0},grades[30] = {0};
    int num = 0,grade = 0;
    for (num = 1;num <= 5;num++){
        printf("plz input a grade:");
        scanf("%d",&grade);
        sprintf(tmp,"%d,",grade);   //将输入的一个成绩打印入tmp数组中
        strcat(grades,tmp);         //将tmp中的字符合并入grade数组中
    }   
    grades[strlen(grades) - 1] = 0;// 将最后一个逗号赋值为0
    printf("%s\n",grades);
    return 0;
}




************************************************
			/*获得字符串fgets*/

	1、fgets函数可以从键盘得到一个字符串并记录到一个数组里。
		这个函数可以避免出现scanf函数的问题(不能录入空格等)

	2、这个函数需要三个参数：
		a.数组名称
		b.数组里的存储区个数。
		c.用stdin表示键盘
	    [e.g.] fgets(str,10,stdin);
	
	3、如果用户输入的内容不足以充满数组，
	   计算机把用户最后输入的回车字符也记录到数组里。
	4、如果输入内容超过数组容量就把后面的内容留在输入缓冲区里等待下次读取。
	5、每次使用万fgets函数后都需要清理输入缓冲区里可能存在的多余数据。
		并且只有确保有多余数据的时候才应该清理。
*****************

//获得字符串演示

#include<stdio.h>
#include<string.h>
int main(){
    char str[10] = {0}; 
    printf("plz input a string:");
//  scanf("%s",str);
    
    fgets(str,10,stdin);
    if(strlen(str) == 9 && str[8] != '\n'){ //确保有多余数据的时候，才清理
        scanf("%*[^\n]");    
        scanf("%*c");
    }   
    printf("%s\n",str);
    
    printf("plz input another string:");
    fgets(str,10,stdin);
    printf("%s\n",str);
    return 0;
}

***************


【练习】
编写模拟登陆程序：
	给用户三次机会，每次要求输入用户名和密码。
	如果三次都失败就提示登陆失败，否则提示登陆成功。
	正确的用户名是admin	正确的密码是123456

//模拟登陆程序、
#include<stdio.h>
#include<string.h>
int main(){
    char usr[10] = {0},pw[10] = {0};
    int i = 0;
    for(i = 1;i <= 3;i++){
            printf("plz input user name:");
            fgets(usr,10,stdin);
            if(strlen(usr) == 9 && usr[8] != '\n'){//clean 
                scanf("%*[^\n]");
                scanf("%*c");
            }   
            if(strcmp(usr,"admin\n")){   
                continue;
            }   

            printf("plz input passward:");
            fgets(pw,10,stdin);
            if(strlen(pw) == 9 && pw[8] != '\n'){//clean 
                scanf("%*[^\n]");
                scanf("%*c");
            }   
            if(strcmp(pw,"123456\n")){   
                continue;
            }   
            break;
    }   
    if(i <= 3){ //异常结束 登陆成功
        printf("succed login\n");
    }   
    else{   //正常结束 登陆失败
        printf("fail to login\n");
    }   

    return 0;
}



*****************************************
		
			
			/*二、字符指针数组*/
	1、指针数组中每个存储区是一个指针类型存储区。
	2、字符指针数组里包含多个字符类型指针，每个指针可以用来代表一个字符串。
	3、字符指针数组就可以用来代表多个相关字符串。

//字符指针数组演示

#include<stdio.h>

int main(){
    char *strs[5] = {"abc","def","hij","klm","xyz"};
    int num = 0;
    for(num = 0;num <= 4;num++){
        printf("%s\n",strs[num]);
    }   
    return 0;
}


*********************************************

			/*三、主函数参数*/

	1、主函数的第二个参数就是一个字符指针数组。
	    int main(int argc,char *argv[])
	
	2、第一个参数表示第二个参数里有多少个指针


//主函数参数演示
#include<stdio.h>
int main(int argc,char *argv[]){ // 1整数，2字符指针数组
	//第一个参数表示第二个参数里有多少个指针
	int num = 0;
	for(num = 0;num <= argc - 1;num++){
		printf("%s\n",argv[num]);

	}
	return 0;
}








预习：
	1、宏
	2、条件编译
	3、多文件编程

作业：
	1、把一个字符串里的考试成绩拆出来，
	 计算并打印其和。


【Gang】
#include <stdio.h>
#include <string.h>
int main(){
    int a,b,c,d,e,sum;
    sscanf("50,60,70,80,90","%d,%d,%d,%d,%d",&a,&b,&c,&d,&e);
    sum = a + b + c + d + e;

    printf("sum = %d\n",sum);
    return 0;
}


//Mr.Yang
#include <stdio.h>
#include <string.h>						
int main(){
    int sum = 0;
    char grades[] = "10,20,30,40,50,60";
    char *p_grade = grades;
    while(1){   //死循环
        sum += atoi(p_grade);
        p_grade = strstr(p_grade,","); //在字符串指针数组中找到逗号
        if(!p_grade){   //处理没找到逗号的情况
            break;
        }   
        p_grade++;
    }   
    printf("sum = %d\n",sum);
    return 0;
}





/**************************************************************************/
*									   *		
*				day_12					   *	
*									   *
/**************************************************************************/


	一、预处理指令
	二、宏操作符
	三、条件编译
	四、多文件编程




		
			/*一、预处理指令*/
	1、#define预处理指令用来定义宏。
	2、宏可以用来给数字起名字。

***********
//宏演示1
#include <stdio.h>
#define     PI      3.14f
int main(){
    int radius = 0;
    printf("plz input radius:");
    scanf("%d",&radius);
    printf("%g\n",2*PI*radius);
    return 0;
}
*********************

	3、宏名称通常都是大写的。并且没有空格
	4、用宏给数字起名字的语句不能包含复制操作符。
	5、可以在编译命令中使用-D选项定义宏。
		
		【e.g.】gcc -DSIZE=5 02hong.c


	6、程序中有些数字在编写时无法确定，只有在编译的时候才知道。这种数字就应该采用宏表示。

	7、宏还可以给计算公式起名字
		用宏的参数表示计算公式里的未知数字。

************
//宏演示2
#include <stdio.h>
#define     PI      3.14f
#define     CIRCLE(r)   2 * PI * r
int main(){
    int radius = 0;
    printf("plz input radius:");
    scanf("%d",&radius);
    printf("%g\n",CIRCLE(radius));
    return 0;
}
**************

	8、宏的参数不一定代表数字，所以它没有类型名称。
	9、宏不可以使用自己的存储区和函数进行数据传递。
	10、宏没有形参也没有用来存放返回值的存储区。
	11、能当作数字使用的宏必须编写成表达式。
	12、宏的参数代表的就是函数的存储区，可以直接修改内容。
*************
//宏演示3
#include<stdio.h>
#define     ABS(n)      n >= 0 ? n : 0 - n
#include<stdio.h>
#define     ABS(n)      n >= 0 ? n : 0 - n
#define     NEG(n)      n = 0 - n
void neg(int *p_num){           //利用指针形参跨函数使用存储区
    *p_num = 0 - *p_num;
}

int abs(int num){
    if(num >= 0){ 
        return num;
    }   
    else{
        return 0 - num;
    }   
}
int main(){
    int num = 0;
    printf("plz input a num:");
    scanf("%d",&num);
    printf("abs(num) is %d\n",abs(num));
    printf("ABS(num) is %d\n\n",ABS(num));
    neg(&num);
    printf("NEG(num) is %d\n",num);
    NEG(num);
    printf("NEG(num) is %d\n",num);
    return 0;
}

*****************
	

【练习1】
	编写一个宏计算两个整数相减的结果。
#include <stdio.h>
#define     SUB(a,b)    a - b
int main(){
    int a = 0,b = 0;
    printf("plz input two numbers:");
    scanf("%d%d",&a,&b);
    printf("result is %d\n",SUB(a,b));
    return 0;
}
			/*    gcc -E 文件名 查看编译器运行步骤	*/
	13、因为宏存没有储区用来存放返回值，所有不能保证优先计算宏内部的操作符。
	   所以能当作数字使用的宏必须写在小括号里。(保证宏的优先级)

***********
#include <stdio.h>
#define     SUB(a,b)    ((a) - (b))
int main(){
    printf("result is %d\n",SUB(10,7));
    printf("result is %d\n",20 - SUB(10,7));
    printf("result is %d\n",SUB(20,10 - 7));
    return 0;
}
************

	14、因为宏没有形参，所有不能保证优先计算参数内部的操作符。
	   所以能当作数字使用的宏参数必须写在小括号里。(保证宏的优先级)

【练习】

	用宏编写计算一个数的平方
#include <stdio.h>
#define     SQU(num)        ((num) * (num))

int main(){
    int num = 5;
    printf("10^2 = %d\n",SQU(10));
    printf(" (++num) * (++num) =  %d\n",SQU(++num)); // 7 * 7
    return 0;

}

	15、不要把自增或自减的结果作为宏的参数使用。




***********************************

			/*二、宏操作符*/

	1、#是一个宏操作符，它可以把宏的参数转换成字符串字面值。

	2、##也是一个宏操作符，它可以把一个代表表示符的参数和其他连接成为新的标识符

//宏操作符演示
#include<stdio.h>
#define     STR(n)      #n
#define     LOCAL(n)    l_##n
int main(){
    STR(2 + 3);     // int num = 0;
    int num = 0;
    int LOCAL(num) = 0; //int l_num = 0;
    return 0;
}



********************



			/*三、条件编译*/

	1、条件编译可以在编译的时候从几组语句中选择一组编译，忽略其他组。

	#ifdef/#ifndef...#else...#endif

	以上结构可以在编译时根据一个宏是否被定义过从粮足语中选择一组编译。
	
	如果最前面的预处理指令选择#ifdef就表示如果它后面宏被定义过时，编译前一组语句，否则编译后一组语句。

	如果选择#ifndef刚好相反。

//条件编译演示
#include<stdio.h>
int main(){
#ifdef    YI
    printf("1\n");
#else    
    printf("2\n");
#endif
    return 0;
}

**********************

【练习】
	编写点菜程序：
	1表示龙虾，2表示小鸡炖蘑菇。
/*点菜程序：
    1表示龙虾   2表示小鸡炖蘑菇
    赵 1 无 2 真没有
    其他1 有 2 无
*/
#include<stdio.h>
int main(){
    int order = 0;
    printf("请点菜：");
    scanf("%d",&order);
#ifdef  ZHAO
    if (order == 1){ 
        printf("没有\n");
    }   
    else{
        printf("真没有\n");
    }   
#else
    if (order == 1){ 
    printf("有\n");
    }   
    else{
    printf("没有\n");
    }   
#endif
    return 0;
}


****************************


	2 #if...#elif(任意多次)...#else...#endif
	  以上结构可以根据任意逻辑表达式从多组语句中选择一组编译。



【练习】
	过季商店	8折
	普通商店	原价
	精品商店	1.2

打印当前商店的折扣
//条件编译演示2
#include<stdio.h>

int main(){
#if     defined(GONGCHANG)      //将宏名称转换成布尔值
    printf("80%%\n");
#elif   !defined(GONGCHANG) && !defined(JINGPIN)
    printf("100%%\n");
#else
    printf("120%%\n");
#endif
    return 0;
}
********************
gcc 09cond.c
./a.out
运行结果：100%

gcc -DGONGCHANG 09cond.c
./a.out
运行结果：80%

gcc -DJINGPIN 09cond.c
./a.out
运行结果：120%

*********************



			/*四、多文件编程*/

	1、多文件编程时，每个文件里可以包含多个函数，一个函数只能属于一个文件。
	
           多文件编程步骤：
		(1).把所有函数分散在多个不同的源文件里
		  (主函数通常单独放在一个文件里)

		(2).为每个源文件白哪些配对的头文件，
		    所有不分配内存的内容都可以写在头文件里,
		    至少应该包含配对源文件里的所有函数声明。
		   (主函数所在的文件不需要配对的头文件)

		(3).为每个源文件包含必要的头文件(配对头文件是必要头文件,
		    如果源文件里使用了头文件中声明的函数则它也是必要头文件)	


	2、可以在gcc命令后列出所有源文件名称，用这种方法可以编译多文件程序。

//多文件编程演示 
//10duo.c
#include <stdio.h>
#include "11add.h"
int main(){
    int num = add(2,6);
    printf("num is %d\n",num);
    return 0;
}

//11add.c
#include "11add.h"
int add(int num,int num1){
    return num + num1;
} 

//11add.h
int add(int,int);


	
	
	3、可以把多文件程序的编译过程记录在Makefile里，
	   然后使用make工具根据Makefile文件内容对多文件程序进行编译。

	4、应该把头文件内容包含在预处理指令中，
	   这样可以保证不论源文件中多少次包含头文件都只会编译一次。
//11add.h
#ifndef     __11ADD_H__
#define     __11ADD_H__
int add(int,int);   
#endif  //__11ADD_H__



	5、头文件里使用的宏名称应该根据文件路径得到。

【练习】
	编写函数从键盘得到一个整数，并把这个整数传递给调用函数

	要求用多文件编程方式实现。


//多文件编程
//12num.c
#include <stdio.h>
#include "12get.h"
int main(){
    int num = print();
    printf("num is %d\n",num);
    return 0;
}

//12get.c
#include <stdio.h>
#include "12get.h"
int print(void){
    int num = 0;
    printf("plz input a number:");
    scanf("%d",&num);
    return num;
}

//12get.h
#ifndef     __12GET_H__
#define     __12GET_H__
int print(void);
#endif




	【tips】
		如果一个源文件里希望使用另外一个源文件里声明的全局变量就需要使用
	extern 关键字再次声明那个变量。

		2、使用 extern 关键字声明变量的语句不会分配内存。
			(可以转移到头文件中)


//多文件编程  改~
//12num.c
#include <stdio.h>
#include "12get.h"
//extern int num;     //一个源文件想使用另外一个源文件的全局变量,需要再次声明。
			(可以转移到头文件中)
int main(){
    print();
    printf("num is %d\n",num);
    return 0;
}

//12get.c
#include <stdio.h>
#include "12get.h"
int num;		//改为全局变量	
void print(void){
    printf("plz input a number:");
    scanf("%d",&num);
}

//12get.h
#ifndef     __12GET_H__
#define     __12GET_H__
extern int num;		
int print(void);
#endif	   //__12GET_H__



*************************************
预习：
	结构体、枚举和联合。

作业：
	编写宏实现字符大小写之间的转换。

//宏编程
#include<stdio.h>
#define     SWAP1(ch)   ch >= 'a' && ch <= 'z' ? ch + 'A' - 'a' : 0 
#define     SWAP2(ch)   ch >= 'A' && ch <= 'Z' ? ch + 'a' - 'A' : 0
int main(){
    char ch = 0;
    printf("plz input a char:");
    scanf("%c",&ch);
    if (ch >= 'a' && ch <= 'z'){
        printf("%c\n",SWAP1(ch));
    }   
    else if (ch >= 'A' && ch <= 'Z'){
        printf("%c\n",SWAP2(ch));
    }
    else{
	printf("ERROR\n");
    }   
    return 0;
}

//Mr.Yang
#include <stdio.h>
#define     CHR(ch)     ((ch) >= 'a' && (ch) <= 'z' ? (ch) +'A' -'a' : (ch) - 'A' +'a')
int main(){
    char ch = 0;
    printf("plz input a char:");
    scanf("%c",&ch);
    printf("Change after is: %c\n",CHR(ch));
    return 0;
}


//多文件编程
//tra.c
#include <stdio.h>
#include "tra.h"
char ch; 
void print(void){
    printf("plz input a letter:");
    scanf("%c",&ch);
    if (ch >= 'A' && ch <= 'Z'){    //大写 => 小写
        ch = ch + 'a' - 'A';
    }   
    else if(ch >= 'a' && ch <= 'z'){ // 小写 => 大写    
        ch = ch + 'A' - 'a';
    }   
}

//main.c
#include <stdio.h>
#include "tra.h"
int main(){
    print();
    printf("corresponding letter is %c\n",ch);
    return 0;
}

//tra.h
#ifndef     __TRA_H__
#define     __TRA_H__
extern char ch; 
void print(void);
#endif      //__TRA_H__







/**************************************************************************/
*									   *		
*				day_13					   *	
*									   *
/**************************************************************************/



	一、结构体
	二、结构体指针
	三、结构体应用
	四、数据对齐
	五、数据补齐


				/*一、结构体*/

	1、C语言可以在一个存储区里存放多个相关数字。
	2、这种存储区的类型叫做结构体，这种类型需要在程序中创建。
	3、结构体存储区里可以包含多个子存储区，每个存储区可以用来记录一个数字。
	4、不同子存储区的类型可以不同，子存储区也可以是结构体类型。
	5、结构体声明语句用来创建结构体类型。
	6、结构体声明语句需要使用 struct 关键字。
	7、结构体声明语句中的变量声明语句不会分配内存，
	     他们只是表示结构体内部的所有子存储区类型。可以写在头文件里。
	8、结构体类型可以用来声明/*结构体变量*/，结构体变量真正分配了内存，可以用来存放数字。
	9、struct 关键字和结构体类型名称合起来才可以作为/*类型名称*/使用。
	10、typedef 关键字可以用来给现有类型名称起别名。别名可以代替原有类型名称使用。
	11、可以把结构体声明语句和起别名的语句合并成为一条语句，这个时候可以省略结构体本身的名称。

	12、C语言里不允许结构体内部包含函数！！！

*************
//结构体演示
#include<stdio.h>
/*  struct person{
        int age;    //三个子存储区 只表示类型~
        float height;   //不分配内存~
        char name[10];  //可以写在头文件里~
    };
typedef struct person   people;//起别名 people;
效果等同与下*/
typedef struct /*person省略*/{
    int age;
    float height;       //结构体声明语句与起别名语句合并
    char name[10];
}people;

int main(){
//  struct person prn;  //结构体变量prn
    people prn1;	//结构体变量prn1
    return 0;
}
********************

	13、结构体变量也应该初始化，采用数组初始化的语法进行初始化。
	14、结构体变量通常不会作为整体使用，一次通常只使用其中某个子存储区。
	15、可以在结构体变量名称后加 . 再加子变量名称的方法表示结构体内部的某个子存储区
	
*****************
#include<stdio.h>
typedef struct /*person省略*/{
    int age;
    float height;       //结构体声明语句与起别名语句合并
    char name[10];
}people;

int main(){
    people prn1 = {20,1.73f,"abc"};
    printf("age is %d\n",prn1.age);
    printf("height is %g\n",prn1.height);
    printf("name is %s\n",prn1.name);
    return 0;
}

****************

【练习】
	从键盘上得到一个人的年龄，身高，姓名。

*****************
#include<stdio.h>
typedef struct /*person省略*/{
    int age;
    float height;       //结构体声明语句与起别名语句合并
    char name[10];
}people;

int main(){
    people prn1 = {20,1.73f,"abc"};
    printf("plz input age:");
    scanf("%d",&(prn1.age));
    printf("plz input height:");
    scanf("%g",&(prn1.height));
    scanf("%*[^\n]");   //清理
    scanf("%*c");       //缓存
    printf("plz input name:");
    fgets(prn1.name,10,stdin);
    printf("age is %d\n",prn1.age);
    printf("height is %g\n",prn1.height);
    printf("name is %s\n",prn1.name);
    return 0;
}
***************


	16、同类型结构体变量之间可以直接赋值。
		【e.g.】 prn2 = prn1;


                      

			/*二、结构体指针*/

	1、结构体指针可以记录一个结构体存储区的地址。
	2、当结构体指针和结构体存储区捆绑以后可以在结构体指针后加 -> 
		再加子存储区名称来表示这个子存储区。

*****************
//struct
#include<stdio.h>
typedef struct{
    int age;
    float height;
    char name[10];
}person;

int main(){
    person prn = {19,1.68,"abc"};
    person *p_person = &prn;       //声明结构体指针
    printf("%d\n",p_person->age);
    printf("%g\n",p_person->height);
    printf("%s\n",p_person->name);
    return 0;
}
**************

【练习】
	(1)、声明一个结构体，这个结构体声明的变量可以记录一个点的位置。
	   再声明一个结构体，这个结构体声明的变量可以记录一个水平长方形的位置。
	
	(2)、从键盘得到两个点的位置 算出他们中间点的位置 并打印
	   (用结构体指针和结构体变量分别表示)

//练习
#include<stdio.h>
typedef struct{
    int row;
    int col;
}point;

typedef struct{
    point pt1,pt2;  
}rect;
/*方法一：用结构体变量。
int main(){
    point pt1 = {0,0},pt2 = {0,0},pt_mid = {0,0};
    printf("plz input the adress of pt1:");
    scanf("%d%d",&(pt1.row),&(pt1.col));
    printf("plz input the adress of pt2:");
    scanf("%d%d",&(pt2.row),&(pt2.col));
    pt_mid.row = (pt1.row + pt2.row) / 2;
    pt_mid.col = (pt1.col + pt2.col) / 2;
    printf("middle of two point is %d %d\n",pt_mid.row,pt_mid.col);
    return 0;
}
*/
//方法二：结构体指针。
int main(){
    point pt1 = {0,0},pt2 = {0,0},mid = {0,0};
    point *p_pt1 = &pt1;
    point *p_pt2 = &pt2;
    point *p_mid = &mid;
    printf("plz input the adress of pt1:");
    scanf("%d%d",&(pt1.row),&(pt1.col));
    printf("plz input the adress of pt2:");
    scanf("%d%d",&(pt2.row),&(pt2.col));
    p_mid->row = (p_pt1->row + p_pt2->row) / 2;
    p_mid->col = (p_pt1->col + p_pt2->col) / 2;
    printf("middle of two point is %d %d\n",p_mid->row,p_mid->col);
    return 0;
}

		


	
			/*三、结构体的应用*/
	//3.1结构体作形参
	1、结构体变量可以作为形参使用。(很麻烦~)
	2、采用结构体指针作为形参可以避免结构体做形参时，时间和空间的浪费。
	3、结构体指针做形参是尽量加 const 关键字。
			（被调用函数) 
			      ^  传					
			      |  递				
		          (调用函数） 


**************
//结构体练习
#include<stdio.h>
typedef struct{
    int row,col;
}pt;
/*ONE 结构体做形参 not good!
void print(pt pt1){
    printf("(%d, %d)\n",pt1.row,pt1.col);
}
int main(){
    pt pt1 = {4,7};
    print(pt1);
    return 0;
}
*/
//TWO 结构体指针做形参
void print(const pt *p_pt){ //结构体指针做形参时，尽量加const关键字。
    printf("(%d, %d)\n",p_pt->row,p_pt->col);
}
int main(){
    pt pt1 = {4,7};
    print(&pt1);
    return 0;
}
********************	
		
	//3.2结构体作返回值。	
	4、可以把结构体变量的内容整个作为返回值使用，
	    但是这样也会造成时间和空间的浪费。
	5、可以用结构体存储区的地址作为返回值把结构体内容传递给调用函数，
	    这样可以避免浪费。
	6、不可以把局部结构体变量的地址作为返回值使用。
			（被调用函数) 
			      |  传					
			      V	 递	 
			  (调用函数）	

#include<stdio.h>
typedef struct{
    int row,col;
}pt;


void print(pt *p_pt){ //存储区内容变化，不加const关键字。
    printf("(%d, %d)\n",p_pt->row,p_pt->col);
}

/*ONE结构体变量作返回值
pt read(void){
    pt pt1 = {0};
    printf("plz input adress of the point:");
    scanf("%d%d",&(pt1.row),&(pt1.col));
    return pt1;
}*/

//TWO
pt *read(pt *p_pt){
    printf("plz input adress of the point:");
    scanf("%d%d",&(p_pt->row),&(p_pt->col));
    return p_pt;

}
int main(){
    pt pt1 = {0},*p_pt = NULL;
    p_pt = read(&pt1);
    print(p_pt);
    return 0;
}
    

**********



【练习】
	编写函数计算水平长方形面积
	  数值从调用函数得到。

************
//练1
#include<stdio.h>
typedef struct{
    int row,col;
}pt;
typedef struct{
    pt pt1,pt2;
}rect;

int area(const rect *p_rect){  //计算面积
    int ret = (p_rect->pt1.row - p_rect->pt2.row) * (p_rect->pt1.col - p_rect->pt2.col);
    return ret >= 0 ? ret : 0 - ret;
}

int main(){
    rect r = {0};
    printf("请输入长方形的位置：");
    scanf("%d%d%d%d",&(r.pt1.row),&(r.pt1.col),&(r.pt2.row),&(r.pt2.col));
    printf("面积是：%d\n",area(&r));  
    return 0;
}

*****************




【练习】
	根据两个已知点计算中点位置，并把结果传递给调用函数。

************
//练2
#include<stdio.h>
typedef struct{
    int row,col;
}pt;

pt *midpt(const pt *p_pt1,const pt *p_pt2,pt *p_mid){
    p_mid->row = (p_pt1->row + p_pt2->row) / 2;
    p_mid->col = (p_pt1->col + p_pt2->col) / 2;
    return p_mid;
}

int main(){
    pt pt1 = {0},pt2 = {0},mid = {0}, *p_pt = NULL;
    printf("plz input a point :");
    scanf("%d%d",&(pt1.row),&(pt1.col));
    printf("plz input another point :");
    scanf("%d%d",&(pt2.row),&(pt2.col));
    p_pt = midpt(&pt1,&pt2,&mid);
    printf("the middle point is (%d, %d)\n",p_pt->row,p_pt->col);
    return 0;
}

****************

	
		

			/*四、数据对齐*/
	1、任何一个存储区的地址必须是它自身大小的整数倍
	(double 类型存储区的地址只需要是4的整数倍)
	2、结构体内部子存储区通常也需要遵守数据对齐规则。
	3、数据对齐会造成结构体内部子存储区之间有空隙。
	
***************
//数据对齐演示
#include<stdio.h>
typedef struct{
    int num;
    char ch; 
}stru;

typedef struct{
    char ch; 
    int num;
    char ch1;
}stru1;

int main(){ 
    printf("sizeof(stru) is %d\n",sizeof(stru));
    printf("sizeof(stru1) is %d\n",sizeof(stru1));
    return 0;
}
**************
运行结果：
sizeof(stru) is 8
sizeof(stru1) is 12


***************
		
			/*五、数据补齐*/
	1、结构体存储区的大小必须是他内部占地最大基本类型存储区大小的整数倍。
	   (如果占地最大基本类型是double类型则之需要是4的整数倍就可以了。)
	2、数据补齐会造成结构体后面有浪费的字节。
	


【练习】
	编写函数从两个圆里找到面积比较大的，并返回给调用函数。


#include<stdio.h>
typedef struct{
    int row,col;
}pt;

typedef struct{
    pt center;	//结构体嵌套~
    int radius;
}circle;

const circle *larger(const circle *p_cl1,const circle *p_cl2){
    return p_cl1->radius >= p_cl2->radius ? p_cl1 : p_cl2;
}

int main(){
    circle cl1 = {0},cl2 = {0};
    const circle *p_cl = NULL;
    printf("piz input address of one circle:");
    scanf("%d%d%d",&(cl1.center.row),&(cl1.center.col),&(cl1.radius));
    printf("piz input address of another circle:");
    scanf("%d%d%d",&(cl2.center.row),&(cl2.center.col),&(cl2.radius));
    p_cl = larger(&cl1,&cl2);
    printf("result is ((%d, %d), %d)\n",p_cl->center.row,p_cl->center.col,p_cl->radius);
    return 0;
}






***************************************************
预习：
	1、枚举，联合
	2、二级指针
	3、函数指针
	4、回调指针
	5、动态内存分配


作业：
	编写函数从两个线段里挑 出比较长的并返回给调用函数。
	 线段长度的平方 = 行之差的平方 + 列之差的平方 
#include<stdio.h>.
typedef struct{
    int row,col;
}pt;

typedef struct{
    pt pt1,pt2;
}line;

const line *longer(const line *p_l1,const line *p_l2){
    int m = (((p_l1->pt1.row - p_l1->pt2.row) * (p_l1->pt1.row - p_l1->pt2.row)) + ((p_l1->pt1.col - p_l1->pt2.col) * (p_l1->pt1.col - p_l1->pt2.col)));
    int n = (((p_l2->pt1.row - p_l2->pt2.row) *(p_l2->pt1.row - p_l2->pt2.row)) + ((p_l2->pt1.col - p_l2->pt2.col) * (p_l2->pt1.col - p_l2->pt2.col)));
/*
    int m = sqrt(((p_l1->pt1.row - p_l1->pt2.row),2) + sqrt((p_l1->pt1.col - p_l1->pt2.col),2));
    int n = sqrt(((p_l2->pt1.row - p_l2->pt2.row),2) + sqrt((p_l2->pt1.col - p_l2->pt2.col),2));
*/
    return m > n ? p_l1 : p_l2;
}

int main(){
    line l1 = {0},l2 = {0};
    const line *p_l = NULL;
    printf("plz input 1st line :");
    scanf("%d%d%d%d",&(l1.pt1.row),&(l1.pt1.col),&(l1.pt2.row),&(l1.pt2.col));
    printf("plz input 2nd line :");
    scanf("%d%d%d%d",&(l2.pt1.row),&(l2.pt1.col),&(l2.pt2.row),&(l2.pt2.col));
    p_l = longer(&l1,&l2);
    printf("The longer is (%d, %d),(%d, %d)\n",p_l->pt1.row,p_l->pt1.col,p_l->pt2.row,p_l->pt2.col);
    return 0;
}

****************

//Mr.Yang
#include<stdio.h>
typedef struct{
    int row,col;
}pt;

typedef struct{
    pt pt1,pt2;
}line;

int len2(const line *p_l){
    return (p_l->pt1.row - p_l->pt2.row) * (p_l->pt1.row - p_l->pt2.row) + (p_l->pt1.col - p_l->pt2.col)*(p_l->pt1.col - p_l->pt2.col);
}

const line *longer(const line *p_l1,const line *p_l2){
    return len2(p_l1) > len2(p_l2) ? p_l1 : p_l2;
    
int main(){
    line l1 = {0},l2 = {0};
    const line *p_l = NULL;
    printf("plz input 1st line :");
    scanf("%d%d%d%d",&(l1.pt1.row),&(l1.pt1.col),&(l1.pt2.row),&(l1.pt2.col));
    printf("plz input 2nd line :");
    scanf("%d%d%d%d",&(l2.pt1.row),&(l2.pt1.col),&(l2.pt2.row),&(l2.pt2.col));
    p_l = longer(&l1,&l2);
    printf("The longer is (%d, %d),(%d, %d)\n",p_l->pt1.row,p_l->pt1.col,p_l->pt2.row,p_l->pt2.col);
    return 0;
}





/**************************************************************************/
*									   *		
*				day_14					   *	
*									   *
/**************************************************************************/	

	
	
	
	
			/*枚举和联合*/

	//枚举	enum
	1、枚举也可以用来创建新的数据类型
	2、枚举类型存储区就是一个整数类型存储区，
	   这种存储区里应该只能记录几个有限的整数。

	3、声明枚举类型时需要提供一组名称，每个名称对应一个整数。	
	    这些整数才可以放到枚举类型存储区里。
	4、声明枚举类型时需要使用 enum 关键字。
	5、枚举类型中第一个名字对应的整数是0，向后依次递增。
	6、可以在生命枚举类型时指定某个名称对应的数字，
           它后面的名称对应的数字也会随着改变。


****************
//枚举类型演示
#include<stdio.h>
int main(){
    enum /*season可以省略*/ {SPRING,SUMMER = 5,AUTUMN,WINTER};  //分别对应0123
    printf("spring is %d\n",SPRING);
    printf("summer is %d\n",SUMMER);
    printf("autumn is %d\n",AUTUMN);
    printf("winter is %d\n",WINTER);
    return 0;
}
***************

	//联合	union
	1、联合也可以用来创建新的数据类型。
	2、联合存储区可以当作多种不同类型存储区使用。
	3、声明联合的时候需要使用 union 关键字。
	4、联合中每个变量声明语句表示联合存储区的一种使用方法，
	    所有子变量的存储区是互相重叠的。
	5、联合存储区的大小是其中最大子变量存储区的大小。

**************
//联合演示
 #include <stdio.h>
typedef union {     //关键字不同
    char ch;        //其他类似与结构体
    int num;    
}un;     

 int main(){
    un un1;
    un1.num = 0;
    un1.ch = 'a';   //修改ch子存储区 上一个num存储区也受影响
    printf("un1.num is %d\n",un1.num);
    return 0;
 }
*************




			/*二级指针*/
	1、记录普通变量地址的指针叫做一级指针。
	2、二级指针可以记录一级指针的地址。二级指针声明的时候需要写两个*
	3、二级指针变量名称前加**可以表示捆绑的普通变量存储区。
	4、二级指针变量名称前加*表示捆绑的一级指针变量存储区。
	5、二级指针变量名称可以代表它自己的存储区。
	6、二级指针可以用来代表/*指针数组*/，但是不能代表二维数组。

***********
//二级指针代表指针数组
#include <stdio.h>

int main(int argc,char **argv){
    int num = 0;
    for (num = 0;num <= argc - 1;num++){
        printf("%s\n",*(argv + num));
    }   
    return 0;
}
**************


	7、二级指针通常作为函数的形参使用。
	     它可以让被调用函数修改调用函数的一级指针存储区。


*******************
//二级指针形参演示
#include <stdio.h>
void setnull(int **pp_num){
    *pp_num = NULL;
}
int main(){
    int num = 0;
    int *p_num = &num;
    setnull(&p_num);
    printf("p_num is %p\n",p_num);
    return 0;
}
**************


	8、无类型指针使用的时候有可能需要首先转换成二级指针然后再使用。 
	

【练习】
	将昨天作业用二级指针无返回值修改。



	
			/*函数指针*/
	
	
	1、C语言里函数也有地址。函数名称可以表示函数的地址，
	2、函数指针用来记录函数的地址，函数指针也需要先声明再使用。
	3、函数指针声明可以根据函数声明变化得到。
	4、函数指针也分类型，不同类型的函数指针适合与不同的函数捆绑。
	5、函数指针可以用来调用函数。

		声明函数指针方法： 返回值类型 /*删去函数名*/(*p_func)(形参) 
			被捆绑函数： int add(int num1,int num2)
			 函数指针 ： int (*p_func)(int, int)
	

***************
//函数指针演示
#include <stdio.h>
int add(int num1,int num2){
    return num1 + num2;
}
int main(){
    int (*p_func)(int, int) = NULL;     //声明函数指针并初始化
    printf("add is %p\n",add);
    p_func = add;           //函数指针和函数捆绑
    printf("4+9 is %d\n",p_func(4,9));
    return 0;
}
*************





	
			/*回调函数*/
	1、函数指针可以作为函数的形参使用。
	2、可以作为实际参数使用的函数叫做回调函数。



****************************
//回调函数演示
#include <stdio.h>
void print(int *p_num,int size){
    int num = 0;
    for (num = 0;num <= size - 1;num++){
        printf("%d ",*(p_num + num));
    }   
}

int main(){
    int arr[] = {1,2,3,4,5};
    print(arr,5);
    printf("\n");
    return 0;
}
/********************
*	| |         *
*   改 	| |   进    *
*	V V         *
********************/
#include <stdio.h>
void print_cb(int *p_num){
    printf("%d ",*p_num);
}
void for_each(int *p_num,int size){ //处理数组每一个存储区
    int num = 0;
    for (num = 0;num <= size - 1;num++) {
        print_cb(p_num + num);
    }   
}
int main(){
    int arr[] = {1,2,3,4,5};
    for_each(arr,5);
    printf("\n");
    return 0;
}
/********************
*	| |         *
*   改 	| |   进    *
*	V V         *
********************/
#include <stdio.h>
void print_cb(int *p_num){
    printf("%d ",*p_num);
}
void for_each(int *p_num,int size,void (*p_func)(int*)){    //处理数组每一个存>储区   
    int num = 0;
    for (num = 0;num <= size - 1;num++) {
        p_func(p_num + num);    //函数名称换为函数指针名称
    }   
}
int main(){
    int arr[] = {1,2,3,4,5};
    for_each(arr,5,print_cb);   //函数指针和print_cb函数捆绑
    printf("\n");
    return 0;
}

**********************






			/*动态内存分配*/
	1、动态内存分配可以在程序运行的时候临时决定需要分配多少个存储区。
	2、为了使用动态内存分配需要使用一组标准函数,
	    为了使用这组标准函数需要包含stdlib.h头文件。
	

	/*malloc函数*/ 可以动态分配一组连续的字节。
	1、这个函数需要一个整数类型参数表示要分配的字节个数。
	2、它的返回值是分配好的第一个字节的地址。如果分配失败返回的是 NULL。
	3、这个函数的返回值存放在一个无类型指针存储区里，
             需要转换成有类型指针然后才能使用。
	


			/*动态内存释放*/

	1、不使用的动态分配内存必须还给计算机。
	
	/*free函数*/ 可以用来释放动态分配内存
	1、这个函数需要动态分配内存的首地址作为参数。
	2、一起分配的内存必须一起释放。
	3、如果用指针作为参数调用free函数，则函数结束后指针成为野指针，须恢复成空指针。	
	


*****************
//动态分配内存演示
#include <stdio.h>
#include <stdlib.h>
int main(){
    int *p_num = (int *)malloc(5 * sizeof(int)); //分配5个int类型的内存
    //malloc分配的是无类型指针，需要强制类型转换
    int num = 0;
    if (p_num){         //分配内存成功
          for (num = 0;num <= 4;num++){
                *(p_num + num) = num + 1;
          }   
          for (num = 0;num <= 4;num++){
                printf("%d ",*(p_num + num));
          }   
          printf("\n");
        free(p_num);    //释放内存	
        p_num = NULL;	//指针恢复成空指针
    }   
    return 0;
}
*************
运行结果：
1 2 3 4 5
*************




	4、动态分配内存函数可以使用被调用函数动态分配的内存。


******************
//动态内存分配 演示
#include <stdio.h>
#include <stdlib.h>
int *read(void){
    int *p_num = (int *)malloc(sizeof(int));
    if (p_num) {
        printf("plz input a number:");
        scanf("%d",p_num);
    }   
    return p_num;   //如果分配不成功 返回值为NULL
}

int main(){
    int *p_num = read();
    if (p_num) {    //只处理分配成功的情况
        printf("%d\n",*p_num);
        free(p_num);    //释放内存
        p_num = NULL;   //指针恢复成空指针
    }   
    return 0;
}
********************




【练习】

	编写产生一张彩票，彩票里的所有数字要记录在动态分配内存里，
	彩票内容要传递给调用函数并打印在屏幕上。

//彩票3.0
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int *print(void){
    int *p_num = (int *)malloc(7 * sizeof(int));
    int num = 0;
    srand(time(0));
    if (p_num) {
        for (num = 0;num <= 6;num++){
            *(p_num + num) = rand() % 36 + 1;
        }   
    }   
    return p_num;
}

int main(){
    int num = 0;
    int *p_num = print();
    if (p_num){
        for(num = 0;num <= 6;num++){
            printf("%d ",*(p_num + num));
        }   
        printf("\n");
        free(p_num);
        p_num = NULL;
    }   
    return 0;
}


***************

【练习】

	编写函数根据两个已知点的位置计算中间点的位置，
	中间点的位置记录在动态分配内存里。
	把中间点位置传递给调用函数并打印。

******************
//昨天作业 改1.0
#include <stdio.h>
typedef struct{
    int row,col;
}pt;
typedef struct{
    pt pt1,pt2;
}line;
/* Mr.Yang
//计算线段长度平方的函数
int len2(const line *p_l) {
    return (p_l->pt1.row - p_l->pt2.row) * (p_l->pt1.row - p_l->pt2.row) + (p_l->pt1.col - p_l->pt2.col) * (p_l->pt1.col - p_l->pt2.col);
}
//挑出比较长线段的函数
void longer(const line *p_l1, const line *p_l2, line **pp_l) {
    *pp_l = (line *)(len2(p_l1) > len2(p_l2) ? p_l1 : p_l2);
}*/

void longer(const line *p_l1,const line *p_l2,line **pp_l){
    int m = (((p_l1->pt1.row - p_l1->pt2.row) * (p_l1->pt1.row - p_l1->pt2.row)) + ((p_l1->pt1.col - p_l1->pt2.col) * (p_l1->pt1.col - p_l1->pt2.col)));
    int n = (((p_l2->pt1.row - p_l2->pt2.row) *(p_l2->pt1.row - p_l2->pt2.row)) + ((p_l2->pt1.col - p_l2->pt2.col) * (p_l2->pt1.col - p_l2->pt2.col)));
     *pp_l =(line *)(m > n ? p_l1 : p_l2);
}

int main(){
    line l1 = {0},l2 = {0};
    line *p_l = NULL;
    printf("plz input 1st line:");
    scanf("%d%d%d%d",&(l1.pt1.row),&(l1.pt1.col),&(l1.pt2.row),&(l1.pt2.col));
    printf("plz input 2ed line:");
    scanf("%d%d%d%d",&(l2.pt1.row),&(l2.pt1.col),&(l2.pt2.row),&(l2.pt2.col));
    longer(&l1,&l2,&p_l);
    printf("The longer is (%d, %d),(%d, %d)\n",p_l->pt1.row,p_l->pt1.col,p_l->pt2.row,p_l->pt2.col);
    return 0;
}


**************
预习：
	文件操作


作业：
	编写字符串拷贝函数(新字符串记录在动态分配内存里)
	函数把新字符串传递给调用函数并打印。


/*编写字符串拷贝函数(新字符串记录在动态分配内存里)
    函数把新字符串传递给调用函数并打印。*/
【Gang】
#include <stdio.h>
#include <stdlib.h>
    int num = 0;
char *print(char *p_num){
    char *p_copy = (char *)malloc(10*sizeof(char));
    if (p_copy){
        for(num = 0;num <= 9;num++){
            *(p_copy + num) = *(p_num + num);
        }   
    }   
    return p_copy;
}   

int main(){
    char str[10] = {0};
    printf("plz input a string:");
    fgets(str,10,stdin);
    char *p_num = print(str);
    if (p_num){
        for(num = 0;num <= 6;num++){
            printf("%c ",*(p_num + num));
        }   
        printf("\n");
        free(p_num);
        p_num = NULL;
    }   
    return 0;
}

//Mr.Yang
//字符串拷贝作业
#include <stdio.h>
#include <stdlib.h>
char *mystrcpy(char *str){
    char *p_tmp = str,*p_dest = NULL;
    char *p_tmp1 = NULL;
    int cnt = 0;
    //计算字符串所占空间
    while (*p_tmp) {    //p_tmp指向'\0' 时 *p_tmp = 0
        cnt++;
        p_tmp++;    //指针后移
    }   
    cnt++;
    p_dest = malloc(cnt *sizeof(char));
    if (p_dest){
        p_tmp = str;    //p_tmp指针和原有字符串第一个存储区捆绑
        p_tmp1 = p_dest;
        while(*p_tmp){
            *p_tmp1 = *p_tmp;
            p_tmp++;
            p_tmp1++;
        }   
        *p_tmp1 = 0;    //在新字符串末尾加入"\0"
    }   
    return p_dest;
}
int main(){
    char *str = mystrcpy("abcdef");
    if (str){
        printf("%s\n",str);
        free(str);
        str = NULL;
    }   
    return 0;
}





/**************************************************************************/
*									   *		
*				day_15					   *	
*									   *
/**************************************************************************/	

	一、动态内存分配(续)
	二、文件
	

			/*一、动态内存分配(续)*/
	//calloc函数
	void *calloc(size_t n,size_t size);

	1、它可以把所有动态分配存储区的内容设置成 0。
	2、为了使用这个函数也需要包含stdlib.h头文件。
	3、它的返回值与malloc函数一样，是分配好的第一个字节的地址。
	   如果分配失败返回的是 NULL。
	4、它需要两个参数，第一个参数表示要分配的存储区个数，
			  第二个参数表示单个存储区的大小。


	//realloc函数
	1、它可以调整动态分配内存的大小。
	2、尽量少使用这个函数！！！






			/*二、文件*/

	1、文件里一定采用二进制方式记录数字。
	2、如果文件里所有字节都是字符的ASCII码，这种文件叫做//文本文件。
		文本文件以外的文件叫做//二进制文件。
	3、所有文件都可以采用二进制方式操作。
	4、文件操作基本步骤：
		(1)打开文件(fopen)
		(2)操作文件(fread/fwrite)
		(3)关闭文件(fclose)
	




	//fopen函数
	1、fopen函数需要两个参数：
		第一个代表要打开的文件路径，
		第二个代表打开方式(决定程序中可以怎么使用文件)。	
	2、打开方式有如下选择：
		"r"	只能查看文件内容而且只能从文件头开始，
			要求文件已经存在，如果不村在就会打开失败。	
		
		"r+"	比"r"多了修改功能(要求文件已经存在)。

		"w"	只能修改文件内容而且只能从文件头开始修改。
			如果文件还不存在就创建文件，
			如果文件存在就删除文件内容。
		
		"w+"	比"w"多了个查看目录。

		"a"	只能在文件末尾追加新内容。
			如果文件不存在就创建文件，
			如果文件存在就保留原有内容。

		"a+"	比"a"多了查看功能。

		"b"	可以和上面任何一种打开方式混合使用~~~
			它表示以二进制方式操作文件。

	3、fopen函数返回值是文件指针，只有文件指针才可以在程序中代表文件。
	4、fopen函数有可能失败，如果失败返回值是 NULL
		(类似与malloc函数)

	//fclose函数
	1、一旦完成对文件的操作后必须使用fclose函数关闭文件。
	2、fclose函数需要文件指针作为参数。
	3、文件关闭后文件指针成为野指针，必须恢复成空指针。
		(类似与free函数~)	
	



*******************

//文件操作代码框架
#include <stdio.h>
int main(){
    FILE *p_file = fopen("a.txt"/*文件路径*/,"w"/*操作方式*/);
    //文件指针打开文件
/*写法一
    if (p_file) {
        //文件打开成功
        fclose(p_file);     //打开的文件不关闭会造成内存泄露!!! 
        p_file = NULL;
    }
*/
//写法二：
    if (!p_file) {
        //文件打开失败
        return 0;
    }   
    //打开成功
    fclose(p_file);
    p_file = NULL;
    return 0;
}

*****************

		


		//文件操作
	1、文件操作分为两种:
		(I)  把内存中一组连续存储区的内容拷贝到文件里(写文件)
		(II) 从文件中把一组连续的内容拷贝到内存里(读文件)
	
	2、fwrite函数可以以二进制方式对文件进行写操作。
	   fread函数可以以二进制的方式对文件进行读操作。


		这两个函数都需要四个参数：
	 	
			a.	内存里第一个存储区的地址
			b.	内存里单个存储区的大小
			c.	希望操作的存储区个数
			d.	文件指针

	  它们的返回值表示实际操作的存储区个数。0 代表没有进行读写操作。



*************	
//fwrite演示
#include <stdio.h>

int main(){
    int arr[] = {1,2,3,4,5},size = 0;
    FILE *p_file = fopen("a.bin","wb");
    if (p_file) {
        size = fwrite(arr,sizeof(int),5,p_file);
//返回值表示实际操作的存储区个数   
        printf("size is %d\n",size);
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}
**************

【练习】
	编写程序从a.bin文件获得所有存储区的内容并把结果打印在屏幕上。

【Gang】
#include <stdio.h>
int main(){
    int arr[5] = {0},num = 0;
    int *p_num = arr;
    FILE *p_file = fopen("a.bin","rb");
    if(p_file){
        fread(arr,sizeof(int),5,p_file);
        for(num = 0;num <= 4;num++){
            *(p_num + num) = arr[num];
        }   
        for(num = 0;num <= 4;num++){
            printf("%d ",*(p_num + num));
        }   
        printf("\n");
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}


//Mr.Yang
#include <stdio.h>
int main(){
    int arr[5] = {0},num = 0;
    FILE *p_file = fopen("a.bin","rb");
    if(p_file){
        fread(arr,sizeof(int),5,p_file);
        for(num = 0;num <= 4;num++){
            printf("%d ",arr[num]);
        }   
        printf("\n");
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}
***************
运行结果：
size is 5
1 2 3 4 5
***************





******************
//文本文件
#include<stdio.h>
#include<string.h>
int main(){
    char str[] = "1,2,3,4,5";   //字符串字面值初始化数组
    FILE *p_file = fopen("a.txt","wb");
    if (p_file) {
        fwrite(str,sizeof(char),strlen(str)/*数出字符个数*/,p_file);
        fclose(p_file);
        p_file = NULL;
    }       
    return 0;
}
******************
运行结果
生成一个a.txt的文本



	//fprintf函数
	1、fprintf函数按照格式把数据记录到文本文件里。
	2、这个函数的第一个参数是一个文件指针，其他参数和printf函数的参数一样。


*************	
//文本文件演示
#include <stdio.h>

int main(){
    int arr[] = {1,2,3,4,5},num = 0;
    FILE *p_file = fopen("b.txt","w");
    if(p_file){
        for (num = 0;num <= 4;num++){
            fprintf(p_file,"%d ",arr[num]); //将数据记录到文件里
        }   
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}
*************



	//fscanf函数
	1、fscanf函数可以按照格式从文本文件里获得数据并记录到存储区里。
	2、这个函数的第一个参数是一个文件指针，其他参数和scanf函数一样。



*************
#include <stdio.h>
int main(){
    int num = 0,num1 = 0;
    FILE *p_file = fopen("b.txt","r");
    if (p_file) {
        for (num = 0;num <= 4;num++) {
            fscanf(p_file,"%d",&num1);  //将文件里的数据读到num1里
            printf("%d ",num1);
        }   
        printf("\n");
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}

*************



	
			/*文件的位置指针*/


	1、计算机里为每个打开的文件保留一个整数，这个整数表示下一次读写操作的开始位置。
	2、这个整数表示从文件头开始到这个位置为止中间包含的字节个数。
	3、这个整数叫做文件的位置指针。
	4、当从文件里获得n个字节或写入n个字节后，这个整数会增加n	
	    【e.g.】 	 b.txt
				
		1 2 3 4 5 
	       |
	       V
	    位置指针

	//ftell函数
	1、ftell函数可以获得当前位置指针的数值。
	

	//rewind函数
	1、rewind函数可以把位置指针的数值设置成 0


	//fseek函数
	1、fseek函数可以把位置指针设置成文件中的任何位置。
	2、fseek函数使用时需要指定一个基准位置和目标位置到基准位置之间的距离。

	SEEK_SET	0	把文件头作为基准位置
	SEEK_CUR	1	把当前位置作为基准位置
	SEEK_END	2	把文件尾作为基准位置

	   如果目标位置在基准位置后，则距离是正数。
	   如果目标位置在基准位置前，则距离是负数。
	
	   距离的数字代表两个位置之间包含的字节个数。


***************
//位置指针演示
#include <stdio.h>
int main(){
    char ch = 0;
    FILE *p_file = fopen("abc.txt","rb");
    if (p_file) {
        fseek(p_file,2,SEEK_SET);  //将位置指针置于文件头后2位
        printf("%ld\n",ftell(p_file));  //打印位置指针当前位置
        fread(&ch,sizeof(char),1,p_file);//读1个字符
        printf("%c\n",ch);
    
        fseek(p_file,4,SEEK_CUR);  //将位置指针置于当前位置后4位
        printf("%ld\n",ftell(p_file));
        fread(&ch,sizeof(char),1,p_file); 
        printf("%c\n",ch);
            
        fseek(p_file,-4,SEEK_END);  //将位置指针置于文件尾前4位
        printf("%ld\n",ftell(p_file));
        fread(&ch,sizeof(char),1,p_file);
        printf("%c\n",ch);

        rewind(p_file);         //把位置指针设置成0
        printf("%ld\n",ftell(p_file));
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}
************



【练习】
	编写模拟人员管理系统，可以把多个人员信息以二进制方式记录到文件里，
	每个人员信息包括整数类型的id，float 类型的salary 和最多9个字符的姓名
	文件内容可以追加。

#include <stdio.h>
typedef struct{
    int id; 
    float salary;
    char name[9];

}person;

int main(){
    person prn = {0};
    int choice = 0;
    FILE *p_file = fopen("person.bin","ab");
    if (p_file){
        while(1){
            printf("plz input id :");
            scanf("%d",&(prn.id));
    
            printf("plz input salary:");
            scanf("%g",&(prn.salary));
            scanf("%*[^\n]"); 
            scanf("%*c");     //清理
    
            printf("plz input name:");
            fgets(prn.name,9,stdin);
    
            fwrite(&prn,sizeof(person),1,p_file);   //将信息写如文件中
            printf("1 is continue 0 is do not:");
            scanf("%d",&choice);
            if (!choice) {
                break;
            }   
        }   
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;   
}





**********************************

作业：
	编写程序从person.bin文件里得到所有人员id并把他们打印在屏幕上。

【Gang】
#include <stdio.h>

int main(){
    int id = 0;
    FILE *p_file = fopen("person.bin","rb");
    if (p_file) {
        while(/*囧...循环体不会写T-T*/){
            fread(&id,sizeof(int),1,p_file);
            printf("%d\n",id);
            fseek(p_file,16,SEEK_CUR);
        }   
        fclose(p_file);
        p_file = NULL;
    }   

    return 0;
}
*************************
【改:】//循环体
        while(1){

            if(!fread(&id,sizeof(int),1,p_file)){
                break;//不能获得下一个id的时候结束循环。
            }
*************************

//Mr.Yang
//文件作业
#include <stdio.h>
typedef struct{
    int id;
    float salary;
    char name[10];
}person;

int main(){
    int id = 0;
    FILE *p_file = fopen("person.bin","rb");
    if(p_file){
        while(1){

            if(!fread(&id,sizeof(int),1,p_file)){
                break;//不能获得下一个id的时候结束循环。
            }
            printf("%d\n",id);
            fseek(p_file,sizeof(person) - sizeof(int),SEEK_CUR);
            //结构体大小 - int类型大小 = id 之间的距离
        }
    }
    return 0;
}










/**************************************************************************/
*									   *		
*				day_16					   *	
*									   *
/**************************************************************************/


【练习】
	编写程序实现文件拷贝功能
	程序必须可以按如下方式使用
	./a.out	   文件路径1(原文件)    文件路径2(新文件)



********************
//Mr.Yang
int main(int argc,char **argv){
    char buf[100] = {0};
    int size = 0;
    FILE *p_src = NULL,*p_dest = NULL;
    //打开原始文件
    p_src = fopen(*(argv + 1),"rb");
    if(!p_src){
        printf("原始文件打开失败\n");
        return 0;
    }
    //打开新文件
    p_dest = fopen(*(argv + 2),"wb");
    if(!p_dest){
        printf("原始文件打开失败\n");
        //关闭原始文件
        fclose(p_src);
        p_src = NULL;
        return 0;
    }
    while(1){
        size = fread(buf,sizeof(char),100,p_src);
        if (!size){
        //不能从原始文件里获得任何数字时，结束循环。
            break;
        }
        fwrite(buf,sizeof(char),size,p_dest);

    }
    //关闭新文件
    fclose(p_dest);
    p_dest = NULL;
    //关闭原始文件
    fclose(p_src);
    p_src = NULL;
    return 0;
}
****************** 


	项目：
	【贪吃蛇】
@  苹果
+  蛇头
-  蛇尾    


/*
	Mr.Yang贪吃蛇
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define		SIZE	  40
enum {UP = 5,DOWN =2 ,LEFT = 1,RIGHT = 3};
typedef struct{
    int row,col;
}pt;

typedef struct{
    pt head,tail;
}snake;
//part.1 设置蛇初始的位置
void init_snake(snake *p_snake){
	p_snake->head.row = 20;	 
	p_snake->head.col = 20;	 
	p_snake->tail.row = 20;	 
	p_snake->tail.col = 21;
}

//part.2 设置苹果初始位置
void init_apple(pt *p_apple){
	p_apple->row = rand() % SIZE;
	p_apple->col = rand() % SIZE;
}

//part.3 移动蛇位置
void move_snake(snake *p_snake){
	pt tmp = {0};
	int direction = 0;
	printf("请选择移动方向(UP = 5,DOWN =2 ,LEFT = 1,RIGHT = 3):");
	scanf("%d",&direction);
	tmp = p_snake->head;//tmp变量记录移动后蛇头移动后的位置
	switch(direction){
		case UP:	
			tmp.row--;
			break;
		case DOWN:
			tmp.row++;
			break;
		case LEFT:
			tmp.col--;
			break;
		case RIGHT:
			tmp.col++;
			break;
		default:
			break;			
	}
	//检查移动后的位置是否合理
	if (tmp.row < 0 || tmp.row > SIZE - 1) {
		return ;
	}
	if (tmp.col < 0 || tmp.col > SIZE - 1) {
		return ;
	}
	//检查是否头尾重叠
	if (tmp.row == p_snake->tail.row && tmp.col == p_snake->tail.col) {
		return ;
	}
	//上面三种情况没有发生,移动~
	p_snake->tail = p_snake->head;
	p_snake->head = tmp;
}

//part.4 判断蛇和苹果位置是否重叠
int overlap(const pt *p_apple,const snake *p_snake){
	 //不修改存储区,需要加const
	if((p_snake->head.row ==  p_apple->row) && (p_snake->head.col == p_apple->col)){
		return 1;
	}
	else if(p_apple->row == p_snake->tail.row && p_apple->col == p_snake->tail.col){
		return 1;
	}
	else{
		return 0;
	}
}

//part.5 显示所有内容
void show_map(const pt *p_apple,const snake *p_snake){
		//只显示,不修改,需要加const
	int row = 0,col = 0; 
	for(row = 0;row <= SIZE - 1;row++){
		for(col = 0;col <= SIZE - 1;col++) {
			if(row == p_snake->head.row && col == p_snake->head.col){
				printf("+");
			}
			else if(row == p_snake->tail.row && col == p_snake->tail.col){
				printf("-");
			}
			else if(row == p_apple->row && col == p_apple->col){
				printf("@");
			}
			else{
				printf(" ");
			}
		}
		printf("\n");
	}
}


int main(){
	srand(time(0));
	snake snk = {0};
	pt apple = {0};	

	init_apple(&apple);
	init_snake(&snk);
	//确定苹果和蛇的位置不重叠
	while(1){
		if(overlap(&apple,&snk)){
			//位置重叠就重新设置苹果位置
			init_apple(&apple);
		}
		else{
			break;	
		}
	}
	//显示初始全部内容
	show_map(&apple,&snk);
	while(1){		
		move_snake(&snk);
		//检查蛇和苹果是否重叠,如果重叠,重蛇苹果位置。
		while(1){
			if(overlap(&apple,&snk)){
				init_apple(&apple);
			}
			else{
				break;
			}
		}
		show_map(&apple,&snk);
	}
 
	return 0;
}












***********************
牢固掌握：

	1、指针
	2、结构体
	3、动态分配内存
	4、函数。








