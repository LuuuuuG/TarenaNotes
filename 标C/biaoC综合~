/**************************************************************************/
*									   *		
*				day_01					   *	
*									   *
/**************************************************************************/



计算机都是由硬件和软件构成的

CPU完成所有数字处理

内存用来存放所有要处理的数字

计算机断电以后内存里的数字消失

硬盘也是用来存放数字的
关机断电以后硬盘里的数字不会丢失

软件可以分为系统软件和应用软件
系统软件主要用来实现对硬件的管理
应用软件用来满足使用者的各种需要

Windows,UNIX和Linux都是常见的操作系统

通常需要通过终端软件使用Linux操作系统

终端软件里不能使用鼠标，只能使用键盘

在终端窗口里通过输入命令控制计算机

clear命令可以清除终端窗口里的所有文字
    信息

操作系统中用来管理文件的部分叫做文件
   系统
文件系统采用分组方式管理文件，每个分组
    里可以包含任意数量的文件
一个分组里的文件还可以再次分组

文件系统中的一个文件分组叫做文件夹或
    目录

如果目录A中包含目录B，它们之间存在
    父子关系
目录A叫做父目录，目录B叫做子目录

Linux文件系统中有一个大分组，这个分组
   里包含所有文件
这个分组叫做根目录，可以采用/代表根
    目录

可以使用路径表示文件或文件夹的位置
路径是从某个文件夹开始到某个文件或文件夹
    为止中间的路线

路径分成绝对路径和相对路径
它们的区别在于起点不同
绝对路径的起点必须是根目录
绝对路径必须以/做开头

相对路径的起点可以是任何目录
相对路径里使用..表示向上走一步
相对路径里使用.表示原地踏步
相对路径里不需要包含起点位置

终端窗口里可以设置当前目录
这个目录作为相对路径的起点使用
当前目录的位置可以改变

pwd命令可以用来察看当前目录的位置

cd命令可以改变当前目录的位置
命令使用方法如下
cd 目录路径

ls命令可以用来察看一个目录里的内容
使用方法如下
ls 目录路径
如果省略路径就能察看当前目录里的内容
使用-a选项可以察看目录里的所有内容
使用-l选项可以察看每个项目的详细信息
这两个选项可以合并成-al

touch命令可以用来创建新的文件
使用方法如下
touch 文件路径
如果文件已经存在就把文件的最后修改时间
    改成执行touch命令的时间

rm命令可以用来删除文件
使用方法如下
rm 文件路径

mkdir命令可以用来创建目录
使用方法如下
mkdir 目录路径
目录本身必须还不存在，但是父目录必须存在
使用-p选项可以把路径中所有不存在的目录
   都创建出来

rm命令也可以用来删除目录，这个时候要加上
    -r选项

cat命令可以用来察看文件内容

预习：
    1.vi的使用
	2.C语言程序基本结构
	3.C语言程序的开发过程
	4.printf标准函数
	5.变量

作业：
    1.假设要开发一个叫做BankATM的系统，
	    这个系统分成客户端(client)和
		服务器端(server)两部分。
		要求创建一组目录把这个系统的所有
		文件和其他文件隔离开，两个部分
		的文件之间也要隔离开


/**************************************************************************/
*									   *		
*				day_02					   *	
*									   *
/**************************************************************************/


vi是Linux系统里用来记录文字信息的工具

vi只能在终端窗口里使用（不能使用鼠标）

vi的功能被分成三组，任何时候只能使用
    其中一组
vi里提供三种工作模式，每种工作模式对应
    一组功能
任何时候只能处于一种工作模式下

三种工作模式分别是正常模式，插入模式
   和命令模式

正常模式下可以执行简单命令
插入模式下可以修改文字内容
命令模式下可以执行复杂命令

每当启动vi的时候一定处于正常模式下

不同工作模式之间可以互相转换
正常模式下输入i可以进入插入模式
正常模式下输入:可以进入命令模式
任何时候输入esc可以进入正常模式

可以采用如下命令启动vi
vi 文件路径

可以采用以下两种做法退出vi
1.在命令模式下输入q!可以退出vi（丢失
    没有保存的修改）
2.在命令模式下输入wq或者x也可以退出vi
    （先保存所有修改然后退出）

在命令模式下输入w可以只保存修改而不需要
   退出vi

在正常模式下输入nyy命令可以把光标所在行
    开始的连续n行拷贝到剪贴板上（如果
	n是1可以省略）

在正常模式下输入np命令可以把剪贴板上的
    内容在光标所在行下面粘贴n次(如果n是
	1也可以省略)

在正常模式下输入ndd命令可以把光标所在行
     开始的连续n行剪切到剪贴板上(如果n
	是1可以省略)

在命令模式下输入set nu命令可以让vi显示
   每行的行号

gVim是Windows里的vi

C语言程序的绝大部分内容应该记录在以.c
    作为扩展名的文件里，这种文件叫做
	C语言源文件
C语言中还包括以.h作为扩展名的文件，这种
    文件叫做头文件

C语言程序中可以直接使用数字和加减乘除
    四则运算符号(*代表乘法，/代表除法)

C语言程序中每个计算步骤最后都必须使用
    ；结束，使用；结束的计算步骤叫做
	一条语句

C语言里绝大多数语句必须写在大括号里面

大括号主要用来表示函数（函数可以看作
    一组语句）
每个函数必须有自己的名字，不同函数的名字
   不同

C语言程序中必须包含叫做main的函数，这个
    函数叫做主函数
程序必须从主函数里的第一条语句开始执行，
    主函数里的最后一条语句结束后程序
	结束

函数结束时可以用一个数字表示它的工作
    结果，这个数字叫做函数的返回值
主函数应该有一个返回值，如果返回值是0
   表示程序希望计算机认为它正常结束了，
   如果不是0表示程序希望计算机认为它
   遇到问题了。

C语言里预先保留了几十个英文单词，这些
   单词叫做关键字
每个关键字都有特定的使用方法，不能
   随便使用
所有关键字都是由小写英文字母构成

return就是一个关键字，它的主要用途是
    结束函数的执行，辅助用途是指定
	返回值的数值。

计算机里根据数字在某个方面的区别把数字
    分成几组，每组叫做一个数据类型
每个数据类型都有名字
整数是一种数据类型，它的名字是int
这个类型里包含几乎所有不带小数点的数字

程序中的所有数字都必须有类型
程序中所有不带小数点的数字默认都是
   整数类型

如果函数有返回值就必须把返回值的类型
    名称写在函数名称前

C语言程序编码规范
1.一行里最多包含一条语句
2.被同一对大括号包含的语句最左边一列
    应该上下对齐
3.在合适的地方使用空格和空行
    提高程序的可读性

C语言程序中通常包含预处理指令
预处理指令以#做开头，不是以;做结尾
#include是一个预处理指令，它可以把
   一个头文件的内容包含到当前文件中
这个预处理指令中需要使用相对路径表示
   头文件的位置
把相对路径包含在<>里表示以系统中预先
    规定好的一组目录作为起点依次查找
	头文件
把相对路径包含""里表示首先以当前文件
    所在目录作为起点查找，然后再以系统
	中预先规定好的目录作为起点查找

C语言程序中可以加入文字性的说明信息
这些信息必须写在注释区域里，计算机会
    忽略注释区域里的所有内容
单行注释以//做开头，一直到行尾为止
多行注释以/*做开头，以*/做结尾

C语言程序中大量采用名称区分不同内容
这些名称叫做标识符
标识符最好都采用英文单词
标识符的书写规则
1.第一个字符应该可以是英文字母或下划线
2.后面的每个字符可以是英文字母，下划线
     或阿拉伯数字字符
3.大小写不同的标识符是不同的标识符(大小写
	敏感)
4.关键字不能作为标识符使用
5.标识符长度没有限制，但是计算机只会
     截取前面一部分使用
6.标识符应该采用驼峰方式或下划线方式
     书写

编译器负责把编写好的程序翻译成计算机能
    认识的格式
gcc是Linux系统里C语言的编译器
MinGW是Windows里的gcc

Linux系统里C语言程序基本开发步骤
1.使用vi编写源文件
2.使用gcc把所有源文件翻译成计算机认识
    的格式(编译)
3.使用./a.out作为命令执行得到的文件

gcc编译器工作过程
1.处理所有预处理指令
2.把第一步的处理结果翻译成计算机认识
    的格式(编译)
3.把第二步的结果合并成执行文件（链接）

gcc选项介绍
-E       只处理预处理指令 
-c       只完成预处理和编译
         处理结果是以.o作为扩展名
		 的目标文件
-o       用来指定得到的结果文件名称
-std=c89/-std=c99
         这个选项决定采用哪个版本
		 的规范进行编译
         默认采用c89规范编译

C语言里预先提供了一组工具，这组工具
   叫做标准函数
每个标准函数可以解决一个常见问题
不同标准函数的名称不同
程序中可以编写函数调用语句来使用某个
    标准函数

printf标准函数可以把程序中的数字显示
    在终端窗口里
为了使用这个标准函数需要包含stdio.h
    头文件
可以把双引号里面的数字转移到双引号
    后面，这个时候双引号里面必须
	使用占位符表示数字应该出现的位置
不同类型的数字应该和不同占位符配合
    使用，整数类型数字应该和%d占位符
	配合使用
双引号后面的数字可以是一个计算公式的
    结果

程序中的所有数字都必须记录在内存里
内存由大量字节构成，每个字节可以单独
    记录一个数字
每个字节有一个编号，不同字节的编号
    不同。这个编号叫做字节的地址
所有字节的地址从0开始向上依次递增

内存中几个相邻字节可以合并在一起用来
    记录一个数字
可以把内存中用来记录一个数字的所有
    字节通称为存储区
一个存储区记录的数字类型必须相同
存储区也有地址，它的地址是它所包含的
   字节中地址最小字节的地址

程序中可以使用变量代表存储区,对变量
   的操作就是对存储区的操作
变量必须先声明然后才能使用
可以在一条语句里声明多个同类型的变量

赋值语句可以向变量里放一个数字
赋值语句里使用赋值操作符（=）
赋值操作符左边的内容必须可以代表一个
    存储区，这种内容叫做左值
赋值草祖父右边的内容必须可以代表
    数字
赋值操作符可以把右边的数字记录到左边
    的存储区里

可以在声明变量的时候立刻对变量进行赋值，
    这叫做变量的初始化
C语言里所有变量都应该初始化

可以在程序中直接把变量当作数字使用，这个
    时候计算机会首先从变量里获得数字
	然后再进行其他计算

变量名称既可以代表存储区也可以代表
   存储区里的数字，由环境决定

预习：
    1.变量
	2.数据类型
	3.scanf标准函数
	4.sizeof关键字
	5.二进制

作业：
    1.编写程序计算长方形的面积（长是7，
	宽是3，要求用变量记录长和宽）
      要把计算结果显示在屏幕上









/**************************************************************************/
*									   *		
*				day_03					   *	
*									   *
/**************************************************************************/


存储区的地址也可以代表存储区
在变量名称前使用&符号就可以计算出
    存储区的地址
采用%p作为占位符可以把地址数据打印在
    屏幕上

变量可以用来依次代表一组数字（任何时候
    只使用其中一个数字，每个数字的使用
	方法类似）

字符类型是一种数据类型
它的名称是char
这个类型里包含256个不同的整数，每个
    整数可以用来代表一个字符(例如'a',
	'*'等)
整数和字符之间可以互相替代
ASCII码表里列出所有整数和字符之间的
    对应关系
'a'          97
'A'          65
'0'          48

所有小写英文字符对应的整数是连续排列的，
    ‘a’对应的整数最小，'z'对应的整数
	最大
所有大写英文字符也符合这个规律
所有阿拉伯数字字符也符合这个规律

'd' - 'a'  等于     'D' - 'A'
'd' - 'a'  等于  '3' - '0'   等于  3 - 0

所有字符数据可以分成两组，每组里包含128个
其中一组字符和整数的对应关系在所有计算机
   上都一样，它们的整数范围从0到127
另外一组和整数之间的对应关系在不同的
   计算机上可能不同。它们的整数范围可能
   从-128到-1也可能从128到255

无符号字符类型也是一种数据类型
它的名字是unsigned char
这个类型里同样包含256个不同的字符数据，
    这些数据的整数范围固定从0到255

'\n'     换行
'\r'     回车
'\\'     代表字符\
'\''     代表字符'
'\"'     代表字符"

短整数类型也是一种数据类型
它的名称是short
这个类型里包含65536个不同的整数，其中
    一半是非负数，另外一半是负数。这些
	数字以0为中心向两边扩展。
无符号短整数类型名称是unsigned short
它里面同样包含65536个不同的整数，这些
    整数从0开始向正数方向扩展

长整数类型名称是long
它里面包含2的32次方个不同的整数，其中
    一半是非负数，另外一半是负数
这些数字以0为中心向两边扩展
无符号长整数类型名称是unsigned long
它里面同样包含2的32次方个不同的整数，
    这些整数从0开始向正数方向扩展

整数类型名称是int
在我们的计算机上整数类型和长整数类型
    完全一样
无符号整数类型名称是unsigned int
在我们的计算机上它和无符号长整数类型
    完全一样

程序中不带小数点数字后加u表示数字的
    类型是无符号整数类型

C语言中使用浮点类型表示带小数点的数字
浮点类型分成单精度浮点类型和双精度
   浮点类型
双精度浮点类型可以记录更多小数点后面
    的数位
单精度浮点类型名称是float
双精度浮点类型名称是double

程序中带小数点的数字默认是双精度
    浮点类型
程序中带小数点数字后加f表示它的类型
   是单精度浮点类型

C语言里允许程序员扩展新的数据类型
这些新的数据类型叫做复合数据类型
复合数据类型需要先定义后使用

布尔类型是C99规范里引入的新的数据类型
这个类型里只包含0和1两个整数，0叫做
    假，1叫做真

任何整数都可以当作布尔类型数字使用，
    0当作布尔类型使用的时候是假，其他
	所有整数当作布尔类型使用的时候
	都是真

数据类型和占位符对应关系介绍
char和unsigned char        %c
short                      %hd
unsigned short             %hu
long                       %ld
unsigned long              %lu
int                        %d
unsigned int               %u
float                      %f或%g
double                     %lf或%lg
            %f和%lf会保留小数点后多余的0
			%g和%lg不会保留

不同数据类型的存储区里包含的字节个数
    不同
sizeof关键字可以用来计算一个存储区或
    类型里包含的字节个数

char和unsigned char       1个字节
short和unsigned short     2个字节
long和unsigned long       4个字节
int和unsigned int         4个字节
float                     4个字节
double                    8个字节

sizeof关键字后的小括号里可以写任何
   能当作数字使用的内容
sizeof关键字后面的小括号里对任何存储区
   内容的修改不会真正生效

scanf标准函数可以把用户在键盘上输入的数字
    记录到存储区里
为了使用这个标准函数也需要包含stdio.h
    头文件
scanf函数调用语句里应该使用存储区的地址
   表示存储区
双引号里使用占位符表示存储区的类型
scanf函数调用语句的双引号里最好只有占位符
可以在一条scanf函数调用语句里获得多个数字
   并记录在多个不同的存储区里
如果用户输入的格式和程序要求的格式不一致
    可能导致程序再也不能获得数字了

一个字节分成八段，每段只能记录一个0或者1
如果要想把一个数字记录到字节里必须首先
    把它拆分成八个0或者1
采用一组0或者1表示数字的方式叫做二进制
计算机里只能采用二进制方式记录数字
任何数字既可以采用二进制方式表示也可以
    采用十进制方式表示
二进制数字中每个数位有一个编号，最右边
    数位的编号是0，向左依次递增
二进制表示方式中某个数位上的1代表的数字
    可以用2的数位编号次方计算出来
如果两个相邻数位的内容一样则左边数位
    代表的数字是右边数位数字的2倍
以上规则只使用于使用二进制表示非负数
二进制加一的时候要把从数位0开始的连续
    多个1变成0，把最右边的0变成1

二进制表示的非负整数转换成十进制的时候
    只需要把所有数位上的1单独转换，然后
	求和

0000 0101 = 2的2次方 + 2的0次方
          = 4 + 1
		  = 5


非负数的十进制转换成二进制的方法
********         12
*******0          6
******00          3
*****100          1
****1100          0

    对数字不停做除以2保留整数部分的
	   操作得到一组数字，对每个数字
	   做除以2取余的操作得到一个数位
	   的内容。把所有数位的内容按照
	   从后向前的顺序书写就得到转换
	   结果。

预习：
    1.二进制
    2.操作符

作业：
    1.编写程序从键盘得到四个整数
	   计算它们的求和结果并打印在屏幕上






/**************************************************************************/
*									   *		
*				day_04					   *	
*									   *
/**************************************************************************/


负数十进制和二进制之间不能直接转换
转换过程需要先计算相反数，然后把相反数
    进行转换，再根据转换结果计算相反数

把二进制中每个数位的内容都改变，然后
    再加一就得到相反数的二进制

有符号类型数字最左边的二进制数位叫做
   符号位，如果符号位是0表示数字是非负数，
   如果符号位是1表示数字是负数

当把占地大的整数类型数字赋值给占地小的
    整数类型存储区时只保留后面的二进制
	数位，这会导致数据丢失

当把占地小的有符号类型数字赋值给占地大
    的整数类型存储区时扩展出来的二进制
	数位填充的都是符号位

把二进制从右向左每三个数位分成一组，每组
    用一个0到7之间的数字替换。这个结果
	叫做数字的八进制表示方式。

0110 1010    01 101 010    152(八进制)

可以直接在程序中采用八进制表示数字，但是
    必须以0做开头
可以采用%o做占位符把数字的八进制表示
    方式打印在屏幕上

把二进制数字从右向左每四个数位分成一组，
    每组用一个字符替代得到的结果叫做
	十六进制。(用a到f的留个字母代表10
	到15的六个数字)

1100 1011        cb(十六进制)

可以在程序中用十六进制方式表示数字，但是
    必须以0x做开头
可以使用%x或%X做占位符把数字的十六进制
    打印在屏幕上
打印结果中不包含0x开头
用%x做占位符打印结果中所有字符都是小写的
用%x做占位符打印结果中所有字符都是大写的

操作符用来描述对数字的处理规则
根据操作符所需要配合的数字个数把操作符
    分成单目操作符，双目操作符和三目
	操作符

如果参与除法计算的两个数字都是整数则
    结果只保留整数部分

可以使用%表示取余操作

赋值语句可以当作数字使用，这个数字就是
    赋值完成后左边存储区里的数字
可以在一条语句里使用多个赋值操作符，
    这个时候先计算右边的赋值操作符

绝大多数双目操作符可以和赋值操作符合并
    成为复合赋值操作符(例如+=, %=等)
复合赋值操作符同样要求左边的内容代表
    存储区，右边的内容代表数字
它可以把双目操作符的计算结果存储到左边
    的存储区里
复合赋值操作符的优先级和赋值操作符优先级
    一样低

自增操作符(++)和自减操作符(--)都是
    单目操作符
它们必须配合存储区使用，它们可以把存储区
    的内容加一或者减一
它们各有两种使用方法，一种是前操作
    （操作符写在存储区前面），另外一种
	是后操作（操作符写在存储区后面）
这个操作符编写的表达式可以当作数字使用，
    前操作当数字使用时是修改后的数字，
	后操作当数字使用时是修改前的数字
不要在一条语句里对同一个变量多次
    进行自增或自减计算

逻辑操作符用来编写逻辑表达式
逻辑表达式的计算结果只能是布尔值

!是一个单目逻辑操作符，它用在一个布尔值
   的前面
它可以计算出一个布尔值的相反值
它叫做求反操作符

双目逻辑操作符包括==(等于),!=(不等于),
	>(大于),<(小于),>=(大于等于)和
	<=(小于等于)

最多包含一个双目逻辑操作符的表达式叫做
    简单逻辑表达式
简单逻辑表达式在计算机里和数学里的计算
    结果一定一样

可以采用与(&&)和或(||)合并逻辑表达式

如果两个逻辑表达式的结果都是真则用与(&&)
	连接后结果也是真，否则结果就是假
如果两个逻辑表达式中有一个的结果是真
    用或(||)连接以后就是真

与(&&)和或(||)具有短路特征（如果前面
    逻辑表达式的结果可以决定整个逻辑
	表达式的结果，计算机会忽略后面的
	逻辑表达式）

位操作符可以直接操作二进制数位

~是一个单目位操作符，它可以把二进制的
   每个数位求反（按位求反）
这个操作符应该写在一个数字的前面

双目位操作符包括按位与(&)，按位或(|)
	和按位异或(^)
它们都可以把两个数字对应二进制数位
    上的数字进行计算

按位与可以把对应数位上的数字进行与计算
只要一个数位上的内容是0则计算结果就是0

    3        0000 0011
&   5        0000 0101
             0000 0001

按位或可以把对应数位上的数字进行或计算
只要一个数位上的内容是1则计算结果就是1

      3      0000 0011
|     5      0000 0101
             0000 0111

按位异或可以把对应数位上的数字进行异或
    计算
如果两个数位内容一样则结果是0，否则结果
    是1

    3        0000 0011
^   5        0000 0101
             0000 0110

移位操作可以把一个数字中所有二进制数位
    里的内容统一向左或者向右移动n个位置
>>表示向右移位
<<表示向左移位
它们都是双目位操作符
左边的数字是将要进行移位操作的数字
右边的数字表示移动的位数

左移以后右边空出来的位置上一定填充0

有符号类型数字右移后左边空出来的位置
    上填充的是符号位的内容
无符号类型数字右移后左边空出来的位置
    上填充的是0

一般情况下向左移动n个位置相当于乘以
    2的n次方，向右移动n个位置相当于
	除以2的n次方

位操作符不会修改存储区内容

&也可以作为单目操作符使用，则合格时候
    可以用来计算一个存储区的地址
这个操作符应该写在一个存储区的前面
我们的计算机里所有地址都是32个二进制数位

*也可以作为单目操作符使用，这个时候
    可以根据地址数据找到地址来源的存储区
这个符号应该写在一个地址数据前面

三目操作符可以从两套计算规则中选择
    一套进行计算
三目操作符格式如下
布尔值 ? 公式一 ：公式二
如果布尔值为真就采用公式一计算，否则
    采用公式二计算
不要在三目表达式问号后使用赋值操作符

预习：
    1.类型转换
	2.分支
	3.for循环

作业：
    1.从键盘得到一个三位数，把它倒序
	    打印在屏幕上(不考虑不是三位数
				的情况)

       例如得到的数字是123，打印结果
	   就应该是321





/**************************************************************************/
*									   *		
*				day_05					   *	
*									   *
/**************************************************************************/




如果表达式里包含的数字类型不同就必须
    首先把他们转换成同一个类型，然后
	才能计算
这个转换过程叫隐式类型转换，完全由
    计算机执行

隐式类型转换过程中要把占地小的数据类型
    转换成占地大的数据类型

如果不同类型数字占的大小一样就把有符号
    类型转换成无符号类型

C语言中可以任意给数字指定一个类型
这个叫做强制类型转换
强制类型转换格式如下
(char)300
强制类型转换有可能造成数据内容丢失

类型转换不会修改存储区内容，计算机会
    分配一个新的存储区记录转换后的
	数字，然后用这个数字进行计算

分支语句可以从几组语句中选择一组执行而
    忽略其他组
在编写程序的时候如果遇到多种可能性并且
    每种可能性的处理方法不同的时候就
	可以采用分支语句解决

if关键字可以用来编写分支
if分支里可以为每种可能性编写专门
    的处理语句
每组语句需要一个配对的逻辑表达式。
    当某个逻辑表达式结果为真的时候
	就执行它配对的处理语句

只有互相不重叠的多种可能性可以合并在
    一个分支里

如果分支的多种可能性中必须选择一个就
    可以省略最后一组语句的逻辑表达式

编写分支的时候应该把逻辑表达式最简单
    的情况写在最前面，把逻辑表达式
	最复杂的情况写在最后面

if分支的逻辑表达式之间有前后顺序，只有
    前面的逻辑表达式结果是假才会计算
	后面的逻辑表达式
可以利用这一点简化后面的逻辑表达式

if分支必须当作整体理解

如果一个分支里包含有限个整数，每个整数
    需要使用一组专门的语句处理，这种
	分支可以采用switch...case格式编写

循环语句可以让一组语句反复多次执行
for关键字可以用来编写循环
可以在for循环里让一个变量依次代表一组
    数字，使用一组语句处理变量所代表
	的每个数字
这个变量叫做循环变量
采用如下结构描述循环变量的变化过程
(把开始数字赋值给循环变量;
 用逻辑表达式描述循环变量和结束数字的关系;
 循环变量的变化规律)

假设有如下for循环
for (1;2;3) {
	4
}
它按照如下分组方式执行
[1,2][4,3,2][4,3,2]....[4,3,2]
第一组和其他组都不同
正常情况下for循环一定在两组之间结束
如果某一组最后编号为2的逻辑表达式结果
    为真则启动下一组，否则结束循环
如果循环正常结束则结束后循环变量一定
     落在数字范围之外
for循环有可能不执行大括号里面的语句

for循环小括号里每部分都可以省略
如果省略小括号中间的逻辑表达式就表示
    逻辑表达式永远为真
这种循环不能正常结束，叫做死循环

小括号里最前面和最后面的部分可以是用
    逗号连接的多条语句

C99规范里允许在循环小括号里临时声明
    循环变量
这种循环变量不可以在循环外使用

预习：
    1.for循环
	2.多重循环
	3.while循环和do...while循环
	4.缓冲区管理
	5.数组

作业：
    1.编写程序从键盘得到一个1到100之间
	    的整数，把这个整数到100之间
		所有和7无关的整数都打印在屏幕上








/**************************************************************************/
*									   *		
*				day_06					   *	
*									   *
/**************************************************************************/	

	一、随机数
	二、控制语句
	三、while 循环
	四、do...while 循环
	五、printf函数		
	六、数组




			/*一、随机数*/

	不可与之的数字叫做//随机数，
	Rand标准函数需要包含stdlib.h头文件。

	Srand 标准函数设置随机数种子
	它可以把一个整数当作种子使用
	为了使用这个标准函数需要包含stdlib.h头文件

	为了使用这个标准函数需要包含time.h 头文件

  1 //随机数rand
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 int main(){
  5     int num = 0;
  6     printf("num = %d\n",rand());
  7     printf("num = %d\n",rand());
  8     printf("num = %d\n",rand());
  9     return 0;
 10 }



  1 //srand
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <time.h>
  5 int main(){
  6     int num = 0;
  7     srand(time(0));//设置随即的算法种子
  8     printf("num = %d\n",rand());
  9     printf("num = %d\n",rand());
 10     printf("num = %d\n",rand());
 11     
 12     return 0;
 13 } 

**********************************************

【练习】
编写猜数游戏，计算机里产生一个1到100之间的随机数，
然后让用户猜，每次猜完都要给出提示
直到猜对程序为止。

【Gang】
  1 /*
  2 编写猜数游戏，计算机里产生一个1到100之间的随机数，
  3 然后让用户猜，每次猜完都要给出提示
  4 直到猜对程序为止。
  5 */
  6 #include <stdio.h>
  7 #include <stdlib.h>
  8 #include <time.h>
  9 
 10 int main(){
 11     int num = 0,guess = 0;
 12     srand(time(0));
 13     num = rand() %100 + 1;
 14     for (;;){
 15     printf("Input a number:");
 16     scanf("%d",&guess);
 17         if(guess > num){
 18             printf("Bigger!\n");
 19         }
 20         else if(guess < num){
 21             printf("Smaller!\n");
 22         }
 23         else{
 24             printf("congratulation!\n");
 25             break;
 26         }
 27     }
 28     return 0;
 29 }  




**********************************************

			/*二、控制语句*/

	1、分支和循环可以让程序和从的语句不再从上到下顺序执行。


 	2、goto 语句可以把任何一条语句指定为下一条语句,一般不要使用goto语句。

	
	//多重循环
	1、循环里面还可以包含其他循环。
	2、如果一个问题可以划分为多个小问题，每个小问题可以采用类似的循环解决，
		这种问题可以采用多重循环解决。

  1 //多重循环演示
  2 
  3 #include <stdio.h>
  4     int main(){
  5     int i = 0,j = 0;
  6     for (i = 1;i <= 5;i++){
  7         for(j = 5;j >= i;j--){
  8             printf("%d",j);
  9         }
 10         printf("\n");
 11     }
 12     return 0;
 13 }
	
	
	


**************************************
【练习】

	有一种货币包含三种面值，分别是1元，2元和5元。
	编写程序把这种货币里所有10元的可能性找到并打印在屏幕上。



【Gang】

  1 /*有一种货币包含三种面值，分别是1元，2元和5元。
  2     编写程序把这种货币里所有10元的可能性找到并打印在屏幕上。
  3     */
  4 
  5 #include <stdio.h>
  6 
  7 int main(){
  8     int i = 0,j = 0,k = 0;
  9     for (i = 0;i <= 10;i++){
 10         for(j = 0;j <= 5;j++){
 11             for(k = 0;k <= 2;k++){
 12                 if((i + 2*j +5*k) == 10){
 13                     printf("一元%d张 两元%d张 五元%d张",i,j,k);
 14                 }
 15             }
 16         }
 17         printf("\n");
 18     }
 19     return 0;
 20 }


//Mr.Yang

  1 #include <stdio.h>
  2 
  3 int main(){
  4     int i = 0,j = 0;
  5     for (i = 0;i <= 5;i++){   //i表示两元
  6         for(j = 0;j <= 2;j++){ //j表示五元
  7                 if(2*i +5*j <= 10){
  8                     printf("一元%d张 两元%d张 五元%d张\n",10 - 2*i - 5*j,i,j    );                  
  9                 }
 10             }   
 11         }   
 12     return 0;
 13 } 



*****************************************************************************


		/*三、while 循环	（先判断，后执行） */
	1、while 和 for 循环可以互相转换。
	2、编写程序时，不能计算出要执行的次数时，可以考虑采用while循环。
	3、while 格式：
		while (逻辑表达式){
			语句
		}
	4、只要逻辑表达式为真，就会反复执行大括号里面的语句。
	5、如果逻辑表达式永远为真，这个逻辑表达式就是一个死循环。
	6、while 里面也可以使用 break 和 continue 语句
	7、while 循环交替执行逻辑表达式和大括号里面的语句，第一步做逻辑表达式的判断。
	8、如果第一步判断逻辑表达式结果为假，则循环立即结束，不执行大括号里面的语句。


  1 //first while 
  2 #include <stdio.h>
  3 int main(){
  4     int i = 1;
  5     while(i <=5){
  6         printf("%d\n",i);
  7         i++;
  8     }
  9     return 0;
 10 }


//while 循环实现猜数游戏
  1 //Game: guess number
  2 
  3 #include <stdio.h>
  4 #include <stdlib.h>
  5 
  6 
  7 /*int main(){
  8     int num = 0,guess = 0;
  9     srand(time(0));
 10     num = rand() % 100 + 1;
 11     printf("Input a number:");

 12     scanf("%d",&guess);
 13 
 14     while (guess < num){			//Gang
 15         printf("Smaller\n");
 16         printf("Input a number:");
 17         scanf("%d",&guess);
 18     }
 19 
 20     while (guess > num){
 21         printf("bigger\n");
 22         printf("Input a number:");
 23         scanf("%d",&guess);
 24     }
 25     
 26     while (guess == num){
 27         printf("congratulation!\n");
 28     }
 29     return 0;
 30 }*/
 31 
 32 int main(){
 33     int num = 0,guess = 0;
 34     srand(time(0));  //随机生成一个数字
 35     num = rand() % 100 + 1;
 36     while(guess != num){
 37         printf("Input a number:");
 38         scanf("%d",&guess);
 39 
 40         if (guess < num){
 41             printf("Smaller\n");
 42         }
 43         else if (guess > num){
 44             printf("Bigger\n");
 45         }
 46         else{
 47             printf("Congratulation\n");
 48         }
 49     }
 50 
 51     return 0;
 52 }


*****************************************************************************

		/*四、do ... while循环	（先执行，后判断）*/
	1、可以把 do ... while 格式看作是while循环的变体。
	2、小括号后面必须用分号结束。
	3、也交替执行大括号里面的语句和逻辑表达式，先执行括号里面的语句。
	4、do ... while 至少执行大括号里面的语句一次。
	


	//scanf 函数

	1、从键盘得到数字的时候，数字会首先进入输入缓冲区，然后再进入变量的存储区。
	2、先进入缓冲区的数字必须首先被处理。
	3、如果用户输入的格式和程序要求的格式不一致，就可能导致程序永远无法获得数字了。
	4、可以使用如下两条语句，丢掉用户某一次输入的所有内容：

		scanf("%*[^\n]");
		scanf("%*c");	


  1 //scanf
  2 
  3 #include <stdio.h>
  4 int main(){
  5     int num = 0,num1 = 0;
  6     printf("input a number:");
  7     scanf("%d",&num);
  8     scanf("%*[^\n]");   // 丢掉前面第一次
  9     scanf("%*c");       //输入的内容！！！
 10     printf("num is %d\n",num);
 11     printf("input a number:");
 12     scanf("%d",&num1);
 13     printf("num is %d\n",num1);
 14     return 0;
 15 }


*****************************************************************************

			/*五、printf 函数	*/

	1、printf现实数字的时候，数字首先进入输出缓冲区，然后彩绘现实在屏幕上。
	2、只在四种情况下输出缓冲区里的内容会显示在屏幕上：
		a.输出缓冲区里有'\n'字符。 
		b.程序结束。                                                //待验证！
		c.输出缓冲区被充满的时候。
		d.在程序中使用fflush(stdout)把前面放在输出缓冲区里的内容显示在屏幕上。
	5、scanf中含有fflush(stdout)函数。
		


*****************************************************************************

			/*六、数组*/

	1、数组可以用来代表内存中一组连续的同类型存储区。
	2、数组一旦存在则里面包含的存储区个数不可以改变。	
 	3、数组通常不会作为整体使用，一次通常只使用其中某个存储区。
	4、数组里每个存储区有一个编号，这个编号叫做数组的下标。
	5、第一个存储区的下标是 0 ，向后依次递增。
	6、下标范围从 0 到存储区个数减一为止，不可以使用超过范围的下标。
	7、数组名称加下标可以用来表示数组里的某个存储区。
	8、可以在for循环里让循环变量依次代表数组中每个存储区的下标，
		然后在循环中处理循环变量代表的存储区。
	9、数组初始化的时候：
		a.应该把所有初始化数据包含在一对大括号里，不同数据之间用逗号分开。
		b.如果初始化数据个数比存储区个数多，就把后面的初始化数据丢掉。
		c.如果初始化数据个数比存储区个数少，就把后面存储区初始化为 0 
		d.如果初始化数据个数跟存储区个数相等，就可以省略数组声明中的存储区个数~
			【e.g.】   int arr[] = {1,2,3,4,5}

















******************************************************************************

预习：
	变长数组、多维数组


作业：
	编写程序从键盘得到多个整数（数量不超过5个，反序打印，然后打印求和结果）

【Gang】
  1 //编写程序从键盘得到多个整数（数量不超过5个，反序打印，然后打印求和结果）
  2 #include <stdio.h>
  3 int main(){
  4     int a,b,c,d,e;
  5     int i = 0;
  6     int sum = 0;
  7     printf("Input five numbers:");
  8     scanf("%d%d%d%d%d",&a,&b,&c,&d,&e);
  9     int arr[5] = {a,b,c,d,e};
 10     for(i = 4;i >= 0;i--){
 11         printf("%d ",arr[i]);
 12         sum = sum + arr[i];
 13     }
 14         printf("sum = %d\n",sum);
 15     
 16     return 0;
 17 }

//Mr.Yang
 21 int main(){
 22     int arr[5] = {0},qty = 0,num = 0,pos = 4;
 23     int sum = 0;
 24     printf("Input counts of numbers:");
 25     scanf("%d",&qty);
 26     for (num = 1;num <= qty;num++){
 27         printf("Input a number:");
 28         scanf("%d",&arr[pos]);
 29         pos--;
 30     }   
 31     printf("\n");
 32     for(num = pos + 1;num <= 4;num++){
 33         printf("%d",arr[num]);
 34         sum += arr[num];
 35     }
 36 
 37     printf("Sun = %d\n",sum);
 38     return 0;
 39 }


/**************************************************************************/
*									   *		
*				day_07					   *	
*									   *
/**************************************************************************/	

	  生成彩票
	  验证身份证
	一、变长数组
	二、多维数组
	
	
	
	
【练习】
  1 /*彩票1.0
  2 编写程序产生一张彩票，彩票里包含7个1~36之间的随机数（数字可以重复）
  3  首先得到一张彩票，然后把彩票里的数字打印在屏幕上。
  4 */
  5 #include<stdio.h>
  6 #include<stdlib.h>
  7 #include<time.h>
  8 
  9 int main(){
 10     srand(time(0));
 11     int arr[] = {0};
 12     int i = 0,j = 0;
 13     for(i = 1;i <=7;i++){
 14         arr[i] = rand() % 36 +1;
 15         printf("%d ",arr[i]);
 16     }
 17 	return 0；
 18 }

/*		\有重复数字/				*/





/*		/无重复数字\				*/


 #include<stdio.h>
  6 #include<stdlib.h>
  7 #include<time.h>
  8 
  9 int main(){
 10     srand(time(0));
 11     int arr[7] = {0};
 12     int tmp = 0,num = 0;
 13     int i = 0,cnt = 0;
 14 /*  for(i = 1;i <=7;i++){				             <重点复习>
 15         arr[i] = rand() % 36 +1;
 16     }
 17 */
 18     do{
 19         tmp = rand() % 36 +1;
 20         for(num = 0;num <= cnt - 1;num++){
 21             if(arr[num] == tmp){    //生成数字跟前面数字已有一样
 22                 break;              //结束循环
 23             }
 24         }
 25         if (num == cnt){            //循环如果正常结束
 26             arr[cnt] = tmp;         //说明生成数字可以使用~
 27             cnt++;
 28         }
 29     }while(cnt <7);
 30     for(i = 0;i < 7;i++){
 31         printf("%d ",arr[i]);
 32     }
 33     printf("\n");
 34 
 35     return 0;
 36 }











【练习】
  1 /*
  2 身份证前17个号码和下面17个数字对应相乘
  3 (7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2)
  4 
  5 把所有乘积求和，用求和结果除11取余，用余数到下面11个数字里挑选
  6 (1,0,x,9,8,7,6,5,4,3,2)
  7 挑选的结果就是第18位的数字
  8 
  9 */
 10 #include<stdio.h>
 11 
 12 int main(){
 13     int arr[17] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
 14     int i = 0,num = 0,sum = 0,last_num = 0;
 15     for(i = 0;i < 17;i++){
 16         printf("输入你身份证的第%d位：",i);
 17         scanf("%d",&num);
 18         sum = sum + arr[i] * num;
 19     }
 20 
 21         last_num = sum % 11;
 22     int arr2[11] = {1,0,999,9,8,7,6,5,4,3,2};
 23         if( arr2[last_num] == 2){
 24             printf("最后一位是x\n");
 25         }
 26         else{
 27             printf("最后一位是%d\n",arr2[last_num]);   
 28         }
 29         
 30     return 0;
 31 }

//Mr.Yang

4 int main(){
 35     int card[17] = {0},arr[17] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
 36     char arr1[11] = {'1','0','x','9','8','7','6','5','4','3','2'};
 37     int num = 0,sum = 0;
 38     for (num = 0;num <= 16;num++){
 39          printf("输入你身份证的第%d位：",num+1);
 40          scanf("%d",&card[num]);
 41     }
 42     for (num = 0;num <= 16;num++){
 43         sum += card[num] * arr[num];
 44     }
 45         printf("最后一位是%c\n",arr1[sum % 11]);
 46 
 47     return 0;
 48 }
        

【练习】       //                                               <   重点复习  >

  1 /*
  2 编写程序 从键盘得到一个非负整数
  3 ，统计出它里面包含的所有数出现的次数
  4 */

//Mr.Yang
 48 int main(){
 49     int arr[10] = {0},num = 0;
 50     printf("请输入一个数字：");
 51     scanf("%d",&num);
 52     do{
 53         arr[num %10]++;
 54         num /= 10;      //丢掉最右边的数
 55     }while(num);
 56 
 57     for(num = 0;num <= 9;num++){
 58         if(arr[num]){
 59             printf("数字%d出现的次数是%d\n",num,arr[num]);
 60         }
 61     }
 62     return 0;
 63 }



*******************************************************


			/*一、变长数组*/
	1、数组名称不可以代表存储区。
	2、数组名称代表的是数组里第一个存储区的地址。
	3、可以对数组名称做sizeof计算，计算结果是数组里所有存储区的总大小
	4、c99规范里允许使用边长数组，声明边长数组时可以使用变量表示数组里
		包含的存储区个数。
	5、如果多次运行这个程序则这个数组里包含的存储区个数可能变化。
		每次程序运行过程中数组里包含的存储区个数不会改变。
	6、变长数组/*不可以初始化。*/



//  数组地址演示
  1 #include<stdio.h>
  2 
  3 int main(){
  4     int arr[5] = {0};
  5     printf("arr is %p\n&arr[0] is %p\n",arr,&arr[0]);
	printf("sizeof(arr)is %d\n",sizeof(arr));

  6     return 0;
  7 }
********************
运行结果：
arr is 0xbf82a6fc
&arr[0] is 0xbf82a6fc
sizeof(arr)is 20



//变长数组演示
  1 #include<stdio.h>
  2 
  3 int main(){
  4     int size = 0;
  5     printf("请输入存储区个数：");
  6     scanf("%d",&size);
  7     int arr[size];  //变长数组声明。
  8     printf("sizeof(arr) is %d\n",sizeof(arr));
  9     return 0;
 10 }


【练习】
编写程序产生一张彩票，彩票里的数字个数由用户指定。






********************************************************



			/*二、多维数组*/
	1、多维数组除了可以表示存储区以外，还可以表示存储区的分组情况。
	2、二维数组是最常见的多维数组，它只能表示存储区的一次存储情况。
	3、声明二维数组时需要提供两个整数，
		前一个表示分组个数，后一个表示分组里的存储区个数。
	4、使用二维数组时也需要提供两个下标，
		a.组下标	表示分组	范围从0开始到分组个数减一为止。
		b.组内下标	表示分组内的存储区	范围从0开始到存储区个数减一为止。

	5、可以采用双重循环依次处理二维数组里的每个存储区。
	6、可以把二维数组当作一维数组进行初始化。
		int arr[3][2] = {1,2,3,4,5,6};
	7、也可以把初始化数据进行分组，每组初始化数据用来初始化一组存储区。
		int arr[3][2] = {{1,2},{3,4},{5,6}};
	8、如果可以根据初始化数据计算出分组个数就可以省略数组声明里的分组个数。
		int arr[][2] = {1,2,3,4,5};
		int arr[][2] = {{1},{3,4},{5,6}};
	9、二维数组名称只能代表其中第一个存储区的地址。
	10、数组名称也不可以被赋值。
	11、二维数组名称也可以做sizeof计算，结果是二维数组里所有存储区的总大小。
	12、二维数组名称在使用的时候也可以只提供一个下标，这个下标作为组下标使用。
		这个写法代表下标对应组里第一个存储区的地址。
			arr[1] 的 %p 与 arr[1][0] %p 相同


************************************************************************


//数组演示
  1 #include<stdio.h>
  2 int main(){
  3     int arr[3][2];  //二维数组声明
  4     int row = 0,col = 0;
  5     int num = 1;
  6     for(row = 0;row <= 2;row++){
  7         for(col = 0;col <= 1;col++){
  8             arr[row][col] = num;
  9             num++;
 10             printf("arr[%d][%d] = %d      ",row,col,arr[row][col]);
 11         }
 12         printf("\n");
 13     }
 14     return 0;
 15 }
*********************************
运行结果：
arr[0][0] = 1      arr[0][1] = 2      
arr[1][0] = 3      arr[1][1] = 4      
arr[2][0] = 5      arr[2][1] = 6 


//二维数组演示
  1 #include<stdio.h>
  2 int main(){
  3     int arr[3][2] = {0};
  4     printf("arr is %p\n&arr[0][0]is %p\n",arr,&arr[0][0]);
  5     printf("sizeof(arr) is %d\n",sizeof(arr));
  6     printf("arr[1] is %p\n&arr[1][0]is %p\n",arr[1],&arr[1][0]);
  7     printf("sizeof(arr[1]) is %d\n",sizeof(arr[1]));
  8     return 0;
  9 }
~      
***************************************
运行结果：
arr is 0xbfde1898
&arr[0][0]is 0xbfde1898
sizeof(arr) is 24
arr[1] is 0xbfde18a0
&arr[1][0]is 0xbfde18a0
sizeof(arr[1]) is 8


*****************************************************************



编写程序 二维数组 5 * 5 
填入 
10000
02000
00300
00040
00005
把以上数字填充到二维数组中然后此格式打印


【Gang】
  1 #include <stdio.h>
  2 int main(){
  3     int arr[5][5];
  4     int i = 0,j = 0;
  5     for(i = 0;i < 5;i++){
  6         for(j = 0;j < 5;j++){
  7             if(i == j){
  8                 arr[i][j] = j + 1;
  9                 printf("%d",arr[i][j]);
 10             }
 11             else{
 12                 arr[i][j] = 0;
 13                 printf("%d",arr[i][j]);
 14             }
 15         }	`
 16         printf("\n");
 17     }
 18 
 19     return 0;
 20 }


//Mr.Yang

 24 int main(){
 25 
 26     int arr[5][5] = {0};
 27     int i = 0,j = 0;
 28     for(i = 0;i < 5;i++){
 29         for(j = 0;j < 5;j++){
 30             if(i == j){
 31                 arr[i][j] = j + 1;
 32             }
 33         }
 34     }
 35     for(i = 0;i < 5;i++){
 36         for(j = 0;j < 5;j++){
 37             printf("%d",arr[i][j]);
 38             }
 39             printf("\n");
 40         }
 41 
 42     return 0;
 43 }











****************************************************************
预习：
	1、函数










/**************************************************************************/
*									   *		
*				day_08					   *	
*									   *
/**************************************************************************/

	扫雷游戏
	一、函数




二维数组练习：
	1、 扫地雷游戏
		10*10 地图随机放10个地雷
		地雷用	X 表示
		空位置  O  表示

【Gang】              // 待调试！！！
  1 #include<stdio.h>
  2 #include<stdlib.h>
  3 #include<time.h>
  4 int main(){
  5     srand(time(0));
  6     int map[10][10] = {0};
  7     int i = 0,j = 0,m = 0,n = 0;
  8     int boom[i][j];
  9     int num = 0;
 10      for (;num < 10;){
 11             m = rand() % 10;
 12             n = rand() % 10;
 13         if(map[m][n] != -1){
 14             map[m][n] = -1;
 15             num++;
 16         }
 17         }
 18 
 19      for (i = 0;i < 10;i++){
 20         for(j = 0;j < 10;j++){
 21             if(map [i][j]){
 22                 printf("X");
 23             }
 24             else{
 25                 printf("o");
 26             }
 27 
 28         }
 29         printf("\n");
 30      }
 31 
 32 
 33     return 0;
 34 }




//Mr.Yang
  1 #include <stdio.h>
  2 #include <stdlib.h>
  3 #include <time.h>
 31 int main(){
 32     int map[10][10] = {0};    //初始化  此时地图上全是空位置0
 33     int row = 0,col = 0;
 34     int cnt = 0;    //用来计算地雷的个数
 35     srand(time(0));
 36     do{
 37         row = rand() % 10;
 38         col = rand() % 10;
 39         if(map[row][col] !=-1){     //用 -1 表示地雷的位置
 40             map[row][col] = -1;     //地图上不是-1的地方变成-1
 41             cnt++;			
 42         }
 43     }while(cnt < 10);
 44     for(row = 0;row < 10;row++){
 45         for(col = 0;col < 10;col++){
 46             if(!map[row][col]){
 47                 printf("O");
 48             }
 49             else{
 50                 printf("X");
 51             }
 52         }
 53         printf("\n");
 54     }
 55 
 56     return 0;
 57 }





		2. 扫雷进阶 （带上雷旁边的数字）  //方法一

		3、扫雷进阶 (从空白位置找到雷的位置) //方法二


#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main() {
	int map[10][10] = {0}, row = 0, col = 0, cnt = 0, num = 0, newrow = 0, newcol = 0;
	int delta[8][2] = {{-1, -1},{-1, 0}, {-1, 1},
	         {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
	srand(time(0));
	do {		//随机在地图上生成地雷
		row = rand() % 10;
		col = rand() % 10;
		if (map[row][col] != -1) { // -1表示地雷的位置
			map[row][col] = -1; // 只在没有地雷的位置随机生成地雷
			cnt++;
		}
	} while (cnt < 10);

	//地图上用数字记录格子旁边有多少个地雷

	//方法一：先找地雷，在地雷旁边计数。
	/*for (row = 0;row <= 9;row++) {
		for (col = 0;col <= 9;col++) {
			if (map[row][col] != -1) {
				continue;
			}
            		for (num = 0;num <= 7;num++) {
				newrow = row + delta[num][0];
				newcol = col + delta[num][1];
				if (newrow < 0 || newrow > 9) {
					continue;
				}
				if (newcol < 0 || newcol > 9) {
					continue;
				}
				if (map[newrow][newcol] == -1) {
					continue;
				}
				map[newrow][newcol]++;
			}
		}
	}*/

	//方法二：先找空白地图，然后在地雷旁边计数。
	for (row = 0;row <= 9;row++) {			//处理不是地雷的区域
		for (col = 0;col <= 9;col++) {
			if (map[row][col] == -1) {  //跳过是地雷的区域
				continue;
			}
			for (num = 0;num <= 7;num++) {
				newrow = row + delta[num][0];
				newcol = col + delta[num][1];
				if (newrow < 0 || newrow > 9) {
					continue;
				}
				if (newcol < 0 || newcol > 9) {
					continue;
				}
				if (map[newrow][newcol] == -1) {
					map[row][col]++;
				}
			}
		}
	}

	//绘制地图
	for (row = 0;row <= 9;row++) {
		for (col = 0;col <= 9;col++) {
			if (!map[row][col]) {
				printf("O ");	//地图上空位置用O表示
			}
			else if (map[row][col] > 0) {
				printf("%d ", map[row][col]);
			//用数字显示地图上格子边上有地雷数量
			}
			else {
				printf("X ");//X表示地雷
			}
		}
		printf("\n");
	}
	return 0;
}





**********************************************************

			/*一、函数*/

	1、C语言中采用分组方式管理语句，每个语句分组叫做一个函数。
	2、多函数程序执行模式：
	  【1】整个程序的执行时间被划分成几段，不同时间段被分配给不同函数使用。
	  【2】所有时间段不能互相重叠并且是连续的。
	  【3】如果函数A在工作过程中把一段时间分配给函数B，则函数B在完成所有工作之后必须把后面的时间再还给函数A。
		【时间划分】
		b			***

		a		    ***	   ***

		main		****	      ***
	
	3、如果函数A在工作过程中把一段时间分配给函数B，则他们之间存在函数调用关系。
	   在这个关系中函数A叫做调用函数，函数B叫做被调用函数。
	4、函数调用关系有时间范围，只要被调用函数已经开始工作但还没有结束，
	   则函数调用关系存在。
	5、函数调用语句可以在程序执行过程中产生函数调用关系
	

*************	
  1 //函数演示
  2 #include<stdio.h>
  3 
  4 void print(void){
  5     printf("1\n");
  6 }
  7 int main(){
  8     print();
  9     return 0;
 10 }
********************	
	
	6、变量不可以跨函数使用。不同函数内部的变量可以重名。
	7、一个函数如果多次运行他内部的变量，每次对应的存储区都可能不同。

*********************
  1 //函数演示
  2 #include<stdio.h>
  3 
  4 void print(void){
  5     int num = 0;
  6     printf("1\n");
  7 }
  8 void func(void){
  9     int num;
 10     printf("num is %d\n",num);
 11     num = 10;
 12 }
 13 void func1(void){   //排除偶然两次调用func函数的因素
 14     int num = 10;
 15     int num1 = 11;
 16     int num2 = num + num1;
 17 
 18 }
 19 int main(){
 20     int num = 0;
 21 //  print();    
 22     func();
 23     func1();
 24     func();
 25     return 0;
 26 }
*********************
运行结果：
num is 134513857   //随机产生
num is 21	   //理应随机产生

*************************

	8、volatile关键字可以用来声明变量，如果变量对应的存储区可能被多个程序同时使用就应该在声明变量的时候使用这个关键字。
	9、函数调用过程中通常伴随着两个函数之间的数字传递。
	  数字传递存在两个完全相反的方向，
	  调用函数 到 被调用函数
	  被调用函数 到 调用函数
	10、不论那个方向的数据传递都需要使用被调用函数提供的存储区。
	11、被调用函数——>调用函数 只能传递一个数据(被调用函数的返回值)
							| 使用return 数值;
							V
						只能在函数结束时传递，
						被调用函数提供存储区。
						(存储区类型: 类型名 函数名)
	12、调用函数可以把函数调用语句当作数字使用，这个数字就是函数的返回值。
//函数返回值演示
  1 #include<stdio.h>
  2 int read(void){ //被调用函数
  3     int num = 0;
  4     printf("plz input a number:");
  5     scanf("%d",&num);
  6     return num;
  7 }   
  8 int main(){
  9     int num = read();    //调用read函数
 10     printf("num is %d\n",num);
 11     return 0;
 12 } 
********************
运行结果：
plz input a number:5
num is 5



【练习】
 /* 编写函数，解决鸡兔同笼问题，这个函数负责解决有多少个头和脚，
	然后把兔子的数量传递。*/

   #include <stdio.h>	
 20 int rabbit(void){
 21     int heads = 0,legs = 0,num = 0;
 22     printf("plz input the number of heads:");
 23     scanf("%d",&heads);
 24     printf("plz input the number of leds:");
 25     scanf("%d",&legs);
 26     for(num = 0;num <= heads;num++){  //计算兔子的数量
 27         if(4 * num + 2 * (heads - num) == legs){
 28             return num;
 29         }
 30     }
 31 }
 32 int main(){
 33     int num = rabbit();
 34     printf("There are %d rabbit\n",num);
 35     return 0;
 36 }

	
	13、如果函数提供存储区用来记录返回值但没有使用return关键字指定返回值的数值
		那么调用函数从这个存储区里获得的就是随机数。
	14、这个存储区不能用来和长期存放数字，调用函数获得返回值后，
		要么立刻使用 要么转存到其他存储区。
	15、函数名称前写void表示函数不提供存储区存放返回值。
		如果函数前面什么都没有，C99规范中不允许此情况
		C89规范中表示函数提供一个整数类型存储区存放返回值。
	16、函数不可以采用数组存放返回值。


【练习】
	从键盘得到两个整数，计算他们的最大公约数，并把结果传递给调用函数
		a	b
	不断作 b % a 得到的两个数与上面一组两个数最大公约数相 				
		48  	68
		20	48
		8	20	
		4	8
		0	4

【Gang】
  1 //用函数求最大公约数
  2 #include <stdio.h>
  3 int max_com(void){
  4     int a = 0,b = 0; // a > b
  5     int tmp = 0;
  6     printf("plz input two numbers:");
  7     scanf("%d%d",&a,&b);
  8     while(b % a){
  9         tmp = a;
 10         a = b % a;
 11         b = tmp;
 12     }
 13     return a;
 14 }
 15 
 16 int main(){
 17     int num = max_com();
 18     printf("max common number is %d\n",num);
 19     return 0;
 20 }




*****************************************
预习：
	1、函数
	2、递归
	3、作用域，全局变量和局部变量。






/**************************************************************************/
*									   *		
*				day_09					   *	
*									   *
/**************************************************************************/

		
	一、函数
	二、变长参数
	三、递归函数
	四、变量和作用域
	五、静态变量
	

	

			/*一、函数*/
			
	函数格式：
		返回值类型 函数名(形参){
	
		}

	
	1、为了从调用函数向被调用函数传递数据，
	也需要被调用函数提供一组存储区，这些存储区的类型和个数任意。
	2、可以在函数名称后的小括号里写一组变量声明语句，
	  用这些变量代表这些存储区。
	3、这些变量叫做函数的/*形式参数*/，小括号里的内容叫做函数的形式参数列表。
	4、每个形式参数的类型名称都不可以省略。不同形式参数声明用逗号分开。
	5、调用函数应该在函数调用语句的小括号里为每个形式参数提供一个对应的数字，
		这些数字叫做/*实际参数*/。
	6、能当作数字使用的内容都可以作为实际参数使用。
	7、如果函数不提供形式参数就应该在函数名称后面写 void 
	8、如果函数名称后面的小括号内容是空的就表示函数可以提供哦功能任意多个任意类型的形式参数。
	


**************
//形式参数演示
  1 #include<stdio.h>
  2 void print(int num,int num1/*形参*/){ //每个形参的类型不能省略
  3     printf("%d %d\n",num,num1);
  4 }
  5 int main(){
  6     print(4,6 + 7/*实参*/);
  7     return 0;
  8 }

***************



/*【练习】
	鸡兔同笼问题，头和脚的数量从调用函数里面解决。
*/
【Gang】
#include<stdio.h>
void print(int heads,int legs){
    int rabbits = 0;
    for(rabbits = 0;rabbits <= heads;rabbits++){
        if(rabbits * 2 + (heads - rabbits) * 4 == legs){
            printf("There are %d rabbits\n",rabbits);
        }   
    }   
}

int main(){
    print(40,120);
    return 0;
}


【改】
#include<stdio.h>
int print(int heads,int legs){
    int rabbits = 0;
    for(rabbits = 0;rabbits <= heads;rabbits++){
        if(rabbits * 4 + (heads - rabbits) * 2 == legs){
            return rabbits;
        }   
    }   
}

int main(){
    int heads = 0,legs = 0,num;
    printf("plz input numbers of heads and legs:");
    scanf("%d%d",&heads,&legs);
    num = print(heads,legs);
    printf("There are %d rabbits and %d checken\n",num,heads - num);
    return 0;
}


**************************

	1、数组可以作为形式参数使用，它仅仅是把形式参数写成数据的样子，
	       真正的形式参数并不是数组而是一个可以当作数组使用的变量。
	2、数组形式参数里包含的存储区都不是被调用函数提供的。
	3、数组形式参数可以让被调用函数使用其他函数提供的存储区(跨函数使用存储区)


//数组形式参数演示
#include<stdio.h>
void print(int arr[5]){
    int num = 0;
    for (num = 0;num <= 4;num++){
        printf("%d ",arr[num]);
    }   
    printf("\n");
}
void clear(int arr[5]){//将数组内容清零
    int num = 0;
    for (num = 0;num <= 4;num++){
        arr[num] = 0;
    }   
}

int main(){
    int arr[] = {1,2,3,4,5};//数组作为形参
    print(arr);
    clear(arr);
    print(arr);
    return 0;
}

************************

	4、使用数组形参可以实现双向数据传递，这种参数叫做输入输出参数。
	5、声明数组形参的时候可以省略其中包含的存储区个数。
	    如果省略，则需要提供另外一个整数类型形参表示数组里的存储区个数。


#include<stdio.h>
void print(int arr[],int size){ //声明一个size变量表示存储区个数
    int num = 0;
    for (num = 0;num <= size - 1;num++){
        printf("%d ",arr[num]);
    }   
    printf("\n");
}
void clear(int arr[],int size){//将数组内容清零
    int num = 0;
    for (num = 0;num <= size -1;num++){
        arr[num] = 0;
    }   
}

int main(){
    int arr[] = {1,2,3,4,5};//提供形参
    print(arr,5);
    clear(arr,5);
    print(arr,5);
    return 0;
}

***********************

【练习】
编写函数把一个数组里所有存储区的内容变成相反数，
在主函数数里把修改后的数组内容打印在屏幕上。
#include<stdio.h>
void print(int arr[5]){
	int num = 0;
	for(num = 0;num <= 4;num++){
		printf("%2d ",arr[num]);
	}
	printf("\n");
}

void negnum(int arr[5]){
	int num = 0;
	for(num = 0;num <= 4;num++){
		arr[num] =0 - arr[num];
	}
}

int main(){
	int arr[] = {1,2,3,4,5};
	print(arr);
	negnum(arr);
	print(arr);
	return 0;
}






			/*二、变长参数*/

	1、C语言中函数形参的数量不确定。
	2、变长参数不能事先命名，只能在被调用函数里通过特殊的方式得到它们。
	3、函数调用语句如果写在被调用函数语句前面，编译器会猜测函数格式
		这个猜测结果叫做函数的隐式声明。
	4、函数隐式声明中包含一个整数类型存储区用来存放返回值，还包含任意多个不确定类型的形参。
	5、隐式声明中的形参只能是int类型或double类型。
	6、如果函数隐式声明格式和真实格式不一致，在编译阶段就会出错。

		函数格式：
		返回值类型 函数名(形参)/*花括号前为函数声明*/ {

		}//花括号里的为函数体
	7、可以把函数声明单独写成一条语句，这个时候可以省略形参名称。
	8；函数的显示声明：
		把函数声明单独写在文件开头。 
	9、显示声明可以避免隐式声明。
	10、除了主函数以外的所有函数都应该显示声明。	
	


		/*exit标准函数*/可以立刻结束程序的执行
	1、为了使用这个标准函数需要包含stdlib.h头文件。
	2、这个函数需要一个证书作为实际参数，这个参数的作用和主函数的返回值一样。
		

*******************
//exit标准函数演示
  1 #include<stdio.h>
  2 #include<stdlib.h>
  3 void func(void){
  4     printf("2\n");
  5 //  return ; //立刻结束函数的执行
  6     exit(0); //结束程序
  7     printf("3\n");
  8 }
  9 
 10 int main(){
 11     printf("1\n");
 12     func();
 13     printf("4\n");
 14     return 0;
 15 }
******************


【练习】
	编写函数产生一张彩票，在主函数里把彩票内容打印在屏幕上
	彩票里包含7个1~36之间的随机数

【Gang】
//彩票2.0
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
void ticket(int arr[7]){
    srand(time(0));
    int num = 0;
    for(num = 0;num <= 6;num++){
        arr[num] = rand() % 36 + 1;
    }
    for(num = 0;num <= 6;num++){
        printf("%d ",arr[num]);
    }
}

int main(){
    int arr[7] = {0};
    ticket(arr);
    printf("\n");
    return 0;
}




//Mr.Yang

void ticket(int arr[],int size){
    int num = 0;
    for(num = 0;num <= size - 1;num++){
        arr[num] = rand() % 36 + 1;
    }   

}

int main(){
    srand(time(0));
    int arr[7] = {0},num = 0;
    ticket(arr,7);
    for (num = 0;num <= 6;num++){
        printf("%d ",arr[num]);
    }   
    printf("\n");
    return 0;
}


********************************************

			/*三、递归函数*/
	1、C语言中函数可以调用自己，这种函数叫做递归函数。
	2、如果一个问题可以分解成几个小问题，
	    其中至少有一个小问题和原来的问题本质上一样，
	     只是稍微简单了一点，这种问题就可以采用递归函数解决。

	3、编写递归函数步骤：
		a.编写语句描述问题的分解方式(假设递归函数已经完成)
		b.在函数开头编写分支处理不可分解的情况(这个分支必须能让函数结束)
		(不需要明白程序执行过程！)
		
//递归函数演示
#include<stdio.h>
void print(int num){
    if (num == 1){ 
        printf("1 ");
        return ;
    }   
    print(num - 1); //假设递归函数已经完成，打印从1开始到num - 1
    printf("%d ",num);//打印num
}

int main(){
    int num = 0;
    printf("plz intput a number:");
    scanf("%d",&num);
    print(num);
    printf("\n");
    return 0;
}



******************
	
	4、能用递归解决的问题也能用循环解决。
		采用递归函数解决问题的思路叫做递归
		采用循环解决问题的思路叫做//递推		


【练习】
编写递归函数，计算从1开始到某个整数之间
  所有整数的和。

/*编写递归函数，计算从1开始到某个整数之间
  所有整数的和。
  */
#include<stdio.h>
int sum(int num){
    if(num == 1){ 
        return 1;    //num为1的情况
    }   
    
     return sum(num - 1) + num;//num不为1的情况 
}

int main(){
    int num = 0;
    printf("plz input a number:");
    scanf("%d",&num);
    printf("sum = %d\n",sum(num));
    return 0;
  }


**********************



			/*四、变量和作用域*/
	1、可以使用某个变量的所有语句叫做这个变量的作用域。
	2、声明在函数内部的变量叫做//局部变量，
	    它的作用域只包含声明它的函数内部的所有语句。
	3、声明在所有函数外边的变量叫做//全局变量，
	    它的作用域包含程序中的所有语句。
	
	4、没有初始化的/*全局变量*/会自动被初始化为 0 。
		      /*局部变量*/ 随机	
	5、局部变量可以和全局变量重名，使用这个变量名时，
		计算机会优先选择局部变量。

	

****************

//变量演示
#include<stdio.h>
 int num;       //全局变量
void func(void){
//  int num;    //局部变量
    printf("num = %d\n",num);
}
int main(){
    int num = 10; 
    func();     //结果num = 0 (使用全局便来那个)
    printf("num = %d\n",num);//结果num = 10(优先使用局部变量)
    return 0;
}
  
***********
	6、如果全局变量和局部变量都能满足程序要求就应该选择局部变量。
	7、变量的使用受作用域限制，而存储区不受(可以跨函数使用存储区)
	8、存储区的使用受到生命周期的限制。存储区只能在这个时间范围内使用。
	9、全局变量的生命周期是整个程序执行的时间范围，
		局部变量的生命周期是包含它的函数某一次执行的时间范围。
	
	10、如果一个函数多次执行，每次执行时它里面的局部变量对应的存储区都可能不同






			/*五、静态变量*/

	1、 static 关键字可以用来声明/*静态变量*/，静态变量的生命周期和作用域和普通变量不同。
	2、所有静态变量的生命周期都是整个程序的执行时间。
	3、静态变量存储区任何时候都可以使用。
	4、没有初始化的静态变量会自动被初始化为 0 (类似与全局变量) 
	5、静态变量只在程序开始执行的时候做一次初始化。
	6、可以跨函数使用静态局部变量的存储区。
	7、静态全局变量的作用域只包含声明他的文件内部的所有语句。



练习：
  1 1 2 3 5 8 13 21 ...
  0 1 2 3 4 5  6  7 ...
	
【Gang】
#include <stdio.h>
int fei(int num){
    if(num <= 1){ 
        return 1;
    }   
    return fei(num - 1) + fei(num - 2); 
}

int main(){
    int num = 0;
    printf("plz input the code:");
    scanf("%d",&num);
    printf("the number is %d\n",fei(num));
    return 0;
}



**********************************
作业：
	使用数组改写斐波那契数列。
	  多用几种方法。(最多3种)

/*
用数组改写斐波那契数列。
用三种不同的方法
    思路：延长数组生命周期，加快程序运行。
*/
#include <stdio.h>
/*方法一  将数组放在主函数内
int fei(int arr[],int num){
    int i = 0;
    for(i = 0;i <= num;i++){
        if(i <= 1){
            arr[i] = 1;
        }
        else{
            arr[i] = arr[i - 1] + arr[i - 2]; 
        }
    }
        return arr[num];
}

int main(){
    int num = 0;
    printf("plz input the code:");
    scanf("%d",&num);
    int arr[num];
    printf("the number is %d\n",fei(arr,num));
    return 0;
}*/


//Mr.Yang
int arr[50];    //法2 将数组改为全局变量
                //全局数组不需要初始化
int fei(int num){
//   static int arr[50] = {0}; //法3 延长数组生命周期
    if(num <= 1){
        return 1;
    }
    if(!arr[num - 2]){
        arr[num - 2] = fei(num - 2);
    }
    if(!arr[num - 1]){
        arr[num - 1] = fei(num - 1);
    }
     return fei(num - 1) + fei(num - 2);
}

int main(){
    int num = 0;
    printf("plz input the code:");
    scanf("%d",&num);
    printf("the number is %d\n",fei(num));
    return 0;
}





***************************

预习：
	指针





/**************************************************************************/
*									   *		
*				day_10					   *	
*									   *
/**************************************************************************/

	一、指针变量
	二、字符串
	三、字符串字面值





			/*一、指针变量*/  /*pointer*/
	1、只有记录有效地址的指针才能使用。
	2、有效指针变量前加*可以表示捆绑的存储区。
	3、指针变量也分类型，不同类型的指针适合与不同类型的存储区捆绑。
	4、可以在一条语句里声明多个同类项指针，每个指针变量名称前单独加‘*’
	5、没有捆绑的指针分为两类：
		1、空指针里记录固定地址(空地址，用NULL表示，数值为0)
		2、除了空指针以外的没有捆绑的指针都叫野指针。
	6、程序中禁止出现野指针。
	7、所有指针必须初始化。指针变量初始化过程中‘*’不参与赋值。

************
//指针演示
#include <stdio.h>
int main(){
    int num = 0;
    int *p_num = &num,*p_num1 = NULL;   //所有指针必须初始化，避免野指针！
    *p_num = 10;         // *用来找到num的存储区
    printf("num is %d\n",num);
    return 0;
}
*****************

【练习】
 	从键盘得到三个整数，从大到小输出


//从键盘得到三个整数，从大到小输出
#include<stdio.h>

int main(){
    int num1 = 0,num2 = 0,num3 = 0,tmp = 0;
    int *p_num1 = &num1,*p_num2 = &num2,*p_num3 = &num3,*p_tmp = &tmp; 
    //声明三个指针变量分别和三个数字捆绑。
    printf("plz input three numbers:");
    scanf("%d%d%d",p_num1,p_num2,p_num3);
    if(*p_num1 < *p_num2){
        *p_tmp = *p_num1;
        *p_num1 = *p_num2;   //赋值语句如果不加‘*’
        *p_num2 = *p_tmp;    //则指针和数字之间的捆绑关系就变了。
    }   
    if(*p_num1 < *p_num3){
        *p_tmp = *p_num1;
        *p_num1 = *p_num3;
        *p_num3 = *p_tmp;
    }   
    if(*p_num2 < *p_num3){
        *p_tmp = *p_num2;
        *p_num2 = *p_num3;
        *p_num3 = *p_tmp;
    }   
    printf("Numbers from bigger to smaller: %d %d %d\n",*p_num1,*p_num2,*p_num3);
    return 0;
}

*************************************


	8、指针变量和普通变量之间的捆绑关系可以随着程序的执行不断变化。
	9、可以把指针看作普通变量的某种身份，
		可以使用指针实现针对身份编程。
	10、用一个指针和数组里第一个存储区捆绑，
	    就可以通过这个指针找到数组里每个存储区，
	    此时可以认为指针间接捆绑了数组里的所有存储区。
	11、地址数据可以参与如下计算：
		a.地址 + 整数
		b.地址 - 整数
		c.地址 - 地址
	
	12、地址加减整数n实际加减的是n个捆绑存储区的大小



***************	
//地址数据演示
#include<stdio.h>

int main(){
    int arr[5] = {1,2,3,4,5};
    printf("arr is %p\narr + 2 is %p\n",arr,arr + 2); 
    return 0;

}
*************
arr is 0xbf8589fc
arr + 2 is 0xbf858a04

结果相差 8 个字节
***********


	13、地址减地址的结果是一个整数，这个结果表示两个地址之间捆绑存储区的个数。
		printf("&arr[2] - arr is %d\n",&arr[2] - arr);
	


****************

//指针和数组的关系
#include<stdio.h>

int main(){
    int arr[5] = {1,2,3,4,5};
    int *p_num = arr ; //用数组名称对指针初始化。
    int num = 0;
    for(num = 0;num <= 4;num++){
        printf("%d ",arr[num]);   // ok
        printf("%d ",*(arr + num));  //bad
        printf("%d ",p_num[num]);  // not good
        printf("%d ",*(p_num + num));  //best
    }   
    printf("\n");
    return 0;
}

****************************

	14、所有跨函数使用存储区都是通过指针实现的。
	15、数组做形参的时候真正的形参是一个指针变量。

【练习】
用指针做形参将数组的内容打印在屏幕上
【Gang】
//用指针做形参将数组的内容打印在屏幕上

#include<stdio.h>
void print(int *p_num){
    int num = 0;
    for (num = 0;num <= 4;num++){

    printf("%d ",*(p_num + num));
    }   
}

int main(){
    int num = 0;
    int arr[5] = {1,2,3,4,5};
    int *p_num = arr;
    print(p_num);
    printf("\n");
    return 0;
}


*******************
【练习】

编写程序 把调用函数中两个变量内容交换

#include<stdio.h>
void swap(int *p_num1,int*p_num2){
    int tmp = *p_num1;
    *p_num1 = *p_num2;
    *p_num2 = tmp;

}

int main(){
    int num1 = 3,num2 = 7;
    swap(&num1,&num2);
    printf("num1 = %d num2 = %d\n",num1,num2);
    return 0;
}


	16、指针存储区可以用来存放函数的返回值。
		这样可以让调用函数使用被调用函数提供的存储区。
	17、不可以把非静态局部变量的地址作为返回值(生命周期太短！)


//指针返回值演示
#include<stdio.h>
int *read(void){
    static int num;   //静态局部变量不可以初始化。。
    printf("plz input a number:");
    scanf("%d",&num);
    return &num;

}

int main(){
    int *p_num = read();
    printf("%d\n",*p_num);
    return 0;
}




	const 关键字可以用来声明变量，多数情况下用来声明指针。

	1、声明指针变量的时候可以把 const 关键字写在/*类型名称*/前，
		表示不可以通过指针对捆绑存储区进行赋值，但可以对指针本身的存储区进行赋值。

******************
//const关键字演示
#include<stdio.h>

int main(){ 
    int num = 0;
    const int *p_num = &num;
//  *p_num = 10; 不能通过指针对捆绑存储区赋值；
    p_num = NULL;   //可以对指针本身的存储区赋值
    return 0;
}
	
*************************

	2、指针形参要尽量采用上面的方式加const关键字。
	3、可以在声明指针变量的时候把 const 关键字写在/*指针变量名称*/前，
	   可以通过这种指针对捆绑存储区做赋值，但是不可以对指针本身做赋值。


***********************
//const关键字演示
#include<stdio.h>
int main(){ 
    int num = 0;
    const int *p_num = &num;
//  *p_num = 10;    //不能通过指针对捆绑存储区赋值；
    p_num = NULL;   //可以对指针本身的存储区赋值
    
    int const p_num1 = &num;
    *p_num1 = 10;   //可以对对指针捆绑存储区做赋值
//  p_num1 = NULL;  //不能对指针本身做赋值。
    return 0;
}
********************
	
	4、可以在声明指针变量时使用 void 作为类型名称，称为/*无类型指针*/。
	5、这种指针可以和任意类型存储区捆绑。不能通过这种指针做的捆绑存储区的类型。
	6、这种指针不可以直接在前面加*来使用。
	7、这种指针必须首先强制类型转换成有类型指针，然后才能在前面加*表示捆绑存储区。

***************	
//无类型指针演示
#include<stdio.h>
int main(){
    char ch = 'a';
    int num = 20; 
    float fnum = 5.4f;
    void *p_v = NULL;
    p_v = &ch;
    printf("%c\n",*(char *)p_v);  //强制类型转换
    p_v = &num;
    printf("%d\n",*(int *)p_v);
    p_v = &fnum;
    printf("%g\n",*(float *)p_v);
    return 0;
}
*******************
运行结果：
a
20
5.4
*******************

	8、无类型指针通常作为形参使用，可以通过它把任意类型的存储区传递给被调用函数。
	
************************************************************************



			/*二、字符串*/
	
	1、C语言里所有文字信息必须存储在一组连续的字符类型存储区里。
	2、所有文字信息必须以‘\0’作为结尾，这个字符的ASCII码就是数字 0 。
		  符合以上特征的内容叫做/*字符串*/。
	3、字符串里‘\0’字符前面的部分是有效字符。
	4、所有字符串一定可以采用字符类型指针表示。








			/*三、字符串字面值*/
	1、用两个双引号中间的一组字符表示，例如："abc","^&%" ...
	2、编译器在编译的时候会自动在字符串字面值后面加上'\0'字符。
	3、编译器编译时会吧字符串字面值替换成第一个字符所在存储区的地址。
	4、字符串面值的内容在程序执行过程中不可以改变。


*************
//字符串演示
#include <stdio.h>

int main(){
    printf("%p\n","abc");      // 字符a的地址
    printf("%p\n","abc" + 3);  // \0 地地址
    printf("%d\n",*("abc" + 3)); // 寻址 结果为0
//  *"abc" = 'x';       // 将a换为x 出现错误！
    return 0;
}

*************

	5、程序中多个内容一样的字符串字面值在程序执行的时候其实是同一个。
	6、并列写在一起的多个字符串面值会被编译器合并成一个。
	7、字符数组也可以用来表示字符串。只有包含'\0'字符的字符数组才可以代表字符串。
	8、可以采用字符字面值对字符数组进行初始化，
 	   这个时候字符串字面值里的'\0'字符也会被初始化到字符数组里。

	9、字符数组里的字符串内容可以修改。

	10、可以用 %s 作为占位符把字符串里的所有字符显示在屏幕上。

*****************

int main(){
    char str[] = "xyz";
    printf("sizeof(str) is %d\n",sizeof(str));
    str[0] = 'a';
    printf("%s\n",str);
    return 0;
}
***************




作业：
	编写函数把一个数组里的所有存储区内容前后颠倒。
		如数组里原有内容是 1 2 3 4 5 
		颠倒后的内容为 5 4 3 2 1 
	要求用返回值表示处理后的数组，用指针编写程序。


【Gang】
int reverse(int *p_num){
    int num = 0;
    int arr[5] = {0}; 
    for (num = 0;num <= 4;num++){
         arr[4 - num] = *(p_num + num);
    }   
    for(num = 0;num <= 4;num++){
        printf("%d ",arr[num]);
    }   
}
int main(){
    int arr[] = {1,2,3,4,5};
    reverse(arr);
    printf("\n");

    return 0;
}

//Mr.Yang

// task of pointers
#include<stdio.h>
int *reverse(int *p_num,int size){
    int tmp = 0;
    int *p_start = p_num;           //数组第一个存储区
    int *p_end = p_num + size - 1;  //数组最后一个存储区

    while (p_start < p_end){    
        tmp = *p_start;             //交换头尾指针内容
        *p_start = *p_end;
        *p_end = tmp;
        p_start++;
        p_end--;
    }   
    return p_num;
}

int main(){
    int num = 0;
    int arr[] = {1,2,3,4,5};
    int *p_num = reverse(arr,5);
    for(num = 0;num <= 4;num++){
        printf("%d ",*(p_num + num));
    }   
    printf("\n");
    return 0;
}





/**************************************************************************/
*									   *		
*				day_11					   *	
*									   *
/**************************************************************************/

	
	一、字符串函数
	二、指针数组
	三、主函数参数
	


			/*一、字符串函数*/
	1、C语言中不可以使用操作符操作字符串，应该使用一组标准函数。
	2、为了使用这些标准函数，需要包含/* string.h 头文件 */。

	3、strlen	统计字符串里有效字符的个数(\0 前面的字符)。
			和sizeof关键字不同。

	4、strcat	合并两个字符串。有可能修改不属于数组的存储区，
			这会造成严重后果。

	   strncat	功能和strcat类似，但是可以避免修改不属于数组的存储区。
					
	5、strcmp	用来比较两个字符串的大小。	
				返回值是1表示前一个字符串大，
				返回值是-1表示后一个字符串大，
				返回值是0表示一样大。

	   strncmp	比较两个字符串的前n个字符。

	6、strcpy	把字符串复制到字符数组里。
			这个函数也可能修改不属于数组的存储区，这可能导致严重错误。


	   strncpy	可以只拷贝字符串里的前n个字符。
	
	7、memset	可以把字符数组里前n个存储区都设置成同一个字符。

	8、strstr	在一个大字符串里查找某个小字符串的位置。
			如果没有找到则返回NULL
	


****************

//字符串函数演示
#include<stdio.h>
#include<string.h>
int main(){
    char str[10] = "xyz";
    int len = strlen(str);      //strlen 统计有效字符个数
    printf("lenth is %d\n",len);
    printf("sizeof(str) is %d\n",sizeof(str));//sizeof统计数组所有字符个数

    printf("%s\n",strcat(str,"abc"));   //前一个参数必须是字符串数组。
    printf("%s\n",str);         //效果与上相同。

    printf("比较结果是%d\n",strcmp("abc","abd"));

    printf("%s\n",strcpy(str,"123456")); //字符串复制到字符数组里
    printf("%s\n",str);     //效果同上 ，与用字符串初始化数组效果相同。

    memset(str,'h',10);     //设置数组为10个 h
    printf("%s\n",str);

    printf("%s\n",strstr("abcdefghijklmn","def"));  //效果从def一直打印到末尾

    return 0;

}

**********************
运行结果：
lenth is 3
sizeof(str) is 10
xyzabc
xyzabc
比较结果是-1
123456
123456
hhhhhhhhhh
defghijklmn

**********************



	其他字符串相关函数(不需要string.h头文件)

	1、sprintf		按格式把多个数字打印到字符数组里形成字符串。

	2、sscanf		按格式从字符串里得到多个数字并记录到存储区里。


***************
#include<stdio.h>

int main(){
    char str[20] = {0};
    printf("%d %g %c\n",34,5.4f,'u');
    
    sprintf(str,"%d %g %c\n",34,5.4f,'u');  //将三个数字形成字符串打印到数组里
    printf("%s\n",str);     //两行效果同上面一行

    int num = 0;
    float fnum = 0.0f;
    char ch = 0;
    sscanf("5.4 p 67","%g %c %d",&fnum,&ch,&num);
    printf("%c %d %g\n",ch,num,fnum);

    return 0;
}

*********************
运行结果：
34 5.4 u
34 5.4 u

p 67 5.4
*********************


	
	以下俩函数可以把字符串里的数字转换成数字类型。
	为了使用它们，需要包含stdlib.h头文件。

	atoi		可以把字符串里的整数转换成整数类型。

	atof		可以把字符串里的浮点数转换成双精度浮点类型	

*****************
#include<stdio.h>
#include<stdlib.h>

int main(){
    int num = atoi("34adsgsd");
    printf("num is %d\n",num);
    
    double dnum = atof("23.67dsgj");
    printf("dnum is %lg\n",dnum);
    return 0;
}
******************
运行结果：
num is 34
dnum is 23.67
******************




【练习】

编写程序从键盘的到5个考试成绩，把他们按照如下格式拼凑成一个字符串

	67，98，34，76，93

【Gang】

#include<stdio.h>

int main(){
    char str[5] = {0};
    int a,b,c,d,e;
    printf("plz input five scores:");
    scanf("%d%d%d%d%d",&a,&b,&c,&d,&e);
    sprintf(str,"%d,%d,%d,%d,%d",a,b,c,d,e);
    printf("%s\n",str);

    return 0;
}


//Mr.Yang
#include<stdio.h>
#include<string.h>
int main(){
    char tmp[10] = {0},grades[30] = {0};
    int num = 0,grade = 0;
    for (num = 1;num <= 5;num++){
        printf("plz input a grade:");
        scanf("%d",&grade);
        sprintf(tmp,"%d,",grade);   //将输入的一个成绩打印入tmp数组中
        strcat(grades,tmp);         //将tmp中的字符合并入grade数组中
    }   
    grades[strlen(grades) - 1] = 0;// 将最后一个逗号赋值为0
    printf("%s\n",grades);
    return 0;
}




************************************************
			/*获得字符串fgets*/

	1、fgets函数可以从键盘得到一个字符串并记录到一个数组里。
		这个函数可以避免出现scanf函数的问题(不能录入空格等)

	2、这个函数需要三个参数：
		a.数组名称
		b.数组里的存储区个数。
		c.用stdin表示键盘
	    [e.g.] fgets(str,10,stdin);
	
	3、如果用户输入的内容不足以充满数组，
	   计算机把用户最后输入的回车字符也记录到数组里。
	4、如果输入内容超过数组容量就把后面的内容留在输入缓冲区里等待下次读取。
	5、每次使用万fgets函数后都需要清理输入缓冲区里可能存在的多余数据。
		并且只有确保有多余数据的时候才应该清理。
*****************

//获得字符串演示

#include<stdio.h>
#include<string.h>
int main(){
    char str[10] = {0}; 
    printf("plz input a string:");
//  scanf("%s",str);
    
    fgets(str,10,stdin);
    if(strlen(str) == 9 && str[8] != '\n'){ //确保有多余数据的时候，才清理
        scanf("%*[^\n]");    
        scanf("%*c");
    }   
    printf("%s\n",str);
    
    printf("plz input another string:");
    fgets(str,10,stdin);
    printf("%s\n",str);
    return 0;
}

***************


【练习】
编写模拟登陆程序：
	给用户三次机会，每次要求输入用户名和密码。
	如果三次都失败就提示登陆失败，否则提示登陆成功。
	正确的用户名是admin	正确的密码是123456

//模拟登陆程序、
#include<stdio.h>
#include<string.h>
int main(){
    char usr[10] = {0},pw[10] = {0};
    int i = 0;
    for(i = 1;i <= 3;i++){
            printf("plz input user name:");
            fgets(usr,10,stdin);
            if(strlen(usr) == 9 && usr[8] != '\n'){//clean 
                scanf("%*[^\n]");
                scanf("%*c");
            }   
            if(strcmp(usr,"admin\n")){   
                continue;
            }   

            printf("plz input passward:");
            fgets(pw,10,stdin);
            if(strlen(pw) == 9 && pw[8] != '\n'){//clean 
                scanf("%*[^\n]");
                scanf("%*c");
            }   
            if(strcmp(pw,"123456\n")){   
                continue;
            }   
            break;
    }   
    if(i <= 3){ //异常结束 登陆成功
        printf("succed login\n");
    }   
    else{   //正常结束 登陆失败
        printf("fail to login\n");
    }   

    return 0;
}



*****************************************
		
			
			/*二、字符指针数组*/
	1、指针数组中每个存储区是一个指针类型存储区。
	2、字符指针数组里包含多个字符类型指针，每个指针可以用来代表一个字符串。
	3、字符指针数组就可以用来代表多个相关字符串。

//字符指针数组演示

#include<stdio.h>

int main(){
    char *strs[5] = {"abc","def","hij","klm","xyz"};
    int num = 0;
    for(num = 0;num <= 4;num++){
        printf("%s\n",strs[num]);
    }   
    return 0;
}


*********************************************

			/*三、主函数参数*/

	1、主函数的第二个参数就是一个字符指针数组。
	    int main(int argc,char *argv[])
	
	2、第一个参数表示第二个参数里有多少个指针


//主函数参数演示
#include<stdio.h>
int main(int argc,char *argv[]){ // 1整数，2字符指针数组
	//第一个参数表示第二个参数里有多少个指针
	int num = 0;
	for(num = 0;num <= argc - 1;num++){
		printf("%s\n",argv[num]);

	}
	return 0;
}








预习：
	1、宏
	2、条件编译
	3、多文件编程

作业：
	1、把一个字符串里的考试成绩拆出来，
	 计算并打印其和。


【Gang】
#include <stdio.h>
#include <string.h>
int main(){
    int a,b,c,d,e,sum;
    sscanf("50,60,70,80,90","%d,%d,%d,%d,%d",&a,&b,&c,&d,&e);
    sum = a + b + c + d + e;

    printf("sum = %d\n",sum);
    return 0;
}


//Mr.Yang
#include <stdio.h>
#include <string.h>						
int main(){
    int sum = 0;
    char grades[] = "10,20,30,40,50,60";
    char *p_grade = grades;
    while(1){   //死循环
        sum += atoi(p_grade);
        p_grade = strstr(p_grade,","); //在字符串指针数组中找到逗号
        if(!p_grade){   //处理没找到逗号的情况
            break;
        }   
        p_grade++;
    }   
    printf("sum = %d\n",sum);
    return 0;
}





/**************************************************************************/
*									   *		
*				day_12					   *	
*									   *
/**************************************************************************/


	一、预处理指令
	二、宏操作符
	三、条件编译
	四、多文件编程




		
			/*一、预处理指令*/
	1、#define预处理指令用来定义宏。
	2、宏可以用来给数字起名字。

***********
//宏演示1
#include <stdio.h>
#define     PI      3.14f
int main(){
    int radius = 0;
    printf("plz input radius:");
    scanf("%d",&radius);
    printf("%g\n",2*PI*radius);
    return 0;
}
*********************

	3、宏名称通常都是大写的。并且没有空格
	4、用宏给数字起名字的语句不能包含复制操作符。
	5、可以在编译命令中使用-D选项定义宏。
		
		【e.g.】gcc -DSIZE=5 02hong.c


	6、程序中有些数字在编写时无法确定，只有在编译的时候才知道。这种数字就应该采用宏表示。

	7、宏还可以给计算公式起名字
		用宏的参数表示计算公式里的未知数字。

************
//宏演示2
#include <stdio.h>
#define     PI      3.14f
#define     CIRCLE(r)   2 * PI * r
int main(){
    int radius = 0;
    printf("plz input radius:");
    scanf("%d",&radius);
    printf("%g\n",CIRCLE(radius));
    return 0;
}
**************

	8、宏的参数不一定代表数字，所以它没有类型名称。
	9、宏不可以使用自己的存储区和函数进行数据传递。
	10、宏没有形参也没有用来存放返回值的存储区。
	11、能当作数字使用的宏必须编写成表达式。
	12、宏的参数代表的就是函数的存储区，可以直接修改内容。
*************
//宏演示3
#include<stdio.h>
#define     ABS(n)      n >= 0 ? n : 0 - n
#include<stdio.h>
#define     ABS(n)      n >= 0 ? n : 0 - n
#define     NEG(n)      n = 0 - n
void neg(int *p_num){           //利用指针形参跨函数使用存储区
    *p_num = 0 - *p_num;
}

int abs(int num){
    if(num >= 0){ 
        return num;
    }   
    else{
        return 0 - num;
    }   
}
int main(){
    int num = 0;
    printf("plz input a num:");
    scanf("%d",&num);
    printf("abs(num) is %d\n",abs(num));
    printf("ABS(num) is %d\n\n",ABS(num));
    neg(&num);
    printf("NEG(num) is %d\n",num);
    NEG(num);
    printf("NEG(num) is %d\n",num);
    return 0;
}

*****************
	

【练习1】
	编写一个宏计算两个整数相减的结果。
#include <stdio.h>
#define     SUB(a,b)    a - b
int main(){
    int a = 0,b = 0;
    printf("plz input two numbers:");
    scanf("%d%d",&a,&b);
    printf("result is %d\n",SUB(a,b));
    return 0;
}
			/*    gcc -E 文件名 查看编译器运行步骤	*/
	13、因为宏存没有储区用来存放返回值，所有不能保证优先计算宏内部的操作符。
	   所以能当作数字使用的宏必须写在小括号里。(保证宏的优先级)

***********
#include <stdio.h>
#define     SUB(a,b)    ((a) - (b))
int main(){
    printf("result is %d\n",SUB(10,7));
    printf("result is %d\n",20 - SUB(10,7));
    printf("result is %d\n",SUB(20,10 - 7));
    return 0;
}
************

	14、因为宏没有形参，所有不能保证优先计算参数内部的操作符。
	   所以能当作数字使用的宏参数必须写在小括号里。(保证宏的优先级)

【练习】

	用宏编写计算一个数的平方
#include <stdio.h>
#define     SQU(num)        ((num) * (num))

int main(){
    int num = 5;
    printf("10^2 = %d\n",SQU(10));
    printf(" (++num) * (++num) =  %d\n",SQU(++num)); // 7 * 7
    return 0;

}

	15、不要把自增或自减的结果作为宏的参数使用。




***********************************

			/*二、宏操作符*/

	1、#是一个宏操作符，它可以把宏的参数转换成字符串字面值。

	2、##也是一个宏操作符，它可以把一个代表表示符的参数和其他连接成为新的标识符

//宏操作符演示
#include<stdio.h>
#define     STR(n)      #n
#define     LOCAL(n)    l_##n
int main(){
    STR(2 + 3);     // int num = 0;
    int num = 0;
    int LOCAL(num) = 0; //int l_num = 0;
    return 0;
}



********************



			/*三、条件编译*/

	1、条件编译可以在编译的时候从几组语句中选择一组编译，忽略其他组。

	#ifdef/#ifndef...#else...#endif

	以上结构可以在编译时根据一个宏是否被定义过从粮足语中选择一组编译。
	
	如果最前面的预处理指令选择#ifdef就表示如果它后面宏被定义过时，编译前一组语句，否则编译后一组语句。

	如果选择#ifndef刚好相反。

//条件编译演示
#include<stdio.h>
int main(){
#ifdef    YI
    printf("1\n");
#else    
    printf("2\n");
#endif
    return 0;
}

**********************

【练习】
	编写点菜程序：
	1表示龙虾，2表示小鸡炖蘑菇。
/*点菜程序：
    1表示龙虾   2表示小鸡炖蘑菇
    赵 1 无 2 真没有
    其他1 有 2 无
*/
#include<stdio.h>
int main(){
    int order = 0;
    printf("请点菜：");
    scanf("%d",&order);
#ifdef  ZHAO
    if (order == 1){ 
        printf("没有\n");
    }   
    else{
        printf("真没有\n");
    }   
#else
    if (order == 1){ 
    printf("有\n");
    }   
    else{
    printf("没有\n");
    }   
#endif
    return 0;
}


****************************


	2 #if...#elif(任意多次)...#else...#endif
	  以上结构可以根据任意逻辑表达式从多组语句中选择一组编译。



【练习】
	过季商店	8折
	普通商店	原价
	精品商店	1.2

打印当前商店的折扣
//条件编译演示2
#include<stdio.h>

int main(){
#if     defined(GONGCHANG)      //将宏名称转换成布尔值
    printf("80%%\n");
#elif   !defined(GONGCHANG) && !defined(JINGPIN)
    printf("100%%\n");
#else
    printf("120%%\n");
#endif
    return 0;
}
********************
gcc 09cond.c
./a.out
运行结果：100%

gcc -DGONGCHANG 09cond.c
./a.out
运行结果：80%

gcc -DJINGPIN 09cond.c
./a.out
运行结果：120%

*********************



			/*四、多文件编程*/

	1、多文件编程时，每个文件里可以包含多个函数，一个函数只能属于一个文件。
	
           多文件编程步骤：
		(1).把所有函数分散在多个不同的源文件里
		  (主函数通常单独放在一个文件里)

		(2).为每个源文件白哪些配对的头文件，
		    所有不分配内存的内容都可以写在头文件里,
		    至少应该包含配对源文件里的所有函数声明。
		   (主函数所在的文件不需要配对的头文件)

		(3).为每个源文件包含必要的头文件(配对头文件是必要头文件,
		    如果源文件里使用了头文件中声明的函数则它也是必要头文件)	


	2、可以在gcc命令后列出所有源文件名称，用这种方法可以编译多文件程序。

//多文件编程演示 
//10duo.c
#include <stdio.h>
#include "11add.h"
int main(){
    int num = add(2,6);
    printf("num is %d\n",num);
    return 0;
}

//11add.c
#include "11add.h"
int add(int num,int num1){
    return num + num1;
} 

//11add.h
int add(int,int);


	
	
	3、可以把多文件程序的编译过程记录在Makefile里，
	   然后使用make工具根据Makefile文件内容对多文件程序进行编译。

	4、应该把头文件内容包含在预处理指令中，
	   这样可以保证不论源文件中多少次包含头文件都只会编译一次。
//11add.h
#ifndef     __11ADD_H__
#define     __11ADD_H__
int add(int,int);   
#endif  //__11ADD_H__



	5、头文件里使用的宏名称应该根据文件路径得到。

【练习】
	编写函数从键盘得到一个整数，并把这个整数传递给调用函数

	要求用多文件编程方式实现。


//多文件编程
//12num.c
#include <stdio.h>
#include "12get.h"
int main(){
    int num = print();
    printf("num is %d\n",num);
    return 0;
}

//12get.c
#include <stdio.h>
#include "12get.h"
int print(void){
    int num = 0;
    printf("plz input a number:");
    scanf("%d",&num);
    return num;
}

//12get.h
#ifndef     __12GET_H__
#define     __12GET_H__
int print(void);
#endif




	【tips】
		如果一个源文件里希望使用另外一个源文件里声明的全局变量就需要使用
	extern 关键字再次声明那个变量。

		2、使用 extern 关键字声明变量的语句不会分配内存。
			(可以转移到头文件中)


//多文件编程  改~
//12num.c
#include <stdio.h>
#include "12get.h"
//extern int num;     //一个源文件想使用另外一个源文件的全局变量,需要再次声明。
			(可以转移到头文件中)
int main(){
    print();
    printf("num is %d\n",num);
    return 0;
}

//12get.c
#include <stdio.h>
#include "12get.h"
int num;		//改为全局变量	
void print(void){
    printf("plz input a number:");
    scanf("%d",&num);
}

//12get.h
#ifndef     __12GET_H__
#define     __12GET_H__
extern int num;		
int print(void);
#endif	   //__12GET_H__



*************************************
预习：
	结构体、枚举和联合。

作业：
	编写宏实现字符大小写之间的转换。

//宏编程
#include<stdio.h>
#define     SWAP1(ch)   ch >= 'a' && ch <= 'z' ? ch + 'A' - 'a' : 0 
#define     SWAP2(ch)   ch >= 'A' && ch <= 'Z' ? ch + 'a' - 'A' : 0
int main(){
    char ch = 0;
    printf("plz input a char:");
    scanf("%c",&ch);
    if (ch >= 'a' && ch <= 'z'){
        printf("%c\n",SWAP1(ch));
    }   
    else if (ch >= 'A' && ch <= 'Z'){
        printf("%c\n",SWAP2(ch));
    }
    else{
	printf("ERROR\n");
    }   
    return 0;
}

//Mr.Yang
#include <stdio.h>
#define     CHR(ch)     ((ch) >= 'a' && (ch) <= 'z' ? (ch) +'A' -'a' : (ch) - 'A' +'a')
int main(){
    char ch = 0;
    printf("plz input a char:");
    scanf("%c",&ch);
    printf("Change after is: %c\n",CHR(ch));
    return 0;
}


//多文件编程
//tra.c
#include <stdio.h>
#include "tra.h"
char ch; 
void print(void){
    printf("plz input a letter:");
    scanf("%c",&ch);
    if (ch >= 'A' && ch <= 'Z'){    //大写 => 小写
        ch = ch + 'a' - 'A';
    }   
    else if(ch >= 'a' && ch <= 'z'){ // 小写 => 大写    
        ch = ch + 'A' - 'a';
    }   
}

//main.c
#include <stdio.h>
#include "tra.h"
int main(){
    print();
    printf("corresponding letter is %c\n",ch);
    return 0;
}

//tra.h
#ifndef     __TRA_H__
#define     __TRA_H__
extern char ch; 
void print(void);
#endif      //__TRA_H__







/**************************************************************************/
*									   *		
*				day_13					   *	
*									   *
/**************************************************************************/



	一、结构体
	二、结构体指针
	三、结构体应用
	四、数据对齐
	五、数据补齐


				/*一、结构体*/

	1、C语言可以在一个存储区里存放多个相关数字。
	2、这种存储区的类型叫做结构体，这种类型需要在程序中创建。
	3、结构体存储区里可以包含多个子存储区，每个存储区可以用来记录一个数字。
	4、不同子存储区的类型可以不同，子存储区也可以是结构体类型。
	5、结构体声明语句用来创建结构体类型。
	6、结构体声明语句需要使用 struct 关键字。
	7、结构体声明语句中的变量声明语句不会分配内存，
	     他们只是表示结构体内部的所有子存储区类型。可以写在头文件里。
	8、结构体类型可以用来声明/*结构体变量*/，结构体变量真正分配了内存，可以用来存放数字。
	9、struct 关键字和结构体类型名称合起来才可以作为/*类型名称*/使用。
	10、typedef 关键字可以用来给现有类型名称起别名。别名可以代替原有类型名称使用。
	11、可以把结构体声明语句和起别名的语句合并成为一条语句，这个时候可以省略结构体本身的名称。

	12、C语言里不允许结构体内部包含函数！！！

*************
//结构体演示
#include<stdio.h>
/*  struct person{
        int age;    //三个子存储区 只表示类型~
        float height;   //不分配内存~
        char name[10];  //可以写在头文件里~
    };
typedef struct person   people;//起别名 people;
效果等同与下*/
typedef struct /*person省略*/{
    int age;
    float height;       //结构体声明语句与起别名语句合并
    char name[10];
}people;

int main(){
//  struct person prn;  //结构体变量prn
    people prn1;	//结构体变量prn1
    return 0;
}
********************

	13、结构体变量也应该初始化，采用数组初始化的语法进行初始化。
	14、结构体变量通常不会作为整体使用，一次通常只使用其中某个子存储区。
	15、可以在结构体变量名称后加 . 再加子变量名称的方法表示结构体内部的某个子存储区
	
*****************
#include<stdio.h>
typedef struct /*person省略*/{
    int age;
    float height;       //结构体声明语句与起别名语句合并
    char name[10];
}people;

int main(){
    people prn1 = {20,1.73f,"abc"};
    printf("age is %d\n",prn1.age);
    printf("height is %g\n",prn1.height);
    printf("name is %s\n",prn1.name);
    return 0;
}

****************

【练习】
	从键盘上得到一个人的年龄，身高，姓名。

*****************
#include<stdio.h>
typedef struct /*person省略*/{
    int age;
    float height;       //结构体声明语句与起别名语句合并
    char name[10];
}people;

int main(){
    people prn1 = {20,1.73f,"abc"};
    printf("plz input age:");
    scanf("%d",&(prn1.age));
    printf("plz input height:");
    scanf("%g",&(prn1.height));
    scanf("%*[^\n]");   //清理
    scanf("%*c");       //缓存
    printf("plz input name:");
    fgets(prn1.name,10,stdin);
    printf("age is %d\n",prn1.age);
    printf("height is %g\n",prn1.height);
    printf("name is %s\n",prn1.name);
    return 0;
}
***************


	16、同类型结构体变量之间可以直接赋值。
		【e.g.】 prn2 = prn1;


                      

			/*二、结构体指针*/

	1、结构体指针可以记录一个结构体存储区的地址。
	2、当结构体指针和结构体存储区捆绑以后可以在结构体指针后加 -> 
		再加子存储区名称来表示这个子存储区。

*****************
//struct
#include<stdio.h>
typedef struct{
    int age;
    float height;
    char name[10];
}person;

int main(){
    person prn = {19,1.68,"abc"};
    person *p_person = &prn;       //声明结构体指针
    printf("%d\n",p_person->age);
    printf("%g\n",p_person->height);
    printf("%s\n",p_person->name);
    return 0;
}
**************

【练习】
	(1)、声明一个结构体，这个结构体声明的变量可以记录一个点的位置。
	   再声明一个结构体，这个结构体声明的变量可以记录一个水平长方形的位置。
	
	(2)、从键盘得到两个点的位置 算出他们中间点的位置 并打印
	   (用结构体指针和结构体变量分别表示)

//练习
#include<stdio.h>
typedef struct{
    int row;
    int col;
}point;

typedef struct{
    point pt1,pt2;  
}rect;
/*方法一：用结构体变量。
int main(){
    point pt1 = {0,0},pt2 = {0,0},pt_mid = {0,0};
    printf("plz input the adress of pt1:");
    scanf("%d%d",&(pt1.row),&(pt1.col));
    printf("plz input the adress of pt2:");
    scanf("%d%d",&(pt2.row),&(pt2.col));
    pt_mid.row = (pt1.row + pt2.row) / 2;
    pt_mid.col = (pt1.col + pt2.col) / 2;
    printf("middle of two point is %d %d\n",pt_mid.row,pt_mid.col);
    return 0;
}
*/
//方法二：结构体指针。
int main(){
    point pt1 = {0,0},pt2 = {0,0},mid = {0,0};
    point *p_pt1 = &pt1;
    point *p_pt2 = &pt2;
    point *p_mid = &mid;
    printf("plz input the adress of pt1:");
    scanf("%d%d",&(pt1.row),&(pt1.col));
    printf("plz input the adress of pt2:");
    scanf("%d%d",&(pt2.row),&(pt2.col));
    p_mid->row = (p_pt1->row + p_pt2->row) / 2;
    p_mid->col = (p_pt1->col + p_pt2->col) / 2;
    printf("middle of two point is %d %d\n",p_mid->row,p_mid->col);
    return 0;
}

		


	
			/*三、结构体的应用*/
	//3.1结构体作形参
	1、结构体变量可以作为形参使用。(很麻烦~)
	2、采用结构体指针作为形参可以避免结构体做形参时，时间和空间的浪费。
	3、结构体指针做形参是尽量加 const 关键字。
			（被调用函数) 
			      ^  传					
			      |  递				
		          (调用函数） 


**************
//结构体练习
#include<stdio.h>
typedef struct{
    int row,col;
}pt;
/*ONE 结构体做形参 not good!
void print(pt pt1){
    printf("(%d, %d)\n",pt1.row,pt1.col);
}
int main(){
    pt pt1 = {4,7};
    print(pt1);
    return 0;
}
*/
//TWO 结构体指针做形参
void print(const pt *p_pt){ //结构体指针做形参时，尽量加const关键字。
    printf("(%d, %d)\n",p_pt->row,p_pt->col);
}
int main(){
    pt pt1 = {4,7};
    print(&pt1);
    return 0;
}
********************	
		
	//3.2结构体作返回值。	
	4、可以把结构体变量的内容整个作为返回值使用，
	    但是这样也会造成时间和空间的浪费。
	5、可以用结构体存储区的地址作为返回值把结构体内容传递给调用函数，
	    这样可以避免浪费。
	6、不可以把局部结构体变量的地址作为返回值使用。
			（被调用函数) 
			      |  传					
			      V	 递	 
			  (调用函数）	

#include<stdio.h>
typedef struct{
    int row,col;
}pt;


void print(pt *p_pt){ //存储区内容变化，不加const关键字。
    printf("(%d, %d)\n",p_pt->row,p_pt->col);
}

/*ONE结构体变量作返回值
pt read(void){
    pt pt1 = {0};
    printf("plz input adress of the point:");
    scanf("%d%d",&(pt1.row),&(pt1.col));
    return pt1;
}*/

//TWO
pt *read(pt *p_pt){
    printf("plz input adress of the point:");
    scanf("%d%d",&(p_pt->row),&(p_pt->col));
    return p_pt;

}
int main(){
    pt pt1 = {0},*p_pt = NULL;
    p_pt = read(&pt1);
    print(p_pt);
    return 0;
}
    

**********



【练习】
	编写函数计算水平长方形面积
	  数值从调用函数得到。

************
//练1
#include<stdio.h>
typedef struct{
    int row,col;
}pt;
typedef struct{
    pt pt1,pt2;
}rect;

int area(const rect *p_rect){  //计算面积
    int ret = (p_rect->pt1.row - p_rect->pt2.row) * (p_rect->pt1.col - p_rect->pt2.col);
    return ret >= 0 ? ret : 0 - ret;
}

int main(){
    rect r = {0};
    printf("请输入长方形的位置：");
    scanf("%d%d%d%d",&(r.pt1.row),&(r.pt1.col),&(r.pt2.row),&(r.pt2.col));
    printf("面积是：%d\n",area(&r));  
    return 0;
}

*****************




【练习】
	根据两个已知点计算中点位置，并把结果传递给调用函数。

************
//练2
#include<stdio.h>
typedef struct{
    int row,col;
}pt;

pt *midpt(const pt *p_pt1,const pt *p_pt2,pt *p_mid){
    p_mid->row = (p_pt1->row + p_pt2->row) / 2;
    p_mid->col = (p_pt1->col + p_pt2->col) / 2;
    return p_mid;
}

int main(){
    pt pt1 = {0},pt2 = {0},mid = {0}, *p_pt = NULL;
    printf("plz input a point :");
    scanf("%d%d",&(pt1.row),&(pt1.col));
    printf("plz input another point :");
    scanf("%d%d",&(pt2.row),&(pt2.col));
    p_pt = midpt(&pt1,&pt2,&mid);
    printf("the middle point is (%d, %d)\n",p_pt->row,p_pt->col);
    return 0;
}

****************

	
		

			/*四、数据对齐*/
	1、任何一个存储区的地址必须是它自身大小的整数倍
	(double 类型存储区的地址只需要是4的整数倍)
	2、结构体内部子存储区通常也需要遵守数据对齐规则。
	3、数据对齐会造成结构体内部子存储区之间有空隙。
	
***************
//数据对齐演示
#include<stdio.h>
typedef struct{
    int num;
    char ch; 
}stru;

typedef struct{
    char ch; 
    int num;
    char ch1;
}stru1;

int main(){ 
    printf("sizeof(stru) is %d\n",sizeof(stru));
    printf("sizeof(stru1) is %d\n",sizeof(stru1));
    return 0;
}
**************
运行结果：
sizeof(stru) is 8
sizeof(stru1) is 12


***************
		
			/*五、数据补齐*/
	1、结构体存储区的大小必须是他内部占地最大基本类型存储区大小的整数倍。
	   (如果占地最大基本类型是double类型则之需要是4的整数倍就可以了。)
	2、数据补齐会造成结构体后面有浪费的字节。
	


【练习】
	编写函数从两个圆里找到面积比较大的，并返回给调用函数。


#include<stdio.h>
typedef struct{
    int row,col;
}pt;

typedef struct{
    pt center;	//结构体嵌套~
    int radius;
}circle;

const circle *larger(const circle *p_cl1,const circle *p_cl2){
    return p_cl1->radius >= p_cl2->radius ? p_cl1 : p_cl2;
}

int main(){
    circle cl1 = {0},cl2 = {0};
    const circle *p_cl = NULL;
    printf("piz input address of one circle:");
    scanf("%d%d%d",&(cl1.center.row),&(cl1.center.col),&(cl1.radius));
    printf("piz input address of another circle:");
    scanf("%d%d%d",&(cl2.center.row),&(cl2.center.col),&(cl2.radius));
    p_cl = larger(&cl1,&cl2);
    printf("result is ((%d, %d), %d)\n",p_cl->center.row,p_cl->center.col,p_cl->radius);
    return 0;
}






***************************************************
预习：
	1、枚举，联合
	2、二级指针
	3、函数指针
	4、回调指针
	5、动态内存分配


作业：
	编写函数从两个线段里挑 出比较长的并返回给调用函数。
	 线段长度的平方 = 行之差的平方 + 列之差的平方 
#include<stdio.h>.
typedef struct{
    int row,col;
}pt;

typedef struct{
    pt pt1,pt2;
}line;

const line *longer(const line *p_l1,const line *p_l2){
    int m = (((p_l1->pt1.row - p_l1->pt2.row) * (p_l1->pt1.row - p_l1->pt2.row)) + ((p_l1->pt1.col - p_l1->pt2.col) * (p_l1->pt1.col - p_l1->pt2.col)));
    int n = (((p_l2->pt1.row - p_l2->pt2.row) *(p_l2->pt1.row - p_l2->pt2.row)) + ((p_l2->pt1.col - p_l2->pt2.col) * (p_l2->pt1.col - p_l2->pt2.col)));
/*
    int m = sqrt(((p_l1->pt1.row - p_l1->pt2.row),2) + sqrt((p_l1->pt1.col - p_l1->pt2.col),2));
    int n = sqrt(((p_l2->pt1.row - p_l2->pt2.row),2) + sqrt((p_l2->pt1.col - p_l2->pt2.col),2));
*/
    return m > n ? p_l1 : p_l2;
}
int main(){
    line l1 = {0},l2 = {0};
    const line *p_l = NULL;
    printf("plz input 1st line :");
    scanf("%d%d%d%d",&(l1.pt1.row),&(l1.pt1.col),&(l1.pt2.row),&(l1.pt2.col));
    printf("plz input 2nd line :");
    scanf("%d%d%d%d",&(l2.pt1.row),&(l2.pt1.col),&(l2.pt2.row),&(l2.pt2.col));
    p_l = longer(&l1,&l2);
    printf("The longer is (%d, %d),(%d, %d)\n",p_l->pt1.row,p_l->pt1.col,p_l->pt2.row,p_l->pt2.col);
    return 0;
}

****************

//Mr.Yang
#include<stdio.h>
typedef struct{
    int row,col;
}pt;

typedef struct{
    pt pt1,pt2;
}line;

int len2(const line *p_l){
    return (p_l->pt1.row - p_l->pt2.row) * (p_l->pt1.row - p_l->pt2.row) + (p_l->pt1.col - p_l->pt2.col)*(p_l->pt1.col - p_l->pt2.col);
}

const line *longer(const line *p_l1,const line *p_l2){
    return len2(p_l1) > len2(p_l2) ? p_l1 : p_l2;
    
int main(){
    line l1 = {0},l2 = {0};
    const line *p_l = NULL;
    printf("plz input 1st line :");
    scanf("%d%d%d%d",&(l1.pt1.row),&(l1.pt1.col),&(l1.pt2.row),&(l1.pt2.col));
    printf("plz input 2nd line :");
    scanf("%d%d%d%d",&(l2.pt1.row),&(l2.pt1.col),&(l2.pt2.row),&(l2.pt2.col));
    p_l = longer(&l1,&l2);
    printf("The longer is (%d, %d),(%d, %d)\n",p_l->pt1.row,p_l->pt1.col,p_l->pt2.row,p_l->pt2.col);
    return 0;
}





/**************************************************************************/
*									   *		
*				day_14					   *	
*									   *
/**************************************************************************/	

	
	
	
	
			/*枚举和联合*/

	//枚举	enum
	1、枚举也可以用来创建新的数据类型
	2、枚举类型存储区就是一个整数类型存储区，
	   这种存储区里应该只能记录几个有限的整数。

	3、声明枚举类型时需要提供一组名称，每个名称对应一个整数。	
	    这些整数才可以放到枚举类型存储区里。
	4、声明枚举类型时需要使用 enum 关键字。
	5、枚举类型中第一个名字对应的整数是0，向后依次递增。
	6、可以在生命枚举类型时指定某个名称对应的数字，
           它后面的名称对应的数字也会随着改变。


****************
//枚举类型演示
#include<stdio.h>
int main(){
    enum /*season可以省略*/ {SPRING,SUMMER = 5,AUTUMN,WINTER};  //分别对应0123
    printf("spring is %d\n",SPRING);
    printf("summer is %d\n",SUMMER);
    printf("autumn is %d\n",AUTUMN);
    printf("winter is %d\n",WINTER);
    return 0;
}
***************

	//联合	union
	1、联合也可以用来创建新的数据类型。
	2、联合存储区可以当作多种不同类型存储区使用。
	3、声明联合的时候需要使用 union 关键字。
	4、联合中每个变量声明语句表示联合存储区的一种使用方法，
	    所有子变量的存储区是互相重叠的。
	5、联合存储区的大小是其中最大子变量存储区的大小。

**************
//联合演示
 #include <stdio.h>
typedef union {     //关键字不同
    char ch;        //其他类似与结构体
    int num;    
}un;     

 int main(){
    un un1;
    un1.num = 0;
    un1.ch = 'a';   //修改ch子存储区 上一个num存储区也受影响
    printf("un1.num is %d\n",un1.num);
    return 0;
 }
*************




			/*二级指针*/
	1、记录普通变量地址的指针叫做一级指针。
	2、二级指针可以记录一级指针的地址。二级指针声明的时候需要写两个*
	3、二级指针变量名称前加**可以表示捆绑的普通变量存储区。
	4、二级指针变量名称前加*表示捆绑的一级指针变量存储区。
	5、二级指针变量名称可以代表它自己的存储区。
	6、二级指针可以用来代表/*指针数组*/，但是不能代表二维数组。

***********
//二级指针代表指针数组
#include <stdio.h>

int main(int argc,char **argv){
    int num = 0;
    for (num = 0;num <= argc - 1;num++){
        printf("%s\n",*(argv + num));
    }   
    return 0;
}
**************


	7、二级指针通常作为函数的形参使用。
	     它可以让被调用函数修改调用函数的一级指针存储区。


*******************
//二级指针形参演示
#include <stdio.h>
void setnull(int **pp_num){
    *pp_num = NULL;
}
int main(){
    int num = 0;
    int *p_num = &num;
    setnull(&p_num);
    printf("p_num is %p\n",p_num);
    return 0;
}
**************


	8、无类型指针使用的时候有可能需要首先转换成二级指针然后再使用。 
	

【练习】
	将昨天作业用二级指针无返回值修改。



	
			/*函数指针*/
	
	
	1、C语言里函数也有地址。函数名称可以表示函数的地址，
	2、函数指针用来记录函数的地址，函数指针也需要先声明再使用。
	3、函数指针声明可以根据函数声明变化得到。
	4、函数指针也分类型，不同类型的函数指针适合与不同的函数捆绑。
	5、函数指针可以用来调用函数。

		声明函数指针方法： 返回值类型 /*删去函数名*/(*p_func)(形参) 
			被捆绑函数： int add(int num1,int num2)
			 函数指针 ： int (*p_func)(int, int)
	

***************
//函数指针演示
#include <stdio.h>
int add(int num1,int num2){
    return num1 + num2;
}
int main(){
    int (*p_func)(int, int) = NULL;     //声明函数指针并初始化
    printf("add is %p\n",add);
    p_func = add;           //函数指针和函数捆绑
    printf("4+9 is %d\n",p_func(4,9));
    return 0;
}
*************





	
			/*回调函数*/
	1、函数指针可以作为函数的形参使用。
	2、可以作为实际参数使用的函数叫做回调函数。



****************************
//回调函数演示
#include <stdio.h>
void print(int *p_num,int size){
    int num = 0;
    for (num = 0;num <= size - 1;num++){
        printf("%d ",*(p_num + num));
    }   
}

int main(){
    int arr[] = {1,2,3,4,5};
    print(arr,5);
    printf("\n");
    return 0;
}
/********************
*	| |         *
*   改 	| |   进    *
*	V V         *
********************/
#include <stdio.h>
void print_cb(int *p_num){
    printf("%d ",*p_num);
}
void for_each(int *p_num,int size){ //处理数组每一个存储区
    int num = 0;
    for (num = 0;num <= size - 1;num++) {
        print_cb(p_num + num);
    }   
}
int main(){
    int arr[] = {1,2,3,4,5};
    for_each(arr,5);
    printf("\n");
    return 0;
}
/********************
*	| |         *
*   改 	| |   进    *
*	V V         *
********************/
#include <stdio.h>
void print_cb(int *p_num){
    printf("%d ",*p_num);
}
void for_each(int *p_num,int size,void (*p_func)(int*)){    //处理数组每一个存>储区   
    int num = 0;
    for (num = 0;num <= size - 1;num++) {
        p_func(p_num + num);    //函数名称换为函数指针名称
    }   
}
int main(){
    int arr[] = {1,2,3,4,5};
    for_each(arr,5,print_cb);   //函数指针和print_cb函数捆绑
    printf("\n");
    return 0;
}

**********************






			/*动态内存分配*/
	1、动态内存分配可以在程序运行的时候临时决定需要分配多少个存储区。
	2、为了使用动态内存分配需要使用一组标准函数,
	    为了使用这组标准函数需要包含stdlib.h头文件。
	

	/*malloc函数*/ 可以动态分配一组连续的字节。
	1、这个函数需要一个整数类型参数表示要分配的字节个数。
	2、它的返回值是分配好的第一个字节的地址。如果分配失败返回的是 NULL。
	3、这个函数的返回值存放在一个无类型指针存储区里，
             需要转换成有类型指针然后才能使用。
	


			/*动态内存释放*/

	1、不使用的动态分配内存必须还给计算机。
	
	/*free函数*/ 可以用来释放动态分配内存
	1、这个函数需要动态分配内存的首地址作为参数。
	2、一起分配的内存必须一起释放。
	3、如果用指针作为参数调用free函数，则函数结束后指针成为野指针，须恢复成空指针。	
	


*****************
//动态分配内存演示
#include <stdio.h>
#include <stdlib.h>
int main(){
    int *p_num = (int *)malloc(5 * sizeof(int)); //分配5个int类型的内存
    //malloc分配的是无类型指针，需要强制类型转换
    int num = 0;
    if (p_num){         //分配内存成功
          for (num = 0;num <= 4;num++){
                *(p_num + num) = num + 1;
          }   
          for (num = 0;num <= 4;num++){
                printf("%d ",*(p_num + num));
          }   
          printf("\n");
        free(p_num);    //释放内存	
        p_num = NULL;	//指针恢复成空指针
    }   
    return 0;
}
*************
运行结果：
1 2 3 4 5
*************




	4、动态分配内存函数可以使用被调用函数动态分配的内存。


******************
//动态内存分配 演示
#include <stdio.h>
#include <stdlib.h>
int *read(void){
    int *p_num = (int *)malloc(sizeof(int));
    if (p_num) {
        printf("plz input a number:");
        scanf("%d",p_num);
    }   
    return p_num;   //如果分配不成功 返回值为NULL
}

int main(){
    int *p_num = read();
    if (p_num) {    //只处理分配成功的情况
        printf("%d\n",*p_num);
        free(p_num);    //释放内存
        p_num = NULL;   //指针恢复成空指针
    }   
    return 0;
}
********************




【练习】

	编写产生一张彩票，彩票里的所有数字要记录在动态分配内存里，
	彩票内容要传递给调用函数并打印在屏幕上。

//彩票3.0
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int *print(void){
    int *p_num = (int *)malloc(7 * sizeof(int));
    int num = 0;
    srand(time(0));
    if (p_num) {
        for (num = 0;num <= 6;num++){
            *(p_num + num) = rand() % 36 + 1;
        }   
    }   
    return p_num;
}

int main(){
    int num = 0;
    int *p_num = print();
    if (p_num){
        for(num = 0;num <= 6;num++){
            printf("%d ",*(p_num + num));
        }   
        printf("\n");
        free(p_num);
        p_num = NULL;
    }   
    return 0;
}


***************

【练习】

	编写函数根据两个已知点的位置计算中间点的位置，
	中间点的位置记录在动态分配内存里。
	把中间点位置传递给调用函数并打印。

******************
//昨天作业 改1.0
#include <stdio.h>
typedef struct{
    int row,col;
}pt;
typedef struct{
    pt pt1,pt2;
}line;
/* Mr.Yang
//计算线段长度平方的函数
int len2(const line *p_l) {
    return (p_l->pt1.row - p_l->pt2.row) * (p_l->pt1.row - p_l->pt2.row) + (p_l->pt1.col - p_l->pt2.col) * (p_l->pt1.col - p_l->pt2.col);
}
//挑出比较长线段的函数
void longer(const line *p_l1, const line *p_l2, line **pp_l) {
    *pp_l = (line *)(len2(p_l1) > len2(p_l2) ? p_l1 : p_l2);
}*/

void longer(const line *p_l1,const line *p_l2,line **pp_l){
    int m = (((p_l1->pt1.row - p_l1->pt2.row) * (p_l1->pt1.row - p_l1->pt2.row)) + ((p_l1->pt1.col - p_l1->pt2.col) * (p_l1->pt1.col - p_l1->pt2.col)));
    int n = (((p_l2->pt1.row - p_l2->pt2.row) *(p_l2->pt1.row - p_l2->pt2.row)) + ((p_l2->pt1.col - p_l2->pt2.col) * (p_l2->pt1.col - p_l2->pt2.col)));
     *pp_l =(line *)(m > n ? p_l1 : p_l2);
}

int main(){
    line l1 = {0},l2 = {0};
    line *p_l = NULL;
    printf("plz input 1st line:");
    scanf("%d%d%d%d",&(l1.pt1.row),&(l1.pt1.col),&(l1.pt2.row),&(l1.pt2.col));
    printf("plz input 2ed line:");
    scanf("%d%d%d%d",&(l2.pt1.row),&(l2.pt1.col),&(l2.pt2.row),&(l2.pt2.col));
    longer(&l1,&l2,&p_l);
    printf("The longer is (%d, %d),(%d, %d)\n",p_l->pt1.row,p_l->pt1.col,p_l->pt2.row,p_l->pt2.col);
    return 0;
}


**************
预习：
	文件操作


作业：
	编写字符串拷贝函数(新字符串记录在动态分配内存里)
	函数把新字符串传递给调用函数并打印。


/*编写字符串拷贝函数(新字符串记录在动态分配内存里)
    函数把新字符串传递给调用函数并打印。*/
【Gang】
#include <stdio.h>
#include <stdlib.h>
    int num = 0;
char *print(char *p_num){
    char *p_copy = (char *)malloc(10*sizeof(char));
    if (p_copy){
        for(num = 0;num <= 9;num++){
            *(p_copy + num) = *(p_num + num);
        }   
    }   
    return p_copy;
}   

int main(){
    char str[10] = {0};
    printf("plz input a string:");
    fgets(str,10,stdin);
    char *p_num = print(str);
    if (p_num){
        for(num = 0;num <= 6;num++){
            printf("%c ",*(p_num + num));
        }   
        printf("\n");
        free(p_num);
        p_num = NULL;
    }   
    return 0;
}

//Mr.Yang
//字符串拷贝作业
#include <stdio.h>
#include <stdlib.h>
char *mystrcpy(char *str){
    char *p_tmp = str,*p_dest = NULL;
    char *p_tmp1 = NULL;
    int cnt = 0;
    //计算字符串所占空间
    while (*p_tmp) {    //p_tmp指向'\0' 时 *p_tmp = 0
        cnt++;
        p_tmp++;    //指针后移
    }   
    cnt++;
    p_dest = malloc(cnt *sizeof(char));
    if (p_dest){
        p_tmp = str;    //p_tmp指针和原有字符串第一个存储区捆绑
        p_tmp1 = p_dest;
        while(*p_tmp){
            *p_tmp1 = *p_tmp;
            p_tmp++;
            p_tmp1++;
        }   
        *p_tmp1 = 0;    //在新字符串末尾加入"\0"
    }   
    return p_dest;
}
int main(){
    char *str = mystrcpy("abcdef");
    if (str){
        printf("%s\n",str);
        free(str);
        str = NULL;
    }   
    return 0;
}





/**************************************************************************/
*									   *		
*				day_15					   *	
*									   *
/**************************************************************************/	

	一、动态内存分配(续)
	二、文件
	

			/*一、动态内存分配(续)*/
	//calloc函数
	void *calloc(size_t n,size_t size);

	1、它可以把所有动态分配存储区的内容设置成 0。
	2、为了使用这个函数也需要包含stdlib.h头文件。
	3、它的返回值与malloc函数一样，是分配好的第一个字节的地址。
	   如果分配失败返回的是 NULL。
	4、它需要两个参数，第一个参数表示要分配的存储区个数，
			  第二个参数表示单个存储区的大小。


	//realloc函数
	1、它可以调整动态分配内存的大小。
	2、尽量少使用这个函数！！！






			/*二、文件*/

	1、文件里一定采用二进制方式记录数字。
	2、如果文件里所有字节都是字符的ASCII码，这种文件叫做//文本文件。
		文本文件以外的文件叫做//二进制文件。
	3、所有文件都可以采用二进制方式操作。
	4、文件操作基本步骤：
		(1)打开文件(fopen)
		(2)操作文件(fread/fwrite)
		(3)关闭文件(fclose)
	




	//fopen函数
	1、fopen函数需要两个参数：
		第一个代表要打开的文件路径，
		第二个代表打开方式(决定程序中可以怎么使用文件)。	
	2、打开方式有如下选择：
		"r"	只能查看文件内容而且只能从文件头开始，
			要求文件已经存在，如果不村在就会打开失败。	
		
		"r+"	比"r"多了修改功能(要求文件已经存在)。

		"w"	只能修改文件内容而且只能从文件头开始修改。
			如果文件还不存在就创建文件，
			如果文件存在就删除文件内容。
		
		"w+"	比"w"多了个查看目录。

		"a"	只能在文件末尾追加新内容。
			如果文件不存在就创建文件，
			如果文件存在就保留原有内容。

		"a+"	比"a"多了查看功能。

		"b"	可以和上面任何一种打开方式混合使用~~~
			它表示以二进制方式操作文件。

	3、fopen函数返回值是文件指针，只有文件指针才可以在程序中代表文件。
	4、fopen函数有可能失败，如果失败返回值是 NULL
		(类似与malloc函数)

	//fclose函数
	1、一旦完成对文件的操作后必须使用fclose函数关闭文件。
	2、fclose函数需要文件指针作为参数。
	3、文件关闭后文件指针成为野指针，必须恢复成空指针。
		(类似与free函数~)	
	



*******************

//文件操作代码框架
#include <stdio.h>
int main(){
    FILE *p_file = fopen("a.txt"/*文件路径*/,"w"/*操作方式*/);
    //文件指针打开文件
/*写法一
    if (p_file) {
        //文件打开成功
        fclose(p_file);     //打开的文件不关闭会造成内存泄露!!! 
        p_file = NULL;
    }
*/
//写法二：
    if (!p_file) {
        //文件打开失败
        return 0;
    }   
    //打开成功
    fclose(p_file);
    p_file = NULL;
    return 0;
}

*****************

		


		//文件操作
	1、文件操作分为两种:
		(I)  把内存中一组连续存储区的内容拷贝到文件里(写文件)
		(II) 从文件中把一组连续的内容拷贝到内存里(读文件)
	
	2、fwrite函数可以以二进制方式对文件进行写操作。
	   fread函数可以以二进制的方式对文件进行读操作。


		这两个函数都需要四个参数：
	 	
			a.	内存里第一个存储区的地址
			b.	内存里单个存储区的大小
			c.	希望操作的存储区个数
			d.	文件指针

	  它们的返回值表示实际操作的存储区个数。0 代表没有进行读写操作。



*************	
//fwrite演示
#include <stdio.h>

int main(){
    int arr[] = {1,2,3,4,5},size = 0;
    FILE *p_file = fopen("a.bin","wb");
    if (p_file) {
        size = fwrite(arr,sizeof(int),5,p_file);
//返回值表示实际操作的存储区个数   
        printf("size is %d\n",size);
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}
**************

【练习】
	编写程序从a.bin文件获得所有存储区的内容并把结果打印在屏幕上。

【Gang】
#include <stdio.h>
int main(){
    int arr[5] = {0},num = 0;
    int *p_num = arr;
    FILE *p_file = fopen("a.bin","rb");
    if(p_file){
        fread(arr,sizeof(int),5,p_file);
        for(num = 0;num <= 4;num++){
            *(p_num + num) = arr[num];
        }   
        for(num = 0;num <= 4;num++){
            printf("%d ",*(p_num + num));
        }   
        printf("\n");
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}


//Mr.Yang
#include <stdio.h>
int main(){
    int arr[5] = {0},num = 0;
    FILE *p_file = fopen("a.bin","rb");
    if(p_file){
        fread(arr,sizeof(int),5,p_file);
        for(num = 0;num <= 4;num++){
            printf("%d ",arr[num]);
        }   
        printf("\n");
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}
***************
运行结果：
size is 5
1 2 3 4 5
***************





******************
//文本文件
#include<stdio.h>
#include<string.h>
int main(){
    char str[] = "1,2,3,4,5";   //字符串字面值初始化数组
    FILE *p_file = fopen("a.txt","wb");
    if (p_file) {
        fwrite(str,sizeof(char),strlen(str)/*数出字符个数*/,p_file);
        fclose(p_file);
        p_file = NULL;
    }       
    return 0;
}
******************
运行结果
生成一个a.txt的文本



	//fprintf函数
	1、fprintf函数按照格式把数据记录到文本文件里。
	2、这个函数的第一个参数是一个文件指针，其他参数和printf函数的参数一样。


*************	
//文本文件演示
#include <stdio.h>

int main(){
    int arr[] = {1,2,3,4,5},num = 0;
    FILE *p_file = fopen("b.txt","w");
    if(p_file){
        for (num = 0;num <= 4;num++){
            fprintf(p_file,"%d ",arr[num]); //将数据记录到文件里
        }   
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}
*************



	//fscanf函数
	1、fscanf函数可以按照格式从文本文件里获得数据并记录到存储区里。
	2、这个函数的第一个参数是一个文件指针，其他参数和scanf函数一样。



*************
#include <stdio.h>
int main(){
    int num = 0,num1 = 0;
    FILE *p_file = fopen("b.txt","r");
    if (p_file) {
        for (num = 0;num <= 4;num++) {
            fscanf(p_file,"%d",&num1);  //将文件里的数据读到num1里
            printf("%d ",num1);
        }   
        printf("\n");
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}

*************



	
			/*文件的位置指针*/


	1、计算机里为每个打开的文件保留一个整数，这个整数表示下一次读写操作的开始位置。
	2、这个整数表示从文件头开始到这个位置为止中间包含的字节个数。
	3、这个整数叫做文件的位置指针。
	4、当从文件里获得n个字节或写入n个字节后，这个整数会增加n	
	    【e.g.】 	 b.txt
				
		1 2 3 4 5 
	       |
	       V
	    位置指针

	//ftell函数
	1、ftell函数可以获得当前位置指针的数值。
	

	//rewind函数
	1、rewind函数可以把位置指针的数值设置成 0


	//fseek函数
	1、fseek函数可以把位置指针设置成文件中的任何位置。
	2、fseek函数使用时需要指定一个基准位置和目标位置到基准位置之间的距离。

	SEEK_SET	0	把文件头作为基准位置
	SEEK_CUR	1	把当前位置作为基准位置
	SEEK_END	2	把文件尾作为基准位置

	   如果目标位置在基准位置后，则距离是正数。
	   如果目标位置在基准位置前，则距离是负数。
	
	   距离的数字代表两个位置之间包含的字节个数。


***************
//位置指针演示
#include <stdio.h>
int main(){
    char ch = 0;
    FILE *p_file = fopen("abc.txt","rb");
    if (p_file) {
        fseek(p_file,2,SEEK_SET);  //将位置指针置于文件头后2位
        printf("%ld\n",ftell(p_file));  //打印位置指针当前位置
        fread(&ch,sizeof(char),1,p_file);//读1个字符
        printf("%c\n",ch);
    
        fseek(p_file,4,SEEK_CUR);  //将位置指针置于当前位置后4位
        printf("%ld\n",ftell(p_file));
        fread(&ch,sizeof(char),1,p_file); 
        printf("%c\n",ch);
            
        fseek(p_file,-4,SEEK_END);  //将位置指针置于文件尾前4位
        printf("%ld\n",ftell(p_file));
        fread(&ch,sizeof(char),1,p_file);
        printf("%c\n",ch);

        rewind(p_file);         //把位置指针设置成0
        printf("%ld\n",ftell(p_file));
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;
}
************



【练习】
	编写模拟人员管理系统，可以把多个人员信息以二进制方式记录到文件里，
	每个人员信息包括整数类型的id，float 类型的salary 和最多9个字符的姓名
	文件内容可以追加。

#include <stdio.h>
typedef struct{
    int id; 
    float salary;
    char name[9];

}person;

int main(){
    person prn = {0};
    int choice = 0;
    FILE *p_file = fopen("person.bin","ab");
    if (p_file){
        while(1){
            printf("plz input id :");
            scanf("%d",&(prn.id));
    
            printf("plz input salary:");
            scanf("%g",&(prn.salary));
            scanf("%*[^\n]"); 
            scanf("%*c");     //清理
    
            printf("plz input name:");
            fgets(prn.name,9,stdin);
    
            fwrite(&prn,sizeof(person),1,p_file);   //将信息写如文件中
            printf("1 is continue 0 is do not:");
            scanf("%d",&choice);
            if (!choice) {
                break;
            }   
        }   
        fclose(p_file);
        p_file = NULL;
    }   
    return 0;   
}





**********************************

作业：
	编写程序从person.bin文件里得到所有人员id并把他们打印在屏幕上。

【Gang】
#include <stdio.h>

int main(){
    int id = 0;
    FILE *p_file = fopen("person.bin","rb");
    if (p_file) {
        while(/*囧...循环体不会写T-T*/){
            fread(&id,sizeof(int),1,p_file);
            printf("%d\n",id);
            fseek(p_file,16,SEEK_CUR);
        }   
        fclose(p_file);
        p_file = NULL;
    }   

    return 0;
}
*************************
【改:】//循环体
        while(1){

            if(!fread(&id,sizeof(int),1,p_file)){
                break;//不能获得下一个id的时候结束循环。
            }
*************************

//Mr.Yang
//文件作业
#include <stdio.h>
typedef struct{
    int id;
    float salary;
    char name[10];
}person;

int main(){
    int id = 0;
    FILE *p_file = fopen("person.bin","rb");
    if(p_file){
        while(1){

            if(!fread(&id,sizeof(int),1,p_file)){
                break;//不能获得下一个id的时候结束循环。
            }
            printf("%d\n",id);
            fseek(p_file,sizeof(person) - sizeof(int),SEEK_CUR);
            //结构体大小 - int类型大小 = id 之间的距离
        }
    }
    return 0;
}










/**************************************************************************/
*									   *		
*				day_16					   *	
*									   *
/**************************************************************************/


【练习】
	编写程序实现文件拷贝功能
	程序必须可以按如下方式使用
	./a.out	   文件路径1(原文件)    文件路径2(新文件)



********************
//Mr.Yang
int main(int argc,char **argv){
    char buf[100] = {0};
    int size = 0;
    FILE *p_src = NULL,*p_dest = NULL;
    //打开原始文件
    p_src = fopen(*(argv + 1),"rb");
    if(!p_src){
        printf("原始文件打开失败\n");
        return 0;
    }
    //打开新文件
    p_dest = fopen(*(argv + 2),"wb");
    if(!p_dest){
        printf("原始文件打开失败\n");
        //关闭原始文件
        fclose(p_src);
        p_src = NULL;
        return 0;
    }
    while(1){
        size = fread(buf,sizeof(char),100,p_src);
        if (!size){
        //不能从原始文件里获得任何数字时，结束循环。
            break;
        }
        fwrite(buf,sizeof(char),size,p_dest);

    }
    //关闭新文件
    fclose(p_dest);
    p_dest = NULL;
    //关闭原始文件
    fclose(p_src);
    p_src = NULL;
    return 0;
}
****************** 


	项目：
	【贪吃蛇】
@  苹果
+  蛇头
-  蛇尾    


/*
	Mr.Yang贪吃蛇
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define		SIZE	  40
enum {UP = 5,DOWN =2 ,LEFT = 1,RIGHT = 3};
typedef struct{
    int row,col;
}pt;

typedef struct{
    pt head,tail;
}snake;
//part.1 设置蛇初始的位置
void init_snake(snake *p_snake){
	p_snake->head.row = 20;	 
	p_snake->head.col = 20;	 
	p_snake->tail.row = 20;	 
	p_snake->tail.col = 21;
}

//part.2 设置苹果初始位置
void init_apple(pt *p_apple){
	p_apple->row = rand() % SIZE;
	p_apple->col = rand() % SIZE;
}

//part.3 移动蛇位置
void move_snake(snake *p_snake){
	pt tmp = {0};
	int direction = 0;
	printf("请选择移动方向(UP = 5,DOWN =2 ,LEFT = 1,RIGHT = 3):");
	scanf("%d",&direction);
	tmp = p_snake->head;//tmp变量记录移动后蛇头移动后的位置
	switch(direction){
		case UP:	
			tmp.row--;
			break;
		case DOWN:
			tmp.row++;
			break;
		case LEFT:
			tmp.col--;
			break;
		case RIGHT:
			tmp.col++;
			break;
		default:
			break;			
	}
	//检查移动后的位置是否合理
	if (tmp.row < 0 || tmp.row > SIZE - 1) {
		return ;
	}
	if (tmp.col < 0 || tmp.col > SIZE - 1) {
		return ;
	}
	//检查是否头尾重叠
	if (tmp.row == p_snake->tail.row && tmp.col == p_snake->tail.col) {
		return ;
	}
	//上面三种情况没有发生,移动~
	p_snake->tail = p_snake->head;
	p_snake->head = tmp;
}

//part.4 判断蛇和苹果位置是否重叠
int overlap(const pt *p_apple,const snake *p_snake){
	 //不修改存储区,需要加const
	if((p_snake->head.row ==  p_apple->row) && (p_snake->head.col == p_apple->col)){
		return 1;
	}
	else if(p_apple->row == p_snake->tail.row && p_apple->col == p_snake->tail.col){
		return 1;
	}
	else{
		return 0;
	}
}

//part.5 显示所有内容
void show_map(const pt *p_apple,const snake *p_snake){
		//只显示,不修改,需要加const
	int row = 0,col = 0; 
	for(row = 0;row <= SIZE - 1;row++){
		for(col = 0;col <= SIZE - 1;col++) {
			if(row == p_snake->head.row && col == p_snake->head.col){
				printf("+");
			}
			else if(row == p_snake->tail.row && col == p_snake->tail.col){
				printf("-");
			}
			else if(row == p_apple->row && col == p_apple->col){
				printf("@");
			}
			else{
				printf(" ");
			}
		}
		printf("\n");
	}
}


int main(){
	srand(time(0));
	snake snk = {0};
	pt apple = {0};	

	init_apple(&apple);
	init_snake(&snk);
	//确定苹果和蛇的位置不重叠
	while(1){
		if(overlap(&apple,&snk)){
			//位置重叠就重新设置苹果位置
			init_apple(&apple);
		}
		else{
			break;	
		}
	}
	//显示初始全部内容
	show_map(&apple,&snk);
	while(1){		
		move_snake(&snk);
		//检查蛇和苹果是否重叠,如果重叠,重蛇苹果位置。
		while(1){
			if(overlap(&apple,&snk)){
				init_apple(&apple);
			}
			else{
				break;
			}
		}
		show_map(&apple,&snk);
	}
 
	return 0;
}












***********************
牢固掌握：

	1、指针
	2、结构体
	3、动态分配内存
	4、函数。








